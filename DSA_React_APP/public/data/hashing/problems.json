[
  {
    "name": "Longest Consecutive Sequence",
    "endpoint": "/api/hashing/longest-consecutive",
    "methodName": "longestConsecutive",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [100, 4, 200, 1, 3, 2] },
    "description": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence (elements that follow each other in sequential order). The sequence must be consecutively increasing by 1 each time. For example, in the array [100, 4, 200, 1, 3, 2], the longest consecutive sequence is [1, 2, 3, 4], which has a length of 4. Similarly, for [0, 3, 7, 2, 5, 8, 4, 6, 1], the longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8], which has a length of 9. Note that elements can appear in any order in the array, and we're only interested in finding the length of the longest sequence that can be formed.",
    "approach": "1. This problem requires finding the longest consecutive sequence of integers in an unsorted array.\n2. A naive approach would be to sort the array and then find consecutive sequences, but this would take O(n log n) time.\n3. Using a HashSet allows us to solve this more efficiently in O(n) time:\n   a. Insert all array elements into a HashSet for O(1) lookup time.\n   b. For each element in the HashSet:\n      - Check if it's the start of a sequence by verifying that (element-1) is not in the set.\n      - If it's a sequence start, count consecutive elements by checking if (element+1), (element+2), etc. exist in the set.\n      - Update the longest sequence length found so far.\n4. The key optimization is only starting sequence checks from potential sequence beginnings (where num-1 is not present).\n5. This ensures each element is part of at most one sequence check, giving us O(n) time complexity overall.\n6. Steps in detail:\n   a. Add all array elements to a HashSet.\n   b. For each element in the set, if it's a potential sequence start (num-1 not in set):\n      - Initialize count to 1 and start checking consecutive elements.\n      - While (num+count) exists in the set, increment count.\n      - Update the longest sequence found so far.\n7. Time Complexity: O(n) where n is the number of elements in the array.\n   - Each element is added to the HashSet once: O(n).\n   - Each element is checked at most twice: once as a potential sequence start and once as part of a sequence: O(n).\n8. Space Complexity: O(n) for the HashSet storing all unique elements.",
    "code": "public int longestConsecutive(int[] nums) {\n    int n = nums.length;\n    if (n == 0) return 0;\n    int longest = 1;\n    Set<Integer> st = new HashSet<>();\n    for (int i = 0; i < n; i++) {\n        st.add(nums[i]);\n    }\n    for (int it : st) {\n        if (!st.contains(it - 1)) {\n            int cnt = 1;\n            int x = it;\n            while (st.contains(x + 1)) {\n                x = x + 1;\n                cnt = cnt + 1;\n            }\n            longest = Math.max(longest, cnt);\n        }\n    }\n    return longest;\n}"
  },
  {
    "name": "Subarrays with Given Sum",
    "endpoint": "/api/hashing/subarray-sum",
    "methodName": "subarraySum",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [1, 2, 3], "k": 3 },
    "description": "Given an array of integers and a target value k, find the total number of continuous subarrays whose elements sum up exactly to k. For example, in the array [1, 2, 3] with k=3, there are 2 subarrays with sum equal to 3: [1, 2] and [3]. For [1, 1, 1] with k=2, there are 2 subarrays: [1, 1] starting at index 0 and [1, 1] starting at index 1. For more complex cases like [3, 4, 7, -2, 2, 1, 4, 2] with k=7, there are 4 subarrays: [3, 4], [7], [7, -2, 2], and [1, 4, 2]. The goal is to efficiently count all such subarrays without explicitly generating them.",
    "approach": "1. This problem requires finding the number of continuous subarrays with sum equal to k.\n2. The approach uses the concept of prefix sums combined with a HashMap to efficiently find these subarrays.\n3. A prefix sum at index i represents the sum of all elements from index 0 to i.\n4. The key insight: If we have a prefix sum prefixSum at the current position and we've seen a prefix sum (prefixSum - k) earlier, then the subarray between these positions has a sum of k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix sums and their frequencies, with an entry (0, 1) for empty subarrays.\n   b. Iterate through the array, calculating the running prefix sum.\n   c. For each position:\n      - Check if (currentPrefixSum - k) exists in the map. If it does, add its frequency to the count of valid subarrays.\n      - Update the frequency of the current prefix sum in the map.\n6. The use of a HashMap allows us to efficiently check for the existence of previous prefix sums in O(1) time.\n7. Examples:\n   - For array [1, 2, 3] and k = 3:\n     * At i=0: prefixSum=1, need prefixSum-k=-2 (not found), add (1,1) to map\n     * At i=1: prefixSum=3, need prefixSum-k=0 (found with freq 1), count=1, add (3,1) to map\n     * At i=2: prefixSum=6, need prefixSum-k=3 (found with freq 1), count=2, add (6,1) to map\n     * Final count: 2 ([1,2], [3])\n8. Time Complexity: O(n) where n is the number of elements in the array.\n9. Space Complexity: O(n) for the HashMap storing prefix sums.",
    "code": "public int subarraySum(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n    int currentPrefixSum = 0, subarrayCount = 0;\n    prefixSumMap.put(0, 1);\n    for (int i = 0; i < n; i++) {\n        currentPrefixSum += nums[i];\n        int sumToRemove = currentPrefixSum - k;\n        subarrayCount += prefixSumMap.getOrDefault(sumToRemove, 0);\n        prefixSumMap.put(currentPrefixSum, prefixSumMap.getOrDefault(currentPrefixSum, 0) + 1);\n    }\n    return subarrayCount;\n}"
  },
  {
    "name": "Longest Subarray with Given Sum",
    "endpoint": "/api/hashing/longest-subarray",
    "methodName": "longestSubarray",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [10, 5, 2, 7, 1, 9], "k": 15 },
    "description": "Given an array of integers and a target sum k, find the length of the longest contiguous subarray whose elements sum exactly to k. For example, in the array [10, 5, 2, 7, 1, 9] with k=15, the longest subarray with sum 15 is [5, 2, 7, 1], which has a length of 4. Note that there's another subarray [10, 5] with sum 15, but its length is only 2. For a more complex case like [1, -1, 5, -2, 3] with k=3, the longest subarray would be [1, -1, 5, -2], which sums to 3 and has a length of 4. The challenge is to find the longest such subarray efficiently, even when the array contains negative numbers.",
    "approach": "1. This problem requires finding the length of the longest subarray with sum equal to k.\n2. The approach uses prefix sums with a HashMap to efficiently track potential subarrays.\n3. A prefix sum at index i represents the sum of all elements from index 0 to i.\n4. The key insight: If we have a prefix sum prefixSum at the current position and we've seen a prefix sum (prefixSum - k) earlier, then the subarray between these positions has a sum of k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix sums and their earliest occurrence indices.\n   b. Iterate through the array, calculating the running prefix sum.\n   c. For each position i:\n      - If the current prefix sum equals k, then the subarray from index 0 to i has sum k (update maxLength to i+1).\n      - Check if (currentPrefixSum - k) exists in the map. If it does, calculate the length of this subarray and update maxLength if needed.\n      - Store the current prefix sum in the map ONLY if it doesn't already exist (to keep the earliest occurrence).\n6. Unlike the subarray count problem, we need to track the earliest occurrence of each prefix sum to find the longest subarray.\n7. The special case check for prefixSum == k handles subarrays that start from the beginning of the array.\n8. Examples:\n   - For array [10, 5, 2, 7, 1, 9] and k = 15:\n     * At i=0: prefixSum=10, not equal to k, add (10,0) to map\n     * At i=1: prefixSum=15, equal to k, maxLength=2, add (15,1) to map\n     * At i=2: prefixSum=17, check for prefixSum-k=2 (not found), add (17,2) to map\n     * At i=3: prefixSum=24, check for prefixSum-k=9 (not found), add (24,3) to map\n     * At i=4: prefixSum=25, check for prefixSum-k=10 (found at index 0), length=4, maxLength=4, add (25,4) to map\n     * At i=5: prefixSum=34, check for prefixSum-k=19 (not found), add (34,5) to map\n     * Final maxLength: 4 (subarray [5,2,7,1])\n9. Time Complexity: O(n) where n is the number of elements in the array.\n10. Space Complexity: O(n) for the HashMap storing prefix sums.",
    "code": "public int longestSubarray(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n    int currentPrefixSum = 0, maxLength = 0;\n    for (int i = 0; i < n; i++) {\n        currentPrefixSum += nums[i];\n        if (currentPrefixSum == k) {\n            maxLength = i + 1;\n        }\n        if (prefixSumMap.containsKey(currentPrefixSum - k)) {\n            maxLength = Math.max(maxLength, i - prefixSumMap.get(currentPrefixSum - k));\n        }\n        if (!prefixSumMap.containsKey(currentPrefixSum)) {\n            prefixSumMap.put(currentPrefixSum, i);\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "name": "Subarrays with XOR Equal to K",
    "endpoint": "/api/hashing/subarrays-with-xor-k",
    "methodName": "subarraysWithXorK",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [4, 2, 2, 6, 4], "k": 6 },
    "description": "Given an array of integers and an integer k, find the total number of contiguous subarrays whose XOR (exclusive OR) of all elements equals k. For example, in the array [4, 2, 2, 6, 4] with k=6, there are 4 subarrays with XOR equal to 6: [4, 2], [2, 2, 6], [6], and [4, 2, 2, 6, 4]. Let's calculate the XORs: XOR of [4, 2] is 4⊕2=6, XOR of [2, 2, 6] is 2⊕2⊕6=6, XOR of [6] is 6, and XOR of [4, 2, 2, 6, 4] is 4⊕2⊕2⊕6⊕4=6. For a more complex case like [5, 6, 7, 8, 9] with k=2, there's only 1 subarray: [5, 7], since 5⊕7=2. The challenge is to efficiently count all such subarrays without explicitly computing XOR for every possible subarray.",
    "approach": "1. This problem requires finding the number of subarrays with XOR equal to k.\n2. The approach uses prefix XORs with a HashMap in a similar way to the prefix sum problems.\n3. A prefix XOR at index i represents the XOR of all elements from index 0 to i.\n4. The key mathematical insight: If we have a prefix XOR prefixXOR at the current position and we need to find subarrays with XOR equal to k, then we need to find earlier positions with prefix XOR equal to (prefixXOR ⊕ k).\n   - This is because if prefix XOR of [0...i] is P1 and prefix XOR of [0...j] is P2 (j < i), then XOR of subarray [j+1...i] is P1 ⊕ P2.\n   - So, if we want this subarray XOR to be k, then P1 ⊕ P2 = k, which means P2 = P1 ⊕ k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix XORs and their frequencies, with an entry (0, 1) for empty subarrays.\n   b. Iterate through the array, calculating the running prefix XOR.\n   c. For each position:\n      - Calculate xorToRemove = currentXor ⊕ k.\n      - Check if xorToRemove exists in the map. If it does, add its frequency to the count of valid subarrays.\n      - Update the frequency of the current prefix XOR in the map.\n6. Examples:\n   - For array [4, 2, 2, 6, 4] and k = 6:\n     * At i=0: prefixXOR=4, need prefixXOR⊕k=4⊕6=2 (not found), add (4,1) to map\n     * At i=1: prefixXOR=4⊕2=6, need prefixXOR⊕k=6⊕6=0 (found with freq 1), count=1, add (6,1) to map\n     * At i=2: prefixXOR=6⊕2=4, need prefixXOR⊕k=4⊕6=2 (not found), update (4,2) in map\n     * At i=3: prefixXOR=4⊕6=2, need prefixXOR⊕k=2⊕6=4 (found with freq 2), count=3, add (2,1) to map\n     * At i=4: prefixXOR=2⊕4=6, need prefixXOR⊕k=6⊕6=0 (found with freq 1), count=4, update (6,2) in map\n     * Final count: 4\n7. Time Complexity: O(n) where n is the number of elements in the array.\n8. Space Complexity: O(n) for the HashMap storing prefix XORs.",
    "code": "public int subarraysWithXorK(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> xorMap = new HashMap<>();\n    int currentXor = 0, subarrayCount = 0;\n    xorMap.put(0, 1);\n    for (int i = 0; i < n; i++) {\n        currentXor ^= nums[i];\n        int xorToRemove = currentXor ^ k;\n        subarrayCount += xorMap.getOrDefault(xorToRemove, 0);\n        xorMap.put(currentXor, xorMap.getOrDefault(currentXor, 0) + 1);\n    }\n    return subarrayCount;\n}"
  }
]