[
  {
    "name": "Bubble Sort",
    "endpoint": "/api/sorting/bubble-sort",
    "methodName": "bubbleSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [5, 1, 4, 2, 8] },
    "description": "Implement the Bubble Sort algorithm to sort an array in ascending order. Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order, causing larger elements to \"bubble\" to the end of the array. For example, given the array [5, 1, 4, 2, 8], the first pass would compare and potentially swap each adjacent pair: [1, 5, 4, 2, 8] → [1, 4, 5, 2, 8] → [1, 4, 2, 5, 8] → [1, 4, 2, 5, 8], placing 8 in its final position. Each subsequent pass places one more element in its final sorted position. The optimization of using a flag to detect if any swaps occurred in a pass allows early termination if the array becomes sorted before completing all passes.",
    "approach": "1. Bubble Sort is a simple comparison-based sorting algorithm.\n2. The algorithm works by comparing adjacent elements and swapping them if they are in the wrong order, causing larger elements to \"bubble up\" to the end of the array in each pass.\n3. Steps of the algorithm:\n   a. Start from the end of the array and work backwards through iterations.\n   b. For each iteration i, compare adjacent elements from index 0 to i-1.\n   c. If the current element is greater than the next element, swap them.\n   d. After each complete iteration, the largest unsorted element is guaranteed to be in its final position.\n   e. Use an optimization flag (isSwapped) to check if any swaps occurred in a pass. If no swaps occurred, the array is already sorted and we can break early.\n4. Time Complexity:\n   - Best Case: O(n) when the array is already sorted (detected by the isSwapped flag).\n   - Average and Worst Case: O(n²) when the array is in reverse order.\n5. Space Complexity: O(1) as it only requires a constant amount of extra space.\n6. Bubble sort is stable (maintains the relative order of equal elements) and in-place (requires no extra array).\n7. It's simple but inefficient for large datasets compared to more advanced sorting algorithms.",
    "code": "public int[] bubbleSort(int[] nums) {\n    int n = nums.length;\n    for (int i = n - 1; i >= 0; i--) {\n        boolean isSwapped = false;\n        for (int j = 0; j <= i - 1; j++) {\n            if (nums[j] > nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n                isSwapped = true;\n            }\n        }\n        if (!isSwapped) {\n            break;\n        }\n    }\n    return nums;\n}"
  },
  {
    "name": "Insertion Sort",
    "endpoint": "/api/sorting/insertion-sort",
    "methodName": "insertionSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [12, 11, 13, 5, 6] },
    "description": "Implement the Insertion Sort algorithm to sort an array in ascending order. Insertion Sort builds the final sorted array one element at a time, similar to how we sort playing cards in our hands. For example, given the array [12, 11, 13, 5, 6], we start with the first element [12] considered sorted. For the second element 11, we compare it with 12 and shift 12 to the right, placing 11 at the beginning: [11, 12, 13, 5, 6]. Next, 13 is already in the correct position. Then for 5, we shift 13, 12, and 11 to the right and place 5 at the beginning: [5, 11, 12, 13, 6]. Finally, 6 is inserted after 5: [5, 6, 11, 12, 13]. This algorithm is efficient for small datasets and nearly sorted arrays.",
    "approach": "1. Insertion Sort builds the final sorted array one element at a time.\n2. It's similar to how we sort playing cards in our hands - we pick one card and insert it into its correct position among the already sorted cards.\n3. Steps of the algorithm:\n   a. Assume the first element is already sorted (a single-element array is always sorted).\n   b. For each unsorted element starting from the second element (index 1):\n      - Store the current element in a temporary variable (key).\n      - Shift all elements in the sorted portion that are greater than the key to the right.\n      - Insert the key into its correct position in the sorted portion.\n   c. Repeat until all elements are processed.\n4. Time Complexity:\n   - Best Case: O(n) when the array is already sorted (each element requires only one comparison).\n   - Average and Worst Case: O(n²) when the array is in reverse order (each element must be compared with each sorted element).\n5. Space Complexity: O(1) as it only requires a constant amount of extra space.\n6. Insertion sort is stable (maintains the relative order of equal elements) and in-place (requires no extra array).\n7. It performs well for small arrays or nearly sorted arrays, and is more efficient than bubble sort in practice.",
    "code": "public int[] insertionSort(int[] nums) {\n    int n = nums.length;\n    for (int i = 1; i < n; i++) {\n        int key = nums[i];\n        int j = i - 1;\n        while (j >= 0 && nums[j] > key) {\n            nums[j + 1] = nums[j];\n            j = j - 1;\n        }\n        nums[j + 1] = key;\n    }\n    return nums;\n}"
  },
  {
    "name": "Merge Sort",
    "endpoint": "/api/sorting/merge-sort",
    "methodName": "mergeSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [38, 27, 43, 3, 9, 82, 10] },
    "description": "Implement the Merge Sort algorithm to sort an array in ascending order. Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves. For example, given [38, 27, 43, 3, 9, 82, 10], the array is first split into [38, 27, 43, 3] and [9, 82, 10]. These are further split and recursively sorted. During the merge phase, the sorted subarrays [3, 27, 38, 43] and [9, 10, 82] are combined by comparing elements from each subarray and selecting the smaller one, resulting in the final sorted array [3, 9, 10, 27, 38, 43, 82]. This algorithm guarantees O(n log n) time complexity in all cases, making it efficient for large datasets.",
    "approach": "1. Merge Sort is an efficient, divide-and-conquer sorting algorithm based on the principle of merging two sorted arrays.\n2. The algorithm divides the input array into two halves, recursively sorts them, and then merges the sorted halves.\n3. Steps of the algorithm:\n   a. Divide: If the array has more than one element, divide it into two halves.\n   b. Conquer: Recursively sort the two halves.\n   c. Merge: Merge the two sorted halves to produce a single sorted array.\n4. The merge operation:\n   - Create a temporary array to store the merged result.\n   - Use two pointers to track positions in the two halves.\n   - Compare elements from both halves and add the smaller element to the temporary array.\n   - After one half is exhausted, add all remaining elements from the other half.\n   - Copy the temporary array back to the original array.\n5. Time Complexity: O(n log n) for all cases (best, average, and worst).\n   - The division step takes O(log n) levels of recursion.\n   - Each level processes all n elements during merging.\n6. Space Complexity: O(n) for the temporary arrays used during merging.\n7. Merge sort is stable (maintains the relative order of equal elements).\n8. It's not in-place (requires additional space proportional to the array size).\n9. Merge sort is particularly efficient for large datasets and is often used as a component in other algorithms.",
    "code": "public int[] mergeSort(int[] arr) {\n    mergeSort(arr, 0, arr.length - 1);\n    return arr;\n}\n\nprivate void merge(int[] arr, int low, int mid, int high) {\n    List<Integer> temp = new ArrayList<>();\n    int left = low;\n    int right = mid + 1;\n    while (left <= mid && right <= high) {\n        if (arr[left] <= arr[right]) {\n            temp.add(arr[left]);\n            left++;\n        } else {\n            temp.add(arr[right]);\n            right++;\n        }\n    }\n    while (left <= mid) {\n        temp.add(arr[left]);\n        left++;\n    }\n    while (right <= high) {\n        temp.add(arr[right]);\n        right++;\n    }\n    for (int i = low; i <= high; i++) {\n        arr[i] = temp.get(i - low);\n    }\n}\n\nprivate void mergeSort(int[] arr, int low, int high) {\n    if (low >= high)\n        return;\n    int mid = (low + high) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    merge(arr, low, mid, high);\n}"
  },
  {
    "name": "Quick Sort",
    "endpoint": "/api/sorting/quick-sort",
    "methodName": "quickSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [10, 7, 8, 9, 1, 5] },
    "description": "Implement the Quick Sort algorithm to sort an array in ascending order. Quick Sort selects a 'pivot' element and partitions the array such that elements smaller than the pivot come before it, and elements greater come after it. For example, given [10, 7, 8, 9, 1, 5] with pivot 10, after the first partition we might have [7, 1, 8, 5, 9, 10]. The pivot 10 is now in its final sorted position. The algorithm then recursively applies the same process to the subarrays [7, 1, 8, 5, 9] and [] (empty in this case). This divide-and-conquer approach continues until all elements are in their correct sorted positions. Quick Sort has an average time complexity of O(n log n) and is often faster in practice than other sorting algorithms due to its cache-friendly behavior.",
    "approach": "1. Quick Sort is an efficient, divide-and-conquer sorting algorithm that uses a pivot element to partition the array.\n2. Steps of the algorithm:\n   a. Choose a pivot element from the array (in this implementation, the first element is chosen as the pivot).\n   b. Partition: Rearrange the array so that all elements less than or equal to the pivot come before it, and all elements greater than the pivot come after it. The pivot is now in its final sorted position.\n   c. Recursively apply the above steps to the sub-arrays formed on either side of the pivot.\n3. The partition process:\n   - Use two pointers i and j starting from low+1 and high respectively.\n   - Move i to the right until finding an element greater than pivot.\n   - Move j to the left until finding an element less than or equal to pivot.\n   - If i < j, swap the elements at i and j.\n   - Repeat until i crosses j.\n   - Finally, swap the pivot with the element at position j to place the pivot in its correct sorted position.\n4. Time Complexity:\n   - Best and Average Case: O(n log n)\n   - Worst Case: O(n²) when the array is already sorted and the first element is always chosen as pivot\n5. Space Complexity: O(log n) for the recursion stack in the average case, O(n) in the worst case.\n6. Quick sort is not stable (may change the relative order of equal elements) but is in-place (requires only O(log n) extra space for recursion).\n7. It's generally faster than other O(n log n) sorting algorithms in practice due to its cache-friendly behavior and lower constant factors.",
    "code": "public int[] quickSort(int[] arr) {\n    quickSort(arr, 0, arr.length - 1);\n    return arr;\n}\n\nprivate int partition(int[] arr, int low, int high) {\n    int pivot = arr[low];\n    int i = low;\n    int j = high;\n    while (i < j) {\n        while (i <= high - 1 && arr[i] <= pivot) {\n            i++;\n        }\n        while (j >= low + 1 && arr[j] > pivot) {\n            j--;\n        }\n        if (i < j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[low];\n    arr[low] = arr[j];\n    arr[j] = temp;\n    return j;\n}\n\nprivate void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pIndex = partition(arr, low, high);\n        quickSort(arr, low, pIndex - 1);\n        quickSort(arr, pIndex + 1, high);\n    }\n}"
  }
]