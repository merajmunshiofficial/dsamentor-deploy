[
  {
    "name": "Convert Min-Heap to Max-Heap",
    "endpoint": "/api/heaps/heap-converter",
    "methodName": "minToMaxHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] },
    "description": "Convert a given min-heap array to a max-heap array.",
    "approach": "1. Converting a min-heap to a max-heap involves restructuring the heap to satisfy the max-heap property (every parent is greater than or equal to its children).\n2. Since the input is already a min-heap, we can leverage the fact that all leaf nodes (approximately half of the nodes) already satisfy the max-heap property (as they have no children).\n3. Steps of the algorithm:\n   a. Start from the last non-leaf node (parent of the last element) and move upward to the root.\n   b. For each node encountered, perform the 'heapify down' operation for a max-heap:\n      - Compare the current node with its children.\n      - If a child is larger, swap the current node with the largest child.\n      - Recursively heapify down from the swapped position to maintain the max-heap property.\n   c. This process is applied to all non-leaf nodes, from bottom to top.\n4. The key insight is that by starting from the last non-leaf node, we ensure that all subtrees below each node we process already satisfy the max-heap property.\n5. Time Complexity: O(n) where n is the number of elements in the heap.\n   - Though heapify down takes O(log n) in the worst case, when performed on all n/2 non-leaf nodes, the overall complexity is O(n).\n6. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] minToMaxHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMax(nums, i);\n    }\n    return nums;\n}\n\nprivate void heapifyDownMax(int[] arr, int ind) {\n    int n = arr.length;\n    int largestInd = ind;\n    int left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] > arr[largestInd]) largestInd = left;\n    if (right < n && arr[right] > arr[largestInd]) largestInd = right;\n    if (largestInd != ind) {\n        int temp = arr[largestInd]; arr[largestInd] = arr[ind]; arr[ind] = temp;\n        heapifyDownMax(arr, largestInd);\n    }\n}"
  },
  {
    "name": "Heap Sort",
    "endpoint": "/api/heaps/heap-sorter",
    "methodName": "heapSort",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [4, 10, 3, 5, 1] },
    "description": "Sort an array using heap sort algorithm.",
    "approach": "1. Heap Sort is a comparison-based sorting algorithm that uses the binary heap data structure.\n2. Steps of the algorithm:\n   a. Build Phase: Transform the input array into a max-heap (every parent is greater than or equal to its children).\n      - This is done by applying the heapify down operation on all non-leaf nodes from bottom to top.\n   b. Sort Phase: Extract elements from the heap one by one to build the sorted array:\n      - Swap the root (maximum element) with the last element of the heap.\n      - Reduce the heap size by one.\n      - Apply heapify down to the root to restore the max-heap property for the reduced heap.\n      - Repeat until the heap is empty.\n3. The result is an array sorted in ascending order (smallest to largest).\n4. The key insight is that after building the max-heap, the maximum element is always at the root. Each extraction places this maximum at the end of the array, gradually building the sorted result.\n5. The heapify operation is customized to respect the current heap boundary during the sort phase.\n6. Time Complexity:\n   - Build Phase: O(n) where n is the number of elements.\n   - Sort Phase: O(n log n) for n extractions with log n work each.\n   - Overall: O(n log n) for all cases (best, average, worst).\n7. Space Complexity: O(1) for in-place sorting (plus O(log n) for the recursion stack).\n8. Heap Sort is not stable (equal elements may be reordered) but is in-place (no extra array needed).",
    "code": "public int[] heapSort(int[] nums) {\n    buildMaxHeap(nums);\n    int last = nums.length - 1;\n    while (last > 0) {\n        int temp = nums[0]; nums[0] = nums[last]; nums[last] = temp;\n        last--;\n        heapifyDownMax(nums, 0, last);\n    }\n    return nums;\n}\n\npublic void buildMaxHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMax(nums, i, n - 1);\n    }\n}\n\nprivate void heapifyDownMax(int[] arr, int ind, int last) {\n    int largestInd = ind;\n    int left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left <= last && arr[left] > arr[largestInd]) largestInd = left;\n    if (right <= last && arr[right] > arr[largestInd]) largestInd = right;\n    if (largestInd != ind) {\n        int temp = arr[largestInd]; arr[largestInd] = arr[ind]; arr[ind] = temp;\n        heapifyDownMax(arr, largestInd, last);\n    }\n}"
  },
  {
    "name": "Kth Largest Element in Array",
    "endpoint": "/api/heaps/kth-largest-element",
    "methodName": "kthLargestElement",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [3,2,1,5,6,4], "k": 2 },
    "description": "Find the kth largest element in an array.",
    "approach": "1. This problem uses a min-heap of size k to efficiently find the kth largest element in an array.\n2. Steps of the algorithm:\n   a. Initialize a min-heap (priority queue) and add the first k elements from the array.\n      - In a min-heap, the smallest element is always at the top.\n   b. For each remaining element in the array (from index k onwards):\n      - If the current element is greater than the smallest element in the heap (the top element), remove the top element and add the current element.\n      - Otherwise, ignore the current element as it cannot be among the k largest.\n   c. After processing all elements, the top of the min-heap will be the kth largest element.\n3. The key insight is that by maintaining a min-heap of exactly k elements that are currently the largest elements seen so far, the smallest of these k elements (at the top of the min-heap) is the kth largest element overall.\n4. This approach efficiently handles both sorted and unsorted arrays without requiring a full sort.\n5. Time Complexity: O(n log k) where n is the number of elements in the array.\n   - Adding or removing an element from the heap takes O(log k) time.\n   - We perform at most n such operations (one for each element in the array).\n6. Space Complexity: O(k) for storing the k largest elements in the heap.",
    "code": "public int kthLargestElement(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    for (int i = 0; i < k; i++) pq.add(nums[i]);\n    for (int i = k; i < nums.length; i++) {\n        if (nums[i] > pq.peek()) {\n            pq.poll(); pq.add(nums[i]);\n        }\n    }\n    return pq.peek();\n}"
  },
  {
    "name": "Validate Min-Heap",
    "endpoint": "/api/heaps/min-heap-validator",
    "methodName": "isMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] },
    "description": "Check if the given array represents a valid min-heap.",
    "approach": "1. This problem involves validating whether an array represents a valid min-heap.\n2. In a min-heap, every parent node must have a value less than or equal to its children.\n3. Steps of the algorithm:\n   a. Iterate through all non-leaf nodes in the array (from index 0 to n/2-1, where n is the array length).\n   b. For each node at index i:\n      - Calculate the indices of its left child (2*i+1) and right child (2*i+2).\n      - Check if the left child exists and is less than the parent; if so, return false.\n      - Check if the right child exists and is less than the parent; if so, return false.\n   c. If all parent-child relationships satisfy the min-heap property, return true.\n4. The validation algorithm only needs to check non-leaf nodes since leaf nodes don't have children to compare with.\n5. We can iterate from the bottom of the tree to the top (last non-leaf node to the root) or from the top to the bottom; the result will be the same.\n6. Time Complexity: O(n) where n is the number of elements in the array.\n   - We check at most n/2 nodes (all non-leaf nodes).\n7. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public boolean isMinHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int left = 2 * i + 1, right = 2 * i + 2;\n        if (left < n && nums[left] < nums[i]) return false;\n        if (right < n && nums[right] < nums[i]) return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Build Min-Heap from Array",
    "endpoint": "/api/heaps/build-min-heap",
    "methodName": "buildMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [9, 4, 7, 1, -2, 6, 5] },
    "description": "Build a min-heap from an unsorted array.",
    "approach": "1. This problem involves converting an unsorted array into a min-heap, where every parent node is less than or equal to its children.\n2. The most efficient approach is to use the 'bottom-up heapify' method, which starts from the last non-leaf node and moves up to the root.\n3. Steps of the algorithm:\n   a. Identify the last non-leaf node (parent of the last element), which is at index (n/2-1) where n is the array length.\n   b. For each non-leaf node from this point up to the root (index 0), perform a 'heapify down' operation:\n      - Compare the current node with its children.\n      - If a child is smaller, swap the current node with the smallest child.\n      - Recursively heapify down from the swapped position to maintain the min-heap property.\n   c. After processing all non-leaf nodes, the array will represent a valid min-heap.\n4. The key insight is that leaf nodes (approximately half of the array) are already valid 1-element heaps, so we only need to process the non-leaf nodes.\n5. This bottom-up approach is more efficient than inserting elements one by one into an initially empty heap.\n6. Time Complexity: O(n) where n is the number of elements in the array.\n   - Though each heapify down operation takes O(log n) in the worst case, when applied to all non-leaf nodes in a specific order, the overall complexity is O(n).\n7. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] buildMinHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMin(nums, i);\n    }\n    return nums;\n}\n\nprivate void heapifyDownMin(int[] arr, int ind) {\n    int n = arr.length;\n    int smallest = ind, left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] < arr[smallest]) smallest = left;\n    if (right < n && arr[right] < arr[smallest]) smallest = right;\n    if (smallest != ind) {\n        int temp = arr[smallest]; arr[smallest] = arr[ind]; arr[ind] = temp;\n        heapifyDownMin(arr, smallest);\n    }\n}"
  },
  {
    "name": "Adjust Min-Heap Value at Index",
    "endpoint": "/api/heaps/adjust-min-heap",
    "methodName": "adjustMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0], "index": 3, "val": 0 },
    "description": "Change the value at a given index in a min-heap and restore the heap property.",
    "approach": "1. This problem involves changing a value at a specific index in a min-heap and then restoring the min-heap property.\n2. The approach depends on how the new value compares to the original value:\n   a. If the new value is less than the original value:\n      - Update the value at the given index.\n      - Perform 'heapify up' to move the smaller value upward as needed:\n        * Compare the node with its parent.\n        * If the node is smaller than its parent, swap them.\n        * Continue this process upward until the heap property is restored.\n   b. If the new value is greater than the original value:\n      - Update the value at the given index.\n      - Perform 'heapify down' to move the larger value downward as needed:\n        * Compare the node with its children.\n        * If a child is smaller, swap with the smallest child.\n        * Continue this process downward until the heap property is restored.\n3. The algorithm efficiently handles both cases without rebuilding the entire heap.\n4. Time Complexity:\n   - Heapify Up: O(log n) in the worst case (node moves all the way to the root).\n   - Heapify Down: O(log n) in the worst case (node moves all the way to a leaf).\n   - Overall: O(log n) where n is the number of elements in the heap.\n5. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] adjustMinHeap(int[] nums, int ind, int val) {\n    if (nums[ind] > val) {\n        nums[ind] = val;\n        heapifyUpMin(nums, ind);\n    } else {\n        nums[ind] = val;\n        heapifyDownMin(nums, ind);\n    }\n    return nums;\n}\n\nprivate void heapifyUpMin(int[] arr, int ind) {\n    int parent = (ind - 1) / 2;\n    if (ind > 0 && arr[ind] < arr[parent]) {\n        int temp = arr[ind]; arr[ind] = arr[parent]; arr[parent] = temp;\n        heapifyUpMin(arr, parent);\n    }\n}\n\nprivate void heapifyDownMin(int[] arr, int ind) {\n    int n = arr.length;\n    int smallest = ind, left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] < arr[smallest]) smallest = left;\n    if (right < n && arr[right] < arr[smallest]) smallest = right;\n    if (smallest != ind) {\n        int temp = arr[smallest]; arr[smallest] = arr[ind]; arr[ind] = temp;\n        heapifyDownMin(arr, smallest);\n    }\n}"
  }
]