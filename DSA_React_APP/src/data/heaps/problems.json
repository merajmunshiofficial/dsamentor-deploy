[
  {
    "name": "Convert Min-Heap to Max-Heap",
    "endpoint": "/api/heaps/heap-converter",
    "methodName": "minToMaxHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] },
    "description": "Given an array representing a min-heap (where each parent node is less than or equal to its children), convert it to a max-heap (where each parent node is greater than or equal to its children). For example, given the min-heap array [1, 3, 5, 7, 9, 2, 4, 6, 8, 0], which can be visualized as a tree where 1 is the root with children 3 and 5, and so on, the output would be a max-heap like [9, 8, 5, 7, 0, 2, 4, 6, 3, 1]. In the output, 9 would be the root, with 8 and 5 as its children, maintaining the max-heap property where each parent is greater than its children.",
    "approach": "1. Converting a min-heap to a max-heap involves restructuring the heap to satisfy the max-heap property (every parent is greater than or equal to its children).\n2. Since the input is already a min-heap, we can leverage the fact that all leaf nodes (approximately half of the nodes) already satisfy the max-heap property (as they have no children).\n3. Steps of the algorithm:\n   a. Start from the last non-leaf node (parent of the last element) and move upward to the root.\n   b. For each node encountered, perform the 'heapify down' operation for a max-heap:\n      - Compare the current node with its children.\n      - If a child is larger, swap the current node with the largest child.\n      - Recursively heapify down from the swapped position to maintain the max-heap property.\n   c. This process is applied to all non-leaf nodes, from bottom to top.\n4. The key insight is that by starting from the last non-leaf node, we ensure that all subtrees below each node we process already satisfy the max-heap property.\n5. Time Complexity: O(n) where n is the number of elements in the heap.\n   - Though heapify down takes O(log n) in the worst case, when performed on all n/2 non-leaf nodes, the overall complexity is O(n).\n6. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] minToMaxHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMax(nums, i);\n    }\n    return nums;\n}\n\nprivate void heapifyDownMax(int[] arr, int ind) {\n    int n = arr.length;\n    int largestInd = ind;\n    int left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] > arr[largestInd]) largestInd = left;\n    if (right < n && arr[right] > arr[largestInd]) largestInd = right;\n    if (largestInd != ind) {\n        int temp = arr[largestInd]; arr[largestInd] = arr[ind]; arr[ind] = temp;\n        heapifyDownMax(arr, largestInd);\n    }\n}"
  },
  {
    "name": "Heap Sort",
    "endpoint": "/api/heaps/heap-sorter",
    "methodName": "heapSort",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [4, 10, 3, 5, 1] },
    "description": "Given an unsorted array, implement the heap sort algorithm to sort it in ascending order. Heap sort uses a binary heap data structure to achieve efficient sorting. For example, given the array [4, 10, 3, 5, 1], the sorting process would first build a max-heap [10, 5, 3, 4, 1], then repeatedly extract the maximum element and place it at the end of the array while maintaining the heap property for the remaining elements. After each extraction and heapification, the array would progress through states like [1, 5, 3, 4, 10], [1, 4, 3, 5, 10], [1, 3, 4, 5, 10], and finally [1, 3, 4, 5, 10], resulting in the sorted output.",
    "approach": "1. Heap Sort is a comparison-based sorting algorithm that uses the binary heap data structure.\n2. Steps of the algorithm:\n   a. Build Phase: Transform the input array into a max-heap (every parent is greater than or equal to its children).\n      - This is done by applying the heapify down operation on all non-leaf nodes from bottom to top.\n   b. Sort Phase: Extract elements from the heap one by one to build the sorted array:\n      - Swap the root (maximum element) with the last element of the heap.\n      - Reduce the heap size by one.\n      - Apply heapify down to the root to restore the max-heap property for the reduced heap.\n      - Repeat until the heap is empty.\n3. The result is an array sorted in ascending order (smallest to largest).\n4. The key insight is that after building the max-heap, the maximum element is always at the root. Each extraction places this maximum at the end of the array, gradually building the sorted result.\n5. The heapify operation is customized to respect the current heap boundary during the sort phase.\n6. Time Complexity:\n   - Build Phase: O(n) where n is the number of elements.\n   - Sort Phase: O(n log n) for n extractions with log n work each.\n   - Overall: O(n log n) for all cases (best, average, worst).\n7. Space Complexity: O(1) for in-place sorting (plus O(log n) for the recursion stack).\n8. Heap Sort is not stable (equal elements may be reordered) but is in-place (no extra array needed).",
    "code": "public int[] heapSort(int[] nums) {\n    buildMaxHeap(nums);\n    int last = nums.length - 1;\n    while (last > 0) {\n        int temp = nums[0]; nums[0] = nums[last]; nums[last] = temp;\n        last--;\n        heapifyDownMax(nums, 0, last);\n    }\n    return nums;\n}\n\npublic void buildMaxHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMax(nums, i, n - 1);\n    }\n}\n\nprivate void heapifyDownMax(int[] arr, int ind, int last) {\n    int largestInd = ind;\n    int left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left <= last && arr[left] > arr[largestInd]) largestInd = left;\n    if (right <= last && arr[right] > arr[largestInd]) largestInd = right;\n    if (largestInd != ind) {\n        int temp = arr[largestInd]; arr[largestInd] = arr[ind]; arr[ind] = temp;\n        heapifyDownMax(arr, largestInd, last);\n    }\n}"
  },
  {
    "name": "Kth Largest Element in Array",
    "endpoint": "/api/heaps/kth-largest-element",
    "methodName": "kthLargestElement",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [3,2,1,5,6,4], "k": 2 },
    "description": "Given an unsorted integer array and a value k, find the kth largest element in the array. For example, in the array [3, 2, 1, 5, 6, 4] and k=2, the 2nd largest element is 5. If we sort the array in descending order, it becomes [6, 5, 4, 3, 2, 1], and the 2nd element is 5. Similarly, for the array [3, 2, 3, 1, 2, 4, 5, 5, 6] and k=4, the 4th largest element would be 4. Note that duplicate elements count individually in determining the kth largest (e.g., in a sorted array [6, 5, 5, 4, ...], the 2nd largest is 5 and the 3rd largest is also 5).",
    "approach": "1. This problem uses a min-heap of size k to efficiently find the kth largest element in an array.\n2. Steps of the algorithm:\n   a. Initialize a min-heap (priority queue) and add the first k elements from the array.\n      - In a min-heap, the smallest element is always at the top.\n   b. For each remaining element in the array (from index k onwards):\n      - If the current element is greater than the smallest element in the heap (the top element), remove the top element and add the current element.\n      - Otherwise, ignore the current element as it cannot be among the k largest.\n   c. After processing all elements, the top of the min-heap will be the kth largest element.\n3. The key insight is that by maintaining a min-heap of exactly k elements that are currently the largest elements seen so far, the smallest of these k elements (at the top of the min-heap) is the kth largest element overall.\n4. This approach efficiently handles both sorted and unsorted arrays without requiring a full sort.\n5. Time Complexity: O(n log k) where n is the number of elements in the array.\n   - Adding or removing an element from the heap takes O(log k) time.\n   - We perform at most n such operations (one for each element in the array).\n6. Space Complexity: O(k) for storing the k largest elements in the heap.",
    "code": "public int kthLargestElement(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>();\n    for (int i = 0; i < k; i++) pq.add(nums[i]);\n    for (int i = k; i < nums.length; i++) {\n        if (nums[i] > pq.peek()) {\n            pq.poll(); pq.add(nums[i]);\n        }\n    }\n    return pq.peek();\n}"
  },
  {
    "name": "Validate Min-Heap",
    "endpoint": "/api/heaps/min-heap-validator",
    "methodName": "isMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] },
    "description": "Given an integer array, determine if it represents a valid min-heap. In a min-heap, every parent node must have a value less than or equal to its children. For a zero-indexed array representation of a binary heap, the children of a node at index i are located at indices 2i+1 and 2i+2 (if they exist). For example, [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] is not a valid min-heap because the node at index 4 (value 9) has a child at index 9 (value 0), violating the min-heap property since 9 > 0. However, [1, 2, 3, 4, 5, 6, 7, 8, 9] would be a valid min-heap since every parent is less than or equal to its children (e.g., 1 at index 0 has children 2 and 3 at indices 1 and 2).",
    "approach": "1. This problem involves validating whether an array represents a valid min-heap.\n2. In a min-heap, every parent node must have a value less than or equal to its children.\n3. Steps of the algorithm:\n   a. Iterate through all non-leaf nodes in the array (from index 0 to n/2-1, where n is the array length).\n   b. For each node at index i:\n      - Calculate the indices of its left child (2*i+1) and right child (2*i+2).\n      - Check if the left child exists and is less than the parent; if so, return false.\n      - Check if the right child exists and is less than the parent; if so, return false.\n   c. If all parent-child relationships satisfy the min-heap property, return true.\n4. The validation algorithm only needs to check non-leaf nodes since leaf nodes don't have children to compare with.\n5. We can iterate from the bottom of the tree to the top (last non-leaf node to the root) or from the top to the bottom; the result will be the same.\n6. Time Complexity: O(n) where n is the number of elements in the array.\n   - We check at most n/2 nodes (all non-leaf nodes).\n7. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public boolean isMinHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        int left = 2 * i + 1, right = 2 * i + 2;\n        if (left < n && nums[left] < nums[i]) return false;\n        if (right < n && nums[right] < nums[i]) return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Build Min-Heap from Array",
    "endpoint": "/api/heaps/build-min-heap",
    "methodName": "buildMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [9, 4, 7, 1, -2, 6, 5] },
    "description": "Given an unsorted array of integers, transform it into a min-heap data structure where each parent node has a value less than or equal to its children. For example, given the unsorted array [9, 4, 7, 1, -2, 6, 5], the output should be a valid min-heap like [-2, 1, 5, 4, 9, 6, 7]. In this min-heap representation, -2 is the root with children 1 and 5. The node 1 has children 4 and 9, while 5 has children 6 and 7. To visualize: -2 is at index 0, its children 1 and 5 are at indices 1 and 2, and their respective children are at indices 3-6, following the heap property that for a node at index i, its children are at indices 2i+1 and 2i+2.",
    "approach": "1. This problem involves converting an unsorted array into a min-heap, where every parent node is less than or equal to its children.\n2. The most efficient approach is to use the 'bottom-up heapify' method, which starts from the last non-leaf node and moves up to the root.\n3. Steps of the algorithm:\n   a. Identify the last non-leaf node (parent of the last element), which is at index (n/2-1) where n is the array length.\n   b. For each non-leaf node from this point up to the root (index 0), perform a 'heapify down' operation:\n      - Compare the current node with its children.\n      - If a child is smaller, swap the current node with the smallest child.\n      - Recursively heapify down from the swapped position to maintain the min-heap property.\n   c. After processing all non-leaf nodes, the array will represent a valid min-heap.\n4. The key insight is that leaf nodes (approximately half of the array) are already valid 1-element heaps, so we only need to process the non-leaf nodes.\n5. This bottom-up approach is more efficient than inserting elements one by one into an initially empty heap.\n6. Time Complexity: O(n) where n is the number of elements in the array.\n   - Though each heapify down operation takes O(log n) in the worst case, when applied to all non-leaf nodes in a specific order, the overall complexity is O(n).\n7. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] buildMinHeap(int[] nums) {\n    int n = nums.length;\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapifyDownMin(nums, i);\n    }\n    return nums;\n}\n\nprivate void heapifyDownMin(int[] arr, int ind) {\n    int n = arr.length;\n    int smallest = ind, left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] < arr[smallest]) smallest = left;\n    if (right < n && arr[right] < arr[smallest]) smallest = right;\n    if (smallest != ind) {\n        int temp = arr[smallest]; arr[smallest] = arr[ind]; arr[ind] = temp;\n        heapifyDownMin(arr, smallest);\n    }\n}"
  },
  {
    "name": "Adjust Min-Heap Value at Index",
    "endpoint": "/api/heaps/adjust-min-heap",
    "methodName": "adjustMinHeap",
    "serviceFile": "HeapsService.java",
    "defaultInput": { "array": [1, 3, 5, 7, 9, 2, 4, 6, 8, 0], "index": 3, "val": 0 },
    "description": "Given a min-heap array, an index, and a new value, update the value at the specified index and reorganize the array to maintain the min-heap property. For example, given the min-heap [1, 3, 5, 7, 9, 2, 4, 6, 8, 0], index 3 (value 7), and new value 0, we need to replace 7 with 0 and then restore the min-heap property. Since 0 is less than its parent 3 at index 1, we need to 'bubble up' the new value by swapping it with its parent. The resulting min-heap would be [0, 1, 5, 3, 9, 2, 4, 6, 8, 7]. Conversely, if we were to change the value at index 0 from 1 to 10, we would need to 'sink down' the new value by swapping it with its smallest child recursively, resulting in a different heap configuration.",
    "approach": "1. This problem involves changing a value at a specific index in a min-heap and then restoring the min-heap property.\n2. The approach depends on how the new value compares to the original value:\n   a. If the new value is less than the original value:\n      - Update the value at the given index.\n      - Perform 'heapify up' to move the smaller value upward as needed:\n        * Compare the node with its parent.\n        * If the node is smaller than its parent, swap them.\n        * Continue this process upward until the heap property is restored.\n   b. If the new value is greater than the original value:\n      - Update the value at the given index.\n      - Perform 'heapify down' to move the larger value downward as needed:\n        * Compare the node with its children.\n        * If a child is smaller, swap with the smallest child.\n        * Continue this process downward until the heap property is restored.\n3. The algorithm efficiently handles both cases without rebuilding the entire heap.\n4. Time Complexity:\n   - Heapify Up: O(log n) in the worst case (node moves all the way to the root).\n   - Heapify Down: O(log n) in the worst case (node moves all the way to a leaf).\n   - Overall: O(log n) where n is the number of elements in the heap.\n5. Space Complexity: O(log n) for the recursion stack in the worst case (tree height).",
    "code": "public int[] adjustMinHeap(int[] nums, int ind, int val) {\n    if (nums[ind] > val) {\n        nums[ind] = val;\n        heapifyUpMin(nums, ind);\n    } else {\n        nums[ind] = val;\n        heapifyDownMin(nums, ind);\n    }\n    return nums;\n}\n\nprivate void heapifyUpMin(int[] arr, int ind) {\n    int parent = (ind - 1) / 2;\n    if (ind > 0 && arr[ind] < arr[parent]) {\n        int temp = arr[ind]; arr[ind] = arr[parent]; arr[parent] = temp;\n        heapifyUpMin(arr, parent);\n    }\n}\n\nprivate void heapifyDownMin(int[] arr, int ind) {\n    int n = arr.length;\n    int smallest = ind, left = 2 * ind + 1, right = 2 * ind + 2;\n    if (left < n && arr[left] < arr[smallest]) smallest = left;\n    if (right < n && arr[right] < arr[smallest]) smallest = right;\n    if (smallest != ind) {\n        int temp = arr[smallest]; arr[smallest] = arr[ind]; arr[ind] = temp;\n        heapifyDownMin(arr, smallest);\n    }\n}"
  }
]