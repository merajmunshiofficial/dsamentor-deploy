[
  {
    "name": "DFS of Graph",
    "endpoint": "/api/graph/dfs-traversal",
    "methodName": "dfsOfGraph",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [[1,2],[0,3,4],[0,4],[1],[1,2]] },
    "description": "Perform Depth First Search (DFS) traversal of a graph.",
    "approach": "1. Depth-First Search (DFS) is a fundamental graph traversal algorithm that explores as far as possible along each branch before backtracking.\n2. The key idea is to start from a source node, visit it, mark it as visited, and then recursively visit all its unvisited adjacent nodes.\n3. The implementation uses:\n   a. A boolean array 'vis' to keep track of visited nodes and prevent cycles.\n   b. A list 'ans' to store the traversal order.\n   c. A recursive helper function that explores each node and its neighbors.\n4. For disconnected graphs, we need to ensure all nodes are visited, which is why we have an outer loop that iterates through all vertices.\n5. Algorithm steps:\n   a. Initialize a boolean visited array of size V (number of vertices) with all values set to false.\n   b. Initialize an empty list to store the traversal result.\n   c. For each vertex i from 0 to V-1:\n      i. If vertex i is not visited, call the DFS function starting from vertex i.\n   d. In the DFS function:\n      i. Mark the current node as visited.\n      ii. Add the current node to the result list.\n      iii. For each adjacent node of the current node:\n           - If the adjacent node is not visited, recursively call DFS for that node.\n6. Example with V = 5, adj = [[1,2],[0,3,4],[0,4],[1],[1,2]]:\n   - Start DFS from node 0: Visit 0, then recursively visit 1, which leads to visiting 3, then 4, then backtrack to 1, then backtrack to 0, then visit 2.\n   - Result: [0, 1, 3, 4, 2]\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n8. Space Complexity: O(V) for the visited array and the recursion stack.",
    "code": "public List<Integer> dfsOfGraph(int V, List<List<Integer>> adj) {\n    boolean[] vis = new boolean[V];\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            dfs(i, adj, vis, ans);\n        }\n    }\n    return ans;\n}\n\nprivate void dfs(int node, List<List<Integer>> adj, boolean[] vis, List<Integer> ans) {\n    vis[node] = true;\n    ans.add(node);\n    \n    for (int it : adj.get(node)) {\n        if (!vis[it]) {\n            dfs(it, adj, vis, ans);\n        }\n    }\n}"
  },
  {
    "name": "BFS of Graph",
    "endpoint": "/api/graph/bfs-traversal",
    "methodName": "bfsOfGraph",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [[1,2],[0,3,4],[0,4],[1],[1,2]] },
    "description": "Perform Breadth First Search (BFS) traversal of a graph.",
    "approach": "1. Breadth-First Search (BFS) is a graph traversal algorithm that explores all vertices at the current depth level before moving on to vertices at the next depth level.\n2. Unlike DFS which uses recursion to explore deeply, BFS uses a queue data structure to explore nodes level by level.\n3. The implementation uses:\n   a. A boolean array 'vis' to track visited nodes and prevent revisiting.\n   b. A queue to maintain the order of exploration (FIFO).\n   c. A list 'ans' to store the traversal order.\n4. For disconnected graphs, we need an outer loop to ensure all components are explored.\n5. Algorithm steps:\n   a. Initialize a boolean visited array of size V (number of vertices) with all values set to false.\n   b. Initialize an empty list to store the traversal result.\n   c. For each vertex i from 0 to V-1:\n      i. If vertex i is not visited, mark it as visited and call the BFS function starting from vertex i.\n   d. In the BFS function:\n      i. Create a queue and add the starting node to it.\n      ii. While the queue is not empty:\n          - Dequeue a node (call it 'current').\n          - Add 'current' to the result list.\n          - For each adjacent node of 'current':\n            * If the adjacent node is not visited, mark it as visited and enqueue it.\n6. Example with V = 5, adj = [[1,2],[0,3,4],[0,4],[1],[1,2]]:\n   - Start BFS from node 0: Visit 0, enqueue 1 and 2, dequeue 1 and visit, enqueue 3 and 4, and so on.\n   - Result: [0, 1, 2, 3, 4]\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n8. Space Complexity: O(V) for the visited array and the queue.",
    "code": "public List<Integer> bfsOfGraph(int V, List<List<Integer>> adj) {\n    boolean[] vis = new boolean[V];\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            vis[i] = true;\n            bfs(i, adj, vis, ans);\n        }\n    }\n    return ans;\n}\n\nprivate void bfs(int node, List<List<Integer>> adj, boolean[] vis, List<Integer> ans) {\n    Queue<Integer> q = new LinkedList<>();\n    q.add(node);\n    \n    while (!q.isEmpty()) {\n        int current = q.poll();\n        ans.add(current);\n        \n        for (int it : adj.get(current)) {\n            if (!vis[it]) {\n                vis[it] = true;\n                q.add(it);\n            }\n        }\n    }\n}"
  },
  {
    "name": "Detect Cycle in Directed Graph (DFS)",
    "endpoint": "/api/graph/is-cyclic-dfs",
    "methodName": "isCyclicDFS",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 4, "adj": [[1],[2],[3],[1]] },
    "description": "Detect if a directed graph contains a cycle using DFS.",
    "approach": "1. Detecting cycles in a directed graph requires tracking both visited nodes and nodes in the current DFS recursion stack.\n2. The implementation uses two boolean arrays:\n   a. 'vis' to mark nodes that have been visited in any path.\n   b. 'dfsVis' to mark nodes that are part of the current DFS traversal path.\n3. A cycle is detected when we encounter a node that is already in the current DFS path (marked in dfsVis).\n4. Algorithm steps:\n   a. Maintain two arrays: visited[] and dfsVisited[] (both initialized to false).\n   b. For each unvisited vertex, call the DFS helper function.\n   c. In the DFS helper function:\n      i. Mark the current node as visited in both arrays.\n      ii. Explore all adjacent nodes of the current node.\n         - If an adjacent node is not visited, recursively call DFS on it.\n         - If an adjacent node is already in the current DFS path (dfsVisited[it] is true), a cycle is detected.\n      iii. When returning from a node, unmark it in the dfsVisited array (backtracking).\n5. Example with V = 4, adj = [[1],[2],[3],[1]]:\n   - Start DFS from node 0: Mark vis[0]=true, dfsVis[0]=true.\n   - Visit node 1: Mark vis[1]=true, dfsVis[1]=true.\n   - Visit node 2: Mark vis[2]=true, dfsVis[2]=true.\n   - Visit node 3: Mark vis[3]=true, dfsVis[3]=true.\n   - Visit node 1: Already in dfsVis, cycle detected!\n6. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n7. Space Complexity: O(V) for the visited arrays and the recursion stack.",
    "code": "public boolean isCyclicDFS(int V, List<Integer>[] adj) {\n    boolean[] vis = new boolean[V];\n    boolean[] dfsVis = new boolean[V];\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            if (isCyclicDFSHelper(i, adj, vis, dfsVis)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean isCyclicDFSHelper(int node, List<Integer>[] adj, boolean[] vis, boolean[] dfsVis) {\n    vis[node] = true;\n    dfsVis[node] = true;\n    \n    for (int it : adj[node]) {\n        if (!vis[it]) {\n            if (isCyclicDFSHelper(it, adj, vis, dfsVis)) {\n                return true;\n            }\n        } else if (dfsVis[it]) {\n            return true;\n        }\n    }\n    dfsVis[node] = false;\n    return false;\n}"
  },
  {
    "name": "Detect Cycle in Directed Graph (BFS/Kahn's Algorithm)",
    "endpoint": "/api/graph/is-cyclic-bfs",
    "methodName": "isCyclicBFS",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 4, "adj": [[1],[2],[3],[1]] },
    "description": "Detect if a directed graph contains a cycle using BFS (Kahn's Algorithm).",
    "approach": "1. This approach uses Kahn's algorithm, which is used for topological sorting of a directed acyclic graph (DAG).\n2. The key insight is that if a directed graph has a cycle, we cannot produce a valid topological ordering of all vertices.\n3. The algorithm works as follows:\n   a. Calculate in-degree (number of incoming edges) for each vertex.\n   b. Enqueue all vertices with in-degree 0 (these are the starting points with no dependencies).\n   c. While the queue is not empty:\n      i. Dequeue a vertex and add it to the result.\n      ii. For each adjacent vertex, reduce its in-degree by 1.\n      iii. If any adjacent vertex's in-degree becomes 0, enqueue it.\n   d. If we can't visit all vertices (count != V), there must be a cycle in the graph.\n4. The cycle detection logic uses the fact that in a DAG, Kahn's algorithm will eventually visit all vertices.\n5. If there's a cycle, some vertices will never have their in-degree reduced to 0, and thus will never be processed.\n6. Example with V = 4, adj = [[1],[2],[3],[1]]:\n   - Calculate in-degrees: [0,2,1,1]\n   - Start with node 0 (in-degree 0)\n   - Process node 0, reduce in-degree of node 1 to 1\n   - No more nodes with in-degree 0, algorithm terminates\n   - Only 1 node visited out of 4, so there's a cycle\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n8. Space Complexity: O(V) for the queue and in-degree array.",
    "code": "public boolean isCyclicBFS(int V, List<Integer>[] adj) {\n    int[] inDegree = new int[V];\n    for (int i = 0; i < V; i++) {\n        for (int it : adj[i]) {\n            inDegree[it]++;\n        }\n    }\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < V; i++) {\n        if (inDegree[i] == 0) {\n            q.add(i);\n        }\n    }\n    int count = 0;\n    while (!q.isEmpty()) {\n        int node = q.poll();\n        count++;\n        for (int it : adj[node]) {\n            inDegree[it]--;\n            if (inDegree[it] == 0) {\n                q.add(it);\n            }\n        }\n    }\n    return count != V;\n}"
  },
  {
    "name": "Check if Graph is Bipartite (DFS)",
    "endpoint": "/api/graph/is-bipartite-dfs",
    "methodName": "isBipartiteDFS",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 4, "adj": [[1,3],[0,2],[1,3],[0,2]] },
    "description": "Check if a graph is bipartite using DFS.",
    "approach": "1. A graph is bipartite if its vertices can be divided into two distinct sets such that no two adjacent vertices belong to the same set (or equivalently, the graph can be colored using only two colors where no adjacent nodes have the same color).\n2. The solution uses Depth-First Search (DFS) with a coloring approach to determine if a graph is bipartite.\n3. Implementation details:\n   a. Use an array 'color[]' to store colors (0 or 1) for each vertex. -1 represents an uncolored vertex.\n   b. For each uncolored vertex, try to color it and recursively color all adjacent vertices with the opposite color.\n   c. If at any point an adjacent vertex already has the same color as the current vertex, the graph cannot be bipartite.\n4. Algorithm steps:\n   a. Initialize color[] with -1 for all vertices (indicating no color assigned).\n   b. For each uncolored vertex, assign it color 0 and start DFS.\n   c. In the DFS function:\n      i. For each adjacent vertex:\n         - If it's not colored, assign the opposite color (1-col) and recursively call DFS.\n         - If it's already colored with the same color as the current vertex, return false (not bipartite).\n   d. If no conflicts are found after processing all vertices, return true.\n5. Example with V = 4, adj = [[1,3],[0,2],[1,3],[0,2]]:\n   - Start with node 0, color it 0.\n   - Assign color 1 to its neighbors (1 and 3).\n   - Continue with node 1, which leads to coloring node 2 with color 0.\n   - The pattern continues without conflicts, so the graph is bipartite.\n6. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n7. Space Complexity: O(V) for the color array and recursion stack.",
    "code": "public boolean isBipartiteDFS(int V, List<Integer>[] adj) {\n    int[] color = new int[V];\n    Arrays.fill(color, -1);\n    for (int i = 0; i < V; i++) {\n        if (color[i] == -1) {\n            if (!isBipartiteDFSHelper(i, 0, adj, color)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate boolean isBipartiteDFSHelper(int node, int col, List<Integer>[] adj, int[] color) {\n    color[node] = col;\n    \n    for (int it : adj[node]) {\n        if (color[it] == -1) {\n            if (!isBipartiteDFSHelper(it, 1 - col, adj, color)) {\n                return false;\n            }\n        } else if (color[it] == col) {\n            return false;\n        }\n    }\n    return true;\n}"
  },
  {
    "name": "Check if Graph is Bipartite (BFS)",
    "endpoint": "/api/graph/is-bipartite-bfs",
    "methodName": "isBipartiteBFS",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 4, "adj": [[1,3],[0,2],[1,3],[0,2]] },
    "description": "Check if a graph is bipartite using BFS.",
    "approach": "1. A graph is bipartite if its vertices can be divided into two distinct sets such that no two adjacent vertices belong to the same set (or can be colored with two colors where no adjacent nodes have the same color).\n2. This solution uses Breadth-First Search (BFS) with a level-by-level coloring approach to check if a graph is bipartite.\n3. Implementation details:\n   a. Use an array 'color[]' to store colors (0 or 1) for each vertex. -1 represents an uncolored vertex.\n   b. Use a queue to perform BFS traversal.\n   c. For each unvisited vertex, assign it a color and enqueue it.\n   d. For each vertex in the queue, color all its uncolored adjacent vertices with the opposite color and enqueue them.\n   e. If any adjacent vertex already has the same color as the current vertex, the graph cannot be bipartite.\n4. Algorithm steps:\n   a. Initialize color[] with -1 for all vertices (indicating no color assigned).\n   b. For each uncolored vertex, start a BFS traversal:\n      i. Assign it color 0 and enqueue it.\n      ii. Process the queue until empty:\n          - For each adjacent vertex of the current node:\n            * If uncolored, assign the opposite color and enqueue it.\n            * If already colored with the same color as current node, return false.\n5. Example with V = 4, adj = [[1,3],[0,2],[1,3],[0,2]]:\n   - Start BFS from node 0, color it 0.\n   - Process node 0: Color its neighbors (1,3) with color 1.\n   - Process node 1: Color its neighbor 2 with color 0.\n   - Process node 3: No conflicts found.\n   - Process node 2: No conflicts found.\n   - The graph is bipartite as no adjacent nodes have the same color.\n6. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n7. Space Complexity: O(V) for the color array and the queue.",
    "code": "public boolean isBipartiteBFS(int V, List<Integer>[] adj) {\n    int[] color = new int[V];\n    Arrays.fill(color, -1);\n    for (int i = 0; i < V; i++) {\n        if (color[i] == -1) {\n            if (!isBipartiteBFSHelper(i, adj, color)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate boolean isBipartiteBFSHelper(int start, List<Integer>[] adj, int[] color) {\n    Queue<Integer> q = new LinkedList<>();\n    q.add(start);\n    color[start] = 0;\n    \n    while (!q.isEmpty()) {\n        int node = q.poll();\n        \n        for (int it : adj[node]) {\n            if (color[it] == -1) {\n                color[it] = 1 - color[node];\n                q.add(it);\n            } else if (color[it] == color[node]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "name": "Topological Sort (DFS)",
    "endpoint": "/api/graph/topological-sort-dfs",
    "methodName": "topologicalSortDFS",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 6, "adj": [[2,3],[3,4],[4],[5],[5],[]] },
    "description": "Perform topological sort of a directed graph using DFS.",
    "approach": "1. Topological sorting is a linear ordering of vertices in a directed graph such that for every directed edge u→v, vertex u comes before v in the ordering.\n2. Topological sorting is only possible for Directed Acyclic Graphs (DAGs).\n3. The DFS-based approach uses the concept of finishing time in DFS traversal. A vertex is added to the result only after all its adjacent vertices are processed.\n4. Implementation details:\n   a. Use a boolean array 'vis' to mark visited nodes.\n   b. Use a stack to store the vertices in topologically sorted order.\n   c. For each unvisited vertex, perform DFS traversal.\n   d. After visiting all adjacent vertices of a vertex, push it onto the stack.\n   e. After all vertices are processed, pop elements from the stack to get the topological ordering.\n5. Algorithm steps:\n   a. Initialize a visited array and an empty stack.\n   b. For each unvisited vertex, call the DFS helper function.\n   c. In the DFS helper function:\n      i. Mark the current node as visited.\n      ii. Recursively call DFS for all its adjacent unvisited vertices.\n      iii. After processing all adjacent vertices, push the current vertex onto the stack.\n   d. After DFS is complete for all vertices, pop elements from the stack to get the topological ordering.\n6. Example with V = 6, adj = [[2,3],[3,4],[4],[5],[5],[]]:\n   - Start DFS from node 0, which leads to visiting nodes 2, 4, 5, then backtrack and visit node 3.\n   - Process remaining unvisited nodes 1, which leads to visiting node 3 (already visited).\n   - Stack after DFS: [1, 0, 3, 4, 5, 2]\n   - Topological sort: [2, 5, 4, 3, 0, 1]\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n8. Space Complexity: O(V) for the visited array, stack, and recursion stack.",
    "code": "public List<Integer> topologicalSortDFS(int V, List<Integer>[] adj) {\n    boolean[] vis = new boolean[V];\n    Stack<Integer> st = new Stack<>();\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            topologicalSortDFSHelper(i, adj, vis, st);\n        }\n    }\n    List<Integer> ans = new ArrayList<>();\n    while (!st.isEmpty()) {\n        ans.add(st.pop());\n    }\n    return ans;\n}\n\nprivate void topologicalSortDFSHelper(int node, List<Integer>[] adj, boolean[] vis, Stack<Integer> st) {\n    vis[node] = true;\n    \n    for (int it : adj[node]) {\n        if (!vis[it]) {\n            topologicalSortDFSHelper(it, adj, vis, st);\n        }\n    }\n    st.push(node);\n}"
  },
  {
    "name": "Topological Sort (Kahn's Algorithm)",
    "endpoint": "/api/graph/topological-sort-kahn",
    "methodName": "topologicalSortKahn",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 6, "adj": [[2,3],[3,4],[4],[5],[5],[]] },
    "description": "Perform topological sort of a directed graph using Kahn's Algorithm (BFS).",
    "approach": "1. Kahn's algorithm provides a BFS-based approach to perform topological sorting on a Directed Acyclic Graph (DAG).\n2. The key idea is to repeatedly remove vertices with zero in-degree and their outgoing edges from the graph, adding them to the result order.\n3. Implementation details:\n   a. Calculate the in-degree (number of incoming edges) for each vertex.\n   b. Enqueue all vertices with in-degree 0 (these are vertices with no dependencies).\n   c. Iteratively dequeue vertices, add them to the result, and reduce the in-degree of their adjacent vertices.\n   d. When a vertex's in-degree becomes 0, enqueue it for processing.\n4. Algorithm steps:\n   a. Calculate in-degree for each vertex.\n   b. Initialize a queue and enqueue all vertices with in-degree 0.\n   c. While the queue is not empty:\n      i. Dequeue a vertex and add it to the result list.\n      ii. For each adjacent vertex of the current vertex:\n          - Reduce its in-degree by 1.\n          - If its in-degree becomes 0, enqueue it.\n   d. If the size of the result list equals the number of vertices, return the list. Otherwise, the graph has cycles (not a DAG).\n5. Example with V = 6, adj = [[2,3],[3,4],[4],[5],[5],[]]:\n   - In-degrees: [0, 0, 1, 1, 2, 2]\n   - Initially, nodes 0 and 1 have in-degree 0, so they're enqueued.\n   - Process node 0: Add to result, decrease in-degree of nodes 2 and 3.\n   - Process node 1: Add to result, decrease in-degree of nodes 3 and 4.\n   - Process node 2: Add to result, decrease in-degree of node 4.\n   - Process node 3: Add to result, decrease in-degree of node 5.\n   - Process node 4: Add to result, decrease in-degree of node 5.\n   - Process node 5: Add to result.\n   - Result: [0, 1, 2, 3, 4, 5]\n6. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph.\n7. Space Complexity: O(V) for the in-degree array and queue.",
    "code": "public List<Integer> topologicalSortKahn(int V, List<Integer>[] adj) {\n    int[] inDegree = new int[V];\n    for (int i = 0; i < V; i++) {\n        for (int it : adj[i]) {\n            inDegree[it]++;\n        }\n    }\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < V; i++) {\n        if (inDegree[i] == 0) {\n            q.add(i);\n        }\n    }\n    List<Integer> ans = new ArrayList<>();\n    while (!q.isEmpty()) {\n        int node = q.poll();\n        ans.add(node);\n        for (int it : adj[node]) {\n            inDegree[it]--;\n            if (inDegree[it] == 0) {\n                q.add(it);\n            }\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Dijkstra's Shortest Path Algorithm",
    "endpoint": "/api/graph/dijkstra",
    "methodName": "dijkstra",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [ [[1,2],[2,4]], [[2,1],[3,7]], [[4,3]], [[5,1]], [] ], "S": 0 },
    "description": "Find shortest paths from source to all vertices using Dijkstra's algorithm.",
    "approach": "1. Dijkstra's algorithm is a greedy algorithm for finding the shortest paths from a source vertex to all other vertices in a weighted graph with non-negative edge weights.\n2. The algorithm maintains a set of vertices whose shortest path from the source is already known and a priority queue of vertices to be processed.\n3. Implementation details:\n   a. Use a priority queue to always select the unvisited vertex with the smallest tentative distance.\n   b. Use an array 'dist' to store the shortest distance from the source to each vertex.\n   c. Initialize dist[source] = 0 and dist[v] = ∞ for all other vertices.\n   d. Repeatedly select the unvisited vertex with the minimum distance (using priority queue) and relax its adjacent vertices.\n4. Algorithm steps:\n   a. Initialize dist[] with infinity for all vertices except the source (dist[S] = 0).\n   b. Add the source vertex with distance 0 to the priority queue.\n   c. While the priority queue is not empty:\n      i. Extract the vertex with the minimum distance (u) from the queue.\n      ii. If the extracted distance is greater than the current known distance, skip this vertex.\n      iii. For each adjacent vertex v of u:\n           - If dist[u] + weight(u,v) < dist[v], update dist[v] and add v to the queue with its new distance.\n5. Example with V = 5, adj = [[[1,2],[2,4]], [[2,1],[3,7]], [[4,3]], [[5,1]], []] and S = 0:\n   - Initially, dist = [0, ∞, ∞, ∞, ∞]\n   - Process node 0: Update dist[1] = 2 and dist[2] = 4.\n   - Process node 1: Update dist[2] = min(4, 2+1) = 3, dist[3] = 9.\n   - Process node 2: Update dist[4] = 6.\n   - Process node 3, node 4: No updates.\n   - Final distances: [0, 2, 3, 9, 6]\n6. Time Complexity: O((V + E) log V) where V is the number of vertices and E is the number of edges in the graph. The log V factor comes from priority queue operations.\n7. Space Complexity: O(V) for the distance array and the priority queue.",
    "code": "public List<Integer> dijkstra(int V, List<List<Integer>>[] adj, int S) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    int[] dist = new int[V];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[S] = 0;\n    pq.add(new int[]{S, 0});\n    while (!pq.isEmpty()) {\n        int[] pair = pq.poll();\n        int node = pair[0];\n        int dis = pair[1];\n        if (dis > dist[node]) continue;\n        for (List<Integer> it : adj[node]) {\n            int adjNode = it.get(0);\n            int weight = it.get(1);\n            if (dis + weight < dist[adjNode]) {\n                dist[adjNode] = dis + weight;\n                pq.add(new int[]{adjNode, dist[adjNode]});\n            }\n        }\n    }\n    List<Integer> result = new ArrayList<>();\n    for (int d : dist) {\n        result.add(d == Integer.MAX_VALUE ? -1 : d);\n    }\n    return result;\n}"
  },
  {
    "name": "Bellman-Ford Shortest Path Algorithm",
    "endpoint": "/api/graph/bellman-ford",
    "methodName": "bellmanFord",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "edges": [[0,1,5],[1,2,3],[2,3,1],[3,4,2],[4,0,-10]], "S": 0 },
    "description": "Find shortest paths from source to all vertices using Bellman-Ford algorithm.",
    "approach": "1. The Bellman-Ford algorithm solves the single-source shortest path problem, similar to Dijkstra's algorithm, but with an important advantage: it can handle graphs with negative edge weights.\n2. Unlike Dijkstra's algorithm which is greedy, Bellman-Ford is based on dynamic programming and relaxation of edges.\n3. The core principle is: if there is a shortest path from source to any vertex using at most k edges, we can find it by considering paths using at most k-1 edges and then considering one more edge.\n4. Implementation details:\n   a. Initialize dist[source] = 0 and dist[v] = ∞ for all other vertices.\n   b. Relax all edges V-1 times, where V is the number of vertices.\n   c. In each iteration, for each edge (u,v) with weight w, if dist[u] + w < dist[v], update dist[v].\n5. Algorithm steps:\n   a. Initialize dist[] with infinity for all vertices except the source (dist[S] = 0).\n   b. Repeat V-1 times:\n      i. For each edge (u,v) with weight w:\n         - If dist[u] + w < dist[v], update dist[v] = dist[u] + w.\n   c. The shortest paths are stored in the dist[] array.\n   d. To detect negative cycles, you would perform one more iteration. If any distance decreases, there's a negative cycle.\n6. Example with V = 5, edges = [[0,1,5],[1,2,3],[2,3,1],[3,4,2],[4,0,-10]], S = 0:\n   - Initially, dist = [0, ∞, ∞, ∞, ∞]\n   - After first few iterations: [0, 5, 8, 9, 11]\n   - With the negative cycle through edge [4,0,-10], eventually: [0, 5, 8, 9, 11] → [-10, -5, -2, -1, 1] → ...\n7. Time Complexity: O(V * E) where V is the number of vertices and E is the number of edges in the graph.\n8. Space Complexity: O(V) for the distance array.",
    "code": "public List<Integer> bellmanFord(int V, List<List<Integer>> edges, int S) {\n    int[] dist = new int[V];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[S] = 0;\n    for (int i = 0; i < V - 1; i++) {\n        for (List<Integer> edge : edges) {\n            int u = edge.get(0);\n            int v = edge.get(1);\n            int wt = edge.get(2);\n            if (dist[u] != Integer.MAX_VALUE && dist[u] + wt < dist[v]) {\n                dist[v] = dist[u] + wt;\n            }\n        }\n    }\n    List<Integer> result = new ArrayList<>();\n    for (int d : dist) {\n        result.add(d == Integer.MAX_VALUE ? -1 : d);\n    }\n    return result;\n}"
  },
  {
    "name": "Floyd-Warshall All-Pairs Shortest Path",
    "endpoint": "/api/graph/floyd-warshall",
    "methodName": "floydWarshall",
    "serviceFile": "GraphService.java",
    "defaultInput": { "matrix": [[0,3,-1,-1],[2,0,-1,1],[-1,7,0,2],[6,-1,-1,0]] },
    "description": "Find shortest paths between all pairs of vertices using Floyd-Warshall algorithm.",
    "approach": "1. The Floyd-Warshall algorithm finds the shortest paths between all pairs of vertices in a weighted graph with positive or negative edge weights (but no negative cycles).\n2. Unlike Dijkstra's and Bellman-Ford which are single-source shortest path algorithms, Floyd-Warshall solves the all-pairs shortest path problem in one execution.\n3. The algorithm is based on dynamic programming and uses a simple but powerful insight: if there is a shorter path from i to j that goes through vertex k, we should update our shortest path.\n4. Implementation details:\n   a. The input is a matrix where matrix[i][j] represents the weight of the edge from vertex i to vertex j. -1 typically indicates no direct edge.\n   b. The algorithm progressively improves the shortest path estimate between each pair of vertices by considering intermediate vertices.\n5. Algorithm steps:\n   a. Initialize the distance matrix with the given adjacency matrix (direct edge weights).\n   b. For each vertex k (as an intermediate vertex):\n      i. For each pair of vertices i and j:\n         - If there is a path from i to k and from k to j (i.e., they are not -1):\n         - If there is no direct path from i to j (-1) OR if the path through k is shorter:\n           Update matrix[i][j] to matrix[i][k] + matrix[k][j].\n6. Example with matrix = [[0,3,-1,-1],[2,0,-1,1],[-1,7,0,2],[6,-1,-1,0]]:\n   - For k=0 (vertex 0 as intermediate):\n     * Checking path from 1 to 3: No direct edge (matrix[1][3]=1), through 0: matrix[1][0]=2 + matrix[0][3]=-1 (no path). No update.\n   - For k=1 (vertex 1 as intermediate):\n     * Checking path from 0 to 3: No direct edge (matrix[0][3]=-1), through 1: matrix[0][1]=3 + matrix[1][3]=1 = 4. Update matrix[0][3]=4.\n   - Continue for all intermediate vertices and pairs.\n7. Time Complexity: O(V³) where V is the number of vertices in the graph.\n8. Space Complexity: O(V²) for the distance matrix, but the algorithm can be implemented in-place.",
    "code": "public int[][] floydWarshall(int[][] matrix) {\n    int n = matrix.length;\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][k] != -1 && matrix[k][j] != -1) {\n                    if (matrix[i][j] == -1 || matrix[i][k] + matrix[k][j] < matrix[i][j]) {\n                        matrix[i][j] = matrix[i][k] + matrix[k][j];\n                    }\n                }\n            }\n        }\n    }\n    return matrix;\n}"
  },
  {
    "name": "Kruskal's Minimum Spanning Tree",
    "endpoint": "/api/graph/kruskal",
    "methodName": "kruskal",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 4, "edges": [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]] },
    "description": "Find the weight of the minimum spanning tree using Kruskal's algorithm.",
    "approach": "1. Kruskal's algorithm finds a minimum spanning tree (MST) for a connected, undirected graph with weighted edges. An MST is a subset of edges that connects all vertices with the minimum possible total edge weight and no cycles.\n2. The algorithm uses a greedy approach: it sorts all edges by weight and iteratively adds the smallest edge that doesn't create a cycle.\n3. To efficiently check if adding an edge creates a cycle, Kruskal's algorithm uses the Union-Find (Disjoint Set) data structure.\n4. Implementation details:\n   a. Sort all edges in non-decreasing order of their weight.\n   b. Use a Union-Find data structure to detect cycles and keep track of connected components.\n   c. Initialize each vertex as a separate component (parent[i] = i).\n   d. Iterate through sorted edges and include an edge in the MST if it doesn't form a cycle with the edges already included.\n5. Algorithm steps:\n   a. Sort all edges in non-decreasing order of their weight.\n   b. Initialize MST weight to 0 and Union-Find data structure.\n   c. For each edge (u,v) with weight w in the sorted order:\n      i. If including this edge doesn't create a cycle (i.e., u and v are in different connected components):\n         - Add it to the MST (union the sets containing u and v).\n         - Add its weight to the MST weight.\n   d. Return the total weight of the MST.\n6. Example with V = 4, edges = [[0,1,10],[0,2,6],[0,3,5],[1,3,15],[2,3,4]]:\n   - Sorted edges: [2,3,4], [0,3,5], [0,2,6], [0,1,10], [1,3,15]\n   - Process [2,3,4]: Add to MST, mstWt = 4\n   - Process [0,3,5]: Add to MST, mstWt = 4 + 5 = 9\n   - Process [0,2,6]: Skip (would create a cycle with edges [2,3,4] and [0,3,5])\n   - Process [0,1,10]: Add to MST, mstWt = 9 + 10 = 19\n   - Process [1,3,15]: Skip (would create a cycle)\n   - Final MST weight: 19\n7. Time Complexity: O(E log E) where E is the number of edges in the graph. Sorting the edges takes O(E log E) time.\n8. Space Complexity: O(V) for the Union-Find data structure.",
    "code": "public int kruskal(int V, List<List<Integer>> edges) {\n    Collections.sort(edges, (a, b) -> a.get(2) - b.get(2));\n    int[] parent = new int[V];\n    int[] rank = new int[V];\n    for (int i = 0; i < V; i++) {\n        parent[i] = i;\n    }\n    int mstWt = 0;\n    for (List<Integer> edge : edges) {\n        int u = edge.get(0);\n        int v = edge.get(1);\n        int wt = edge.get(2);\n        if (findPar(u, parent) != findPar(v, parent)) {\n            union(u, v, parent, rank);\n            mstWt += wt;\n        }\n    }\n    return mstWt;\n}\n\nprivate int findPar(int u, int[] parent) {\n    if (u == parent[u]) return u;\n    return parent[u] = findPar(parent[u], parent);\n}\n\nprivate void union(int u, int v, int[] parent, int[] rank) {\n    u = findPar(u, parent);\n    v = findPar(v, parent);\n    \n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    } else if (rank[v] < rank[u]) {\n        parent[v] = u;\n    } else {\n        parent[v] = u;\n        rank[u]++;\n    }\n}"
  },
  {
    "name": "Prim's Minimum Spanning Tree",
    "endpoint": "/api/graph/prim",
    "methodName": "prim",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [ [[1,2],[2,3]], [[0,2],[3,4]], [[0,3],[4,5]], [[1,4],[4,1]], [[2,5],[3,1]] ] },
    "description": "Find the weight of the minimum spanning tree using Prim's algorithm.",
    "approach": "1. Prim's algorithm is another greedy approach for finding a minimum spanning tree (MST) in a connected, undirected graph with weighted edges.\n2. Unlike Kruskal's which processes edges globally, Prim's algorithm grows the MST from a single vertex, adding the lowest-weight edge that connects a vertex in the MST to a vertex outside the MST.\n3. The algorithm maintains two sets of vertices: those already included in the MST and those not yet included.\n4. Implementation details:\n   a. Use a priority queue to efficiently find the next minimum-weight edge to add to the MST.\n   b. Use a boolean array to keep track of vertices already included in the MST.\n   c. Start from any vertex (typically 0) and greedily select the next vertex to include based on edge weights.\n5. Algorithm steps:\n   a. Initialize a priority queue (to store vertices with their edge weights), a visited array, and MST weight.\n   b. Add the starting vertex (0) to the queue with weight 0.\n   c. While the queue is not empty:\n      i. Extract the vertex with the minimum edge weight.\n      ii. If it's already visited, skip it (to avoid cycles).\n      iii. Mark it as visited and add its edge weight to the MST weight.\n      iv. Add all its unvisited adjacent vertices to the priority queue.\n6. Example with V = 5, adj = [[[1,2],[2,3]], [[0,2],[3,4]], [[0,3],[4,5]], [[1,4],[4,1]], [[2,5],[3,1]]]:\n   - Start at vertex 0 with weight 0: Add to MST, sum = 0.\n   - Add its adjacent vertices to queue: (1,2), (2,3).\n   - Process vertex 1 (min weight): Add to MST, sum = 0+2 = 2.\n   - Add its adjacent unvisited vertex to queue: (3,4).\n   - Process vertex 2 (next min weight): Add to MST, sum = 2+3 = 5.\n   - Add its adjacent unvisited vertex to queue: (4,5).\n   - Process vertex 4 (next min weight): Add to MST, sum = 5+1 = 6 (from edge 3-4).\n   - Process vertex 3 (next min weight): Add to MST, sum = 6+1 = 7.\n   - All vertices are now in the MST with total weight 7.\n7. Time Complexity: O(E log V) where E is the number of edges and V is the number of vertices in the graph. The log V factor comes from priority queue operations.\n8. Space Complexity: O(V) for the visited array and priority queue.",
    "code": "public int prim(int V, List<List<Integer>>[] adj) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n    boolean[] vis = new boolean[V];\n    pq.add(new int[]{0, 0});\n    int sum = 0;\n    while (!pq.isEmpty()) {\n        int[] pair = pq.poll();\n        int node = pair[0];\n        int wt = pair[1];\n        if (vis[node]) continue;\n        vis[node] = true;\n        sum += wt;\n        for (List<Integer> it : adj[node]) {\n            int adjNode = it.get(0);\n            int adjWt = it.get(1);\n            if (!vis[adjNode]) {\n                pq.add(new int[]{adjNode, adjWt});\n            }\n        }\n    }\n    return sum;\n}"
  },
  {
    "name": "Number of Islands",
    "endpoint": "/api/graph/num-islands",
    "methodName": "numIslands",
    "serviceFile": "GraphService.java",
    "defaultInput": { "grid": [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]] },
    "description": "Count the number of islands in a 2D grid.",
    "approach": "1. An island in a 2D grid is a group of connected '1's (land) surrounded by '0's (water) or the edges of the grid. Two cells are considered connected if they are horizontally or vertically adjacent.\n2. The task is to count the total number of distinct islands in the grid.\n3. The solution uses a Depth-First Search (DFS) approach to identify and mark islands.\n4. Implementation details:\n   a. Traverse the entire grid cell by cell.\n   b. When a land cell ('1') is found, increment the island counter and use DFS to mark all connected land cells as visited (by changing them to '0').\n   c. The DFS ensures that all cells belonging to the same island are visited and marked in a single traversal.\n5. Algorithm steps:\n   a. Initialize a counter for the number of islands.\n   b. Iterate through each cell in the grid:\n      i. If the current cell is land ('1'):\n         - Increment the island counter.\n         - Call DFS to mark all connected land cells as visited.\n   c. In the DFS function:\n      i. Check boundary conditions and if the current cell is land.\n      ii. Mark the current cell as water ('0') to indicate it has been visited.\n      iii. Recursively call DFS for the four adjacent cells (up, down, left, right).\n6. Example with grid = [['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']]:\n   - First island: (0,0), (0,1), (1,0), (1,1) - Connected land cells in the top-left.\n   - Second island: (2,2) - A single land cell.\n   - Third island: (3,3), (3,4) - Connected land cells in the bottom-right.\n   - Total islands: 3\n7. Time Complexity: O(N × M) where N is the number of rows and M is the number of columns in the grid. Each cell is processed exactly once.\n8. Space Complexity: O(N × M) in the worst case for the recursion stack when the grid is filled with land cells.",
    "code": "public int numIslands(char[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == '1') {\n                count++;\n                dfsIslands(i, j, grid);\n            }\n        }\n    }\n    return count;\n}\n\nprivate void dfsIslands(int i, int j, char[][] grid) {\n    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {\n        return;\n    }\n    \n    grid[i][j] = '0';\n    dfsIslands(i + 1, j, grid);\n    dfsIslands(i - 1, j, grid);\n    dfsIslands(i, j + 1, grid);\n    dfsIslands(i, j - 1, grid);\n}"
  },
  {
    "name": "Flood Fill Algorithm",
    "endpoint": "/api/graph/flood-fill",
    "methodName": "floodFill",
    "serviceFile": "GraphService.java",
    "defaultInput": { "image": [[1,1,1],[1,1,0],[1,0,1]], "sr": 1, "sc": 1, "color": 2 },
    "description": "Perform flood fill on a 2D image starting from a given cell.",
    "approach": "1. The flood fill algorithm is similar to the bucket/paint fill tool in graphics editing programs. It changes all connected cells of the same color to a new color, starting from a specified cell.\n2. A cell is connected to another cell if they are adjacent horizontally or vertically (4-directional).\n3. The solution uses a Depth-First Search (DFS) approach to find and color all connected cells with the same original color.\n4. Implementation details:\n   a. Record the original color of the starting cell.\n   b. If the original color is already the target color, return the image unchanged (to avoid unnecessary processing and potential infinite recursion).\n   c. Use DFS to traverse and color all connected cells with the same original color.\n5. Algorithm steps:\n   a. Get the original color of the starting cell (sr, sc).\n   b. If the original color is the same as the target color, return the image unchanged.\n   c. Call the DFS function starting from (sr, sc).\n   d. In the DFS function:\n      i. Check boundary conditions and if the current cell has the original color.\n      ii. Change the color of the current cell to the target color.\n      iii. Recursively call DFS for the four adjacent cells (up, down, left, right).\n6. Example with image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2:\n   - Original color at (1,1) is 1.\n   - DFS starts at (1,1) and colors it to 2.\n   - DFS explores connected cells with color 1: (0,0), (0,1), (0,2), (1,0), (2,0).\n   - After flood fill: [[2,2,2],[2,2,0],[2,0,1]]\n7. Time Complexity: O(N × M) where N is the number of rows and M is the number of columns in the image. In the worst case, if all cells have the same color, we visit each cell once.\n8. Space Complexity: O(N × M) in the worst case for the recursion stack when the entire image has the same color.",
    "code": "public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n    int oldColor = image[sr][sc];\n    if (oldColor == color) return image;\n    dfsFloodFill(sr, sc, image, oldColor, color);\n    return image;\n}\n\nprivate void dfsFloodFill(int i, int j, int[][] image, int oldColor, int newColor) {\n    if (i < 0 || i >= image.length || j < 0 || j >= image[0].length || image[i][j] != oldColor) {\n        return;\n    }\n    \n    image[i][j] = newColor;\n    dfsFloodFill(i + 1, j, image, oldColor, newColor);\n    dfsFloodFill(i - 1, j, image, oldColor, newColor);\n    dfsFloodFill(i, j + 1, image, oldColor, newColor);\n    dfsFloodFill(i, j - 1, image, oldColor, newColor);\n}"
  },
  {
    "name": "Course Schedule (Can Finish All Courses)",
    "endpoint": "/api/graph/can-finish",
    "methodName": "canFinish",
    "serviceFile": "GraphService.java",
    "defaultInput": { "numCourses": 2, "prerequisites": [[1,0]] },
    "description": "Determine if all courses can be finished given prerequisites.",
    "approach": "1. The problem is essentially asking if there is a valid way to complete all courses, given the prerequisite relationships between them.\n2. This can be modeled as a directed graph problem where each course is a vertex, and there is a directed edge from course A to course B if B is a prerequisite for A.\n3. The key insight is that we can finish all courses if and only if there is no cycle in the directed graph. If there is a cycle, it means there is a circular dependency between courses, which makes it impossible to complete them all.\n4. Implementation details:\n   a. Build an adjacency list representation of the graph from the prerequisites.\n   b. Use a cycle detection algorithm (such as DFS) to check if the directed graph contains any cycles.\n5. Algorithm steps:\n   a. Create an adjacency list representation of the graph where adj[i] contains all courses that have course i as a prerequisite.\n   b. Use the isCyclicDFS function to check if the directed graph contains a cycle.\n   c. Return true if no cycle is found (all courses can be finished), otherwise return false.\n6. Example with numCourses = 2, prerequisites = [[1,0]] (meaning course 1 has course 0 as a prerequisite):\n   - Build adjacency list: adj[0] = [1], adj[1] = []\n   - Check for cycles: No cycle found\n   - Result: true (all courses can be finished)\n7. Time Complexity: O(V + E) where V is the number of courses (vertices) and E is the number of prerequisites (edges) in the graph.\n8. Space Complexity: O(V + E) for the adjacency list and visited arrays.",
    "code": "public boolean canFinish(int numCourses, List<List<Integer>> prerequisites) {\n    List<Integer>[] adj = new List[numCourses];\n    for (int i = 0; i < numCourses; i++) {\n        adj[i] = new ArrayList<>();\n    }\n    for (List<Integer> pre : prerequisites) {\n        adj[pre.get(1)].add(pre.get(0));\n    }\n    return !isCyclicDFS(numCourses, adj);\n}\n\nprivate boolean isCyclicDFS(int V, List<Integer>[] adj) {\n    boolean[] vis = new boolean[V];\n    boolean[] dfsVis = new boolean[V];\n    \n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            if (isCyclicDFSHelper(i, adj, vis, dfsVis)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean isCyclicDFSHelper(int node, List<Integer>[] adj, boolean[] vis, boolean[] dfsVis) {\n    vis[node] = true;\n    dfsVis[node] = true;\n    \n    for (int it : adj[node]) {\n        if (!vis[it]) {\n            if (isCyclicDFSHelper(it, adj, vis, dfsVis)) {\n                return true;\n            }\n        } else if (dfsVis[it]) {\n            return true;\n        }\n    }\n    dfsVis[node] = false;\n    return false;\n}"
  },
  {
    "name": "Course Schedule II (Find Order)",
    "endpoint": "/api/graph/find-order",
    "methodName": "findOrder",
    "serviceFile": "GraphService.java",
    "defaultInput": { "numCourses": 2, "prerequisites": [[1,0]] },
    "description": "Find a possible order to finish all courses given prerequisites.",
    "approach": "1. This problem extends the Course Schedule problem by not only determining if all courses can be finished, but also finding a valid order in which they should be taken.\n2. The order in which courses should be taken is essentially a topological sort of the directed graph representing the course dependencies.\n3. Topological sorting gives a linear ordering of vertices such that for every directed edge u→v, u comes before v in the ordering. This is exactly what we need for the course order.\n4. Implementation details:\n   a. Build an adjacency list representation of the graph from the prerequisites.\n   b. Use Kahn's algorithm (BFS-based topological sort) to find a valid course order.\n   c. If a valid topological sort doesn't exist (i.e., there's a cycle), return an empty list.\n5. Algorithm steps:\n   a. Create an adjacency list representation of the graph where adj[i] contains all courses that have course i as a prerequisite.\n   b. Use the topologicalSortKahn function to find a topological ordering of the courses.\n   c. If the size of the result is equal to numCourses, return the result. Otherwise, there is a cycle, and we return an empty list.\n6. Example with numCourses = 2, prerequisites = [[1,0]] (meaning course 1 has course 0 as a prerequisite):\n   - Build adjacency list: adj[0] = [1], adj[1] = []\n   - Apply Kahn's algorithm:\n     * Calculate in-degrees: inDegree[0] = 0, inDegree[1] = 1\n     * Add course 0 to queue (it has in-degree 0)\n     * Process course 0: Add to result, reduce in-degree of course 1 to 0\n     * Add course 1 to queue\n     * Process course 1: Add to result\n   - Final order: [0, 1]\n7. Time Complexity: O(V + E) where V is the number of courses (vertices) and E is the number of prerequisites (edges) in the graph.\n8. Space Complexity: O(V + E) for the adjacency list, queue, and result list.",
    "code": "public List<Integer> findOrder(int numCourses, List<List<Integer>> prerequisites) {\n    List<Integer>[] adj = new List[numCourses];\n    for (int i = 0; i < numCourses; i++) {\n        adj[i] = new ArrayList<>();\n    }\n    for (List<Integer> pre : prerequisites) {\n        adj[pre.get(1)].add(pre.get(0));\n    }\n    List<Integer> result = topologicalSortKahn(numCourses, adj);\n    return result.size() == numCourses ? result : new ArrayList<>();\n}\n\nprivate List<Integer> topologicalSortKahn(int V, List<Integer>[] adj) {\n    int[] inDegree = new int[V];\n    for (int i = 0; i < V; i++) {\n        for (int it : adj[i]) {\n            inDegree[it]++;\n        }\n    }\n    Queue<Integer> q = new LinkedList<>();\n    for (int i = 0; i < V; i++) {\n        if (inDegree[i] == 0) {\n            q.add(i);\n        }\n    }\n    List<Integer> ans = new ArrayList<>();\n    while (!q.isEmpty()) {\n        int node = q.poll();\n        ans.add(node);\n        for (int it : adj[node]) {\n            inDegree[it]--;\n            if (inDegree[it] == 0) {\n                q.add(it);\n            }\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Number of Provinces",
    "endpoint": "/api/graph/num-provinces",
    "methodName": "numProvinces",
    "serviceFile": "GraphService.java",
    "defaultInput": { "isConnected": [[1,1,0],[1,1,0],[0,0,1]] },
    "description": "Count the number of provinces (connected components) in an undirected graph.",
    "approach": "1. A province is a group of directly or indirectly connected cities, with no other cities outside of the group. In graph theory terms, it's a connected component in an undirected graph.\n2. The problem provides an adjacency matrix representation of the graph where isConnected[i][j] = 1 indicates that city i and city j are directly connected, and isConnected[i][j] = 0 indicates they are not directly connected.\n3. The solution uses a Depth-First Search (DFS) approach to identify all connected components in the graph.\n4. Implementation details:\n   a. Use a boolean array 'vis' to keep track of visited nodes.\n   b. For each unvisited node, increment the province counter and use DFS to mark all nodes in that province as visited.\n5. Algorithm steps:\n   a. Initialize a counter for the number of provinces and a visited array.\n   b. For each node i from 0 to n-1:\n      i. If node i has not been visited:\n         - Increment the province counter.\n         - Call DFS to mark all nodes in the same province as visited.\n   c. In the DFS function:\n      i. Mark the current node as visited.\n      ii. For each adjacent node (as indicated by the adjacency matrix), if it's not visited, recursively call DFS.\n6. Example with isConnected = [[1,1,0],[1,1,0],[0,0,1]]:\n   - Start with node 0: Mark 0 as visited, DFS also visits node 1. Count = 1.\n   - Node 1 is already visited, skip.\n   - Node 2 is not visited: Mark 2 as visited. Count = 2.\n   - Final count: 2 provinces ([0,1] and [2]).\n7. Time Complexity: O(n²) where n is the number of cities (nodes). We potentially visit each node once and for each node, we check its connection with all other nodes.\n8. Space Complexity: O(n) for the visited array and the recursion stack.",
    "code": "public int numProvinces(int[][] isConnected) {\n    int n = isConnected.length;\n    boolean[] vis = new boolean[n];\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            count++;\n            dfsProvinces(i, isConnected, vis);\n        }\n    }\n    return count;\n}\n\nprivate void dfsProvinces(int node, int[][] isConnected, boolean[] vis) {\n    vis[node] = true;\n    \n    for (int i = 0; i < isConnected.length; i++) {\n        if (isConnected[node][i] == 1 && !vis[i]) {\n            dfsProvinces(i, isConnected, vis);\n        }\n    }\n}"
  },
  {
    "name": "Rotting Oranges",
    "endpoint": "/api/graph/oranges-rotting",
    "methodName": "orangesRotting",
    "serviceFile": "GraphService.java",
    "defaultInput": { "grid": [[2,1,1],[1,1,0],[0,1,1]] },
    "description": "Find the minimum time to rot all oranges in a grid.",
    "approach": "1. In this problem, we have a grid where each cell can contain:\n   - 0: representing an empty cell\n   - 1: representing a fresh orange\n   - 2: representing a rotten orange\n2. Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten. We need to find the minimum time until no fresh oranges are left, or return -1 if it's impossible.\n3. This is a classic scenario for using Breadth-First Search (BFS) to simulate the rotting process level by level (or minute by minute).\n4. Implementation details:\n   a. Use a queue to keep track of all initially rotten oranges.\n   b. Count the number of fresh oranges at the beginning.\n   c. Perform BFS to rot adjacent fresh oranges minute by minute.\n   d. Keep track of the minutes elapsed and the number of fresh oranges left.\n5. Algorithm steps:\n   a. Initialize a queue for BFS and count all fresh oranges.\n   b. If there are no fresh oranges initially, return 0 (no time needed).\n   c. Add all initially rotten oranges to the queue.\n   d. Perform BFS:\n      i. For each minute, process all rotten oranges in the queue.\n      ii. For each rotten orange, check its four adjacent cells.\n      iii. If an adjacent cell contains a fresh orange, rot it, add it to the queue, and decrease the fresh orange count.\n   e. After BFS, if there are still fresh oranges left, return -1 (impossible to rot all oranges).\n   f. Otherwise, return the time elapsed.\n6. Example with grid = [[2,1,1],[1,1,0],[0,1,1]]:\n   - Initially: 1 rotten orange, 5 fresh oranges\n   - Minute 1: Orange at (0,1) becomes rotten. 4 fresh oranges left.\n   - Minute 2: Oranges at (0,2) and (1,1) become rotten. 2 fresh oranges left.\n   - Minute 3: Orange at (2,1) becomes rotten. 1 fresh orange left.\n   - Minute 4: Orange at (2,2) becomes rotten. 0 fresh oranges left.\n   - Result: 4 minutes\n7. Time Complexity: O(N × M) where N is the number of rows and M is the number of columns in the grid. Each cell is processed at most once.\n8. Space Complexity: O(N × M) for the queue in the worst case if all cells contain rotten oranges initially.",
    "code": "public int orangesRotting(int[][] grid) {\n    int n = grid.length;\n    int m = grid[0].length;\n    Queue<int[]> q = new LinkedList<>();\n    int fresh = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 2) {\n                q.add(new int[]{i, j});\n            } else if (grid[i][j] == 1) {\n                fresh++;\n            }\n        }\n    }\n    if (fresh == 0) return 0;\n    int time = 0;\n    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    while (!q.isEmpty() && fresh > 0) {\n        int size = q.size();\n        time++;\n        for (int i = 0; i < size; i++) {\n            int[] curr = q.poll();\n            for (int[] dir : dirs) {\n                int newRow = curr[0] + dir[0];\n                int newCol = curr[1] + dir[1];\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && grid[newRow][newCol] == 1) {\n                    grid[newRow][newCol] = 2;\n                    q.add(new int[]{newRow, newCol});\n                    fresh--;\n                }\n            }\n        }\n    }\n    return fresh == 0 ? time : -1;\n}"
  },
  {
    "name": "Word Ladder Length",
    "endpoint": "/api/graph/word-ladder-length",
    "methodName": "wordLadderLength",
    "serviceFile": "GraphService.java",
    "defaultInput": { "wordList": ["hot","dot","dog","lot","log","cog"], "beginWord": "hit", "endWord": "cog" },
    "description": "Find the length of the shortest transformation sequence from beginWord to endWord.",
    "approach": "1. The Word Ladder problem asks for the length of the shortest transformation sequence from beginWord to endWord, where in each step, we can change exactly one letter of the word and the result must be a word in the given word list.\n2. This can be modeled as a graph problem, where each word is a node, and there is an edge between two words if they differ by exactly one letter.\n3. Since we want the shortest transformation sequence, Breadth-First Search (BFS) is the ideal approach as it explores all possible paths level by level.\n4. Implementation details:\n   a. Use a HashSet to store the words from the word list for O(1) lookup.\n   b. Use a queue for BFS traversal to explore words level by level.\n   c. For each word in the queue, try changing each character to all possible letters (a-z) and check if the resulting word is in the word list.\n   d. Remove words from the set once they are visited to avoid cycles.\n5. Algorithm steps:\n   a. Check if the endWord is in the word list. If not, return 0 (no transformation sequence possible).\n   b. Initialize a queue with the beginWord and a level counter to 1.\n   c. While the queue is not empty:\n      i. For each word in the current level:\n         - If it equals the endWord, return the current level (transformation sequence length).\n         - Try changing each character of the word to all possible letters (a-z).\n         - If a new word is in the word list, add it to the queue and remove it from the set to mark it as visited.\n      ii. Increment the level counter.\n   d. If the queue becomes empty without finding the endWord, return 0 (no transformation sequence possible).\n6. Example with wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"], beginWord = \"hit\", endWord = \"cog\":\n   - Start with \"hit\" at level 1.\n   - Transform \"hit\" to \"hot\" at level 2.\n   - Transform \"hot\" to \"dot\" and \"lot\" at level 3.\n   - Transform \"dot\" to \"dog\" and \"lot\" to \"log\" at level 4.\n   - Transform \"dog\" and \"log\" to \"cog\" at level 5.\n   - Result: 5 (the length of the transformation sequence).\n7. Time Complexity: O(M² × N) where M is the length of each word and N is the total number of words in the word list. For each word, we try all possible transformations which takes O(M²) time, and in the worst case, we might need to do this for all N words.\n8. Space Complexity: O(N) for the queue and set.",
    "code": "public int wordLadderLength(List<String> wordList, String beginWord, String endWord) {\n    Set<String> set = new HashSet<>(wordList);\n    if (!set.contains(endWord)) return 0;\n    Queue<String> q = new LinkedList<>();\n    q.add(beginWord);\n    int level = 1;\n    while (!q.isEmpty()) {\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            String curr = q.poll();\n            if (curr.equals(endWord)) return level;\n            char[] arr = curr.toCharArray();\n            for (int j = 0; j < arr.length; j++) {\n                char original = arr[j];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    arr[j] = c;\n                    String newWord = new String(arr);\n                    if (set.contains(newWord)) {\n                        set.remove(newWord);\n                        q.add(newWord);\n                    }\n                }\n                arr[j] = original;\n            }\n        }\n        level++;\n    }\n    return 0;\n}"
  },
  {
    "name": "Cheapest Flight Within K Stops",
    "endpoint": "/api/graph/cheapest-flight",
    "methodName": "cheapestFlight",
    "serviceFile": "GraphService.java",
    "defaultInput": { "n": 4, "flights": [[0,1,100],[1,2,100],[2,3,100],[0,2,500]], "src": 0, "dst": 3, "k": 1 },
    "description": "Find the cheapest price from src to dst with at most k stops.",
    "approach": "1. This problem asks for the cheapest price to fly from source city to destination city with at most k stops. It's a shortest path problem with an additional constraint on the number of stops.\n2. Unlike standard shortest path algorithms like Dijkstra's, we need to track not only the cost but also the number of stops made so far.\n3. A modified BFS approach works well for this, where we explore paths level by level (by number of stops) and update the minimum cost to reach each city.\n4. Implementation details:\n   a. Build an adjacency list representation of the flight network.\n   b. Use a queue for BFS traversal, storing the current node, accumulated cost, and number of stops.\n   c. Maintain a distance array to keep track of the minimum cost to reach each city.\n   d. If a path with fewer stops or lower cost is found, update the distance and enqueue the next node.\n5. Algorithm steps:\n   a. Build an adjacency list where adj[i] contains pairs (j, cost) meaning there is a flight from i to j with the given cost.\n   b. Initialize a distance array with infinity for all cities except the source (dist[src] = 0).\n   c. Initialize a queue with the source city, 0 cost, and 0 stops.\n   d. While the queue is not empty:\n      i. Dequeue a triplet (node, cost, stops).\n      ii. If stops > k, skip this path.\n      iii. For each neighbor of the current node:\n           - If the new path has a lower cost than the known best cost to reach this neighbor, update the cost and enqueue the neighbor with incremented stops.\n   e. Return the minimum cost to reach the destination or -1 if it's not possible within k stops.\n6. Example with n = 4, flights = [[0,1,100],[1,2,100],[2,3,100],[0,2,500]], src = 0, dst = 3, k = 1:\n   - Start at city 0 with cost 0 and 0 stops.\n   - Explore neighbors of city 0: city 1 (cost 100, 1 stop) and city 2 (cost 500, 1 stop).\n   - From city 1: Going to city 2 would make 2 stops, exceeding k=1.\n   - From city 2: Going to city 3 costs 500+100=600 with 2 stops, exceeding k=1.\n   - No valid path found, return -1.\n7. Time Complexity: O(V + E * k) where V is the number of cities, E is the number of flights, and k is the maximum number of stops. In the worst case, we might enqueue each edge up to k times.\n8. Space Complexity: O(V + E) for the adjacency list, queue, and distance array.",
    "code": "public int cheapestFlight(int n, List<List<Integer>> flights, int src, int dst, int k) {\n    List<List<int[]>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (List<Integer> flight : flights) {\n        adj.get(flight.get(0)).add(new int[]{flight.get(1), flight.get(2)});\n    }\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[src] = 0;\n    Queue<int[]> q = new LinkedList<>();\n    q.add(new int[]{src, 0, 0});\n    while (!q.isEmpty()) {\n        int[] curr = q.poll();\n        int node = curr[0];\n        int cost = curr[1];\n        int stops = curr[2];\n        if (stops > k) continue;\n        for (int[] neighbor : adj.get(node)) {\n            int nextNode = neighbor[0];\n            int nextCost = neighbor[1];\n            if (cost + nextCost < dist[nextNode] && stops <= k) {\n                dist[nextNode] = cost + nextCost;\n                q.add(new int[]{nextNode, dist[nextNode], stops + 1});\n            }\n        }\n    }\n    return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\n}"
  },
  {
    "name": "Articulation Points in a Graph",
    "endpoint": "/api/graph/articulation-points",
    "methodName": "articulationPoints",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [[1,2],[0,2],[0,1,3,4],[2,4],[2,3]] },
    "description": "Find all articulation points (cut vertices) in a graph.",
    "approach": "1. An articulation point (or cut vertex) in an undirected connected graph is a vertex whose removal increases the number of connected components in the graph.\n2. These points are critical in network analysis as they represent single points of failure in a connected system.\n3. The algorithm uses a modified Depth-First Search (DFS) to identify articulation points, utilizing two key concepts:\n   a. Discovery time (tin): The time (or order) in which a node is first visited during DFS.\n   b. Low time (low): The earliest discovery time reachable from a node via its subtree in the DFS traversal.\n4. Implementation details:\n   a. Use arrays to track visited nodes, discovery times, low times, and identified articulation points.\n   b. The key insight is that a non-root node is an articulation point if, for any of its children, the lowest discovery time reachable from the child is greater than or equal to the discovery time of the node.\n   c. The root of the DFS tree is an articulation point if and only if it has more than one child in the DFS tree.\n5. Algorithm steps:\n   a. Initialize visited, tin (discovery time), low, and mark arrays. Start a timer at 0.\n   b. For each unvisited vertex, call the DFS function starting with the vertex as root.\n   c. In the DFS function:\n      i. Mark the current node as visited and set its discovery and low time to the current timer value.\n      ii. For each adjacent node:\n          - If it's the parent, skip it.\n          - If it's not visited, recursively call DFS and update the current node's low time if needed.\n          - If an adjacent node is already visited, update the current node's low time if possible.\n      iii. Check if the current node is an articulation point:\n           - If it's the root of the DFS tree and has multiple children, it's an articulation point.\n           - If it's not the root and for any child, the lowest time reachable from the child is greater than or equal to the discovery time of the current node, it's an articulation point.\n6. Example with V = 5, adj = [[1,2],[0,2],[0,1,3,4],[2,4],[2,3]]:\n   - Node 2 is an articulation point because its removal would disconnect nodes 3 and 4 from nodes 0 and 1.\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph. We perform a single DFS traversal.\n8. Space Complexity: O(V) for the various arrays used to track node properties.",
    "code": "public List<Integer> articulationPoints(int V, List<Integer>[] adj) {\n    boolean[] vis = new boolean[V];\n    int[] tin = new int[V];\n    int[] low = new int[V];\n    int[] mark = new int[V];\n    int timer = 0;\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            dfsArticulation(i, -1, adj, vis, tin, low, mark, timer);\n        }\n    }\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i < V; i++) {\n        if (mark[i] == 1) {\n            ans.add(i);\n        }\n    }\n    return ans;\n}\n\nprivate void dfsArticulation(int node, int parent, List<Integer>[] adj, boolean[] vis, \n                            int[] tin, int[] low, int[] mark, int timer) {\n    vis[node] = true;\n    tin[node] = low[node] = timer++;\n    int child = 0;\n    \n    for (int it : adj[node]) {\n        if (it == parent) continue;\n        \n        if (!vis[it]) {\n            dfsArticulation(it, node, adj, vis, tin, low, mark, timer);\n            low[node] = Math.min(low[node], low[it]);\n            \n            if (low[it] >= tin[node] && parent != -1) {\n                mark[node] = 1;\n            }\n            child++;\n        } else {\n            low[node] = Math.min(low[node], tin[it]);\n        }\n    }\n    \n    if (child > 1 && parent == -1) {\n        mark[node] = 1;\n    }\n}"
  },
  {
    "name": "Critical Connections (Bridges) in a Network",
    "endpoint": "/api/graph/critical-connections",
    "methodName": "criticalConnections",
    "serviceFile": "GraphService.java",
    "defaultInput": { "n": 5, "connections": [[0,1],[1,2],[2,0],[1,3],[3,4]] },
    "description": "Find all critical connections (bridges) in a network.",
    "approach": "1. A critical connection (or bridge) in an undirected connected graph is an edge whose removal would increase the number of connected components in the graph.\n2. These connections are critical in network analysis as they represent single points of failure in a connected system.\n3. The algorithm uses a modified Depth-First Search (DFS) to identify bridges, similar to finding articulation points, using two key concepts:\n   a. Discovery time (tin): The time (or order) in which a node is first visited during DFS.\n   b. Low time (low): The earliest discovery time reachable from a node via its subtree in the DFS traversal.\n4. Implementation details:\n   a. Use arrays to track visited nodes, discovery times, and low times.\n   b. The key insight is that an edge (u, v) is a bridge if and only if there is no back edge from v or any of its descendants to u or any of its ancestors. In other words, if low[v] > tin[u], the edge (u, v) is a bridge.\n5. Algorithm steps:\n   a. Build an adjacency list representation of the graph from the given connections.\n   b. Initialize visited, tin (discovery time), and low arrays. Start a timer at 0.\n   c. For each unvisited vertex, call the DFS function starting with the vertex.\n   d. In the DFS function:\n      i. Mark the current node as visited and set its discovery and low time to the current timer value.\n      ii. For each adjacent node:\n          - If it's the parent, skip it.\n          - If it's not visited, recursively call DFS and update the current node's low time if needed.\n          - After the DFS call, if low[adjacent] > tin[current], the edge (current, adjacent) is a bridge.\n          - If an adjacent node is already visited, update the current node's low time if possible.\n6. Example with n = 5, connections = [[0,1],[1,2],[2,0],[1,3],[3,4]]:\n   - The edge (1,3) is a bridge because its removal disconnects node 3 and 4 from the rest of the graph.\n   - The edge (3,4) is also a bridge for the same reason.\n   - Result: [[1,3],[3,4]]\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph. We perform a single DFS traversal.\n8. Space Complexity: O(V + E) for the adjacency list and various arrays used to track node properties.",
    "code": "public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n    List<Integer>[] adj = new List[n];\n    for (int i = 0; i < n; i++) {\n        adj[i] = new ArrayList<>();\n    }\n    for (List<Integer> connection : connections) {\n        adj[connection.get(0)].add(connection.get(1));\n        adj[connection.get(1)].add(connection.get(0));\n    }\n    boolean[] vis = new boolean[n];\n    int[] tin = new int[n];\n    int[] low = new int[n];\n    int timer = 0;\n    List<List<Integer>> bridges = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        if (!vis[i]) {\n            dfsBridges(i, -1, adj, vis, tin, low, timer, bridges);\n        }\n    }\n    return bridges;\n}\n\nprivate void dfsBridges(int node, int parent, List<Integer>[] adj, boolean[] vis, \n                       int[] tin, int[] low, int timer, List<List<Integer>> bridges) {\n    vis[node] = true;\n    tin[node] = low[node] = timer++;\n    for (int it : adj[node]) {\n        if (it == parent) continue;\n        if (!vis[it]) {\n            dfsBridges(it, node, adj, vis, tin, low, timer, bridges);\n            low[node] = Math.min(low[node], low[it]);\n            if (low[it] > tin[node]) {\n                bridges.add(Arrays.asList(node, it));\n            }\n        } else {\n            low[node] = Math.min(low[node], tin[it]);\n        }\n    }\n}"
  },
  {
    "name": "Kosaraju's Strongly Connected Components",
    "endpoint": "/api/graph/kosaraju",
    "methodName": "kosaraju",
    "serviceFile": "GraphService.java",
    "defaultInput": { "V": 5, "adj": [[1],[2],[0,3],[4],[]] },
    "description": "Find all strongly connected components in a directed graph using Kosaraju's algorithm.",
    "approach": "1. A strongly connected component (SCC) in a directed graph is a subgraph where every vertex is reachable from every other vertex within that subgraph.\n2. Kosaraju's algorithm is a linear time algorithm for finding all SCCs in a directed graph using two depth-first searches.\n3. The algorithm works in three main steps:\n   a. First DFS: Perform a DFS on the original graph and store the vertices in a stack according to their finish times (topological sort-like ordering).\n   b. Transpose the graph: Reverse all edges in the original graph.\n   c. Second DFS: Perform another DFS on the transposed graph, starting with vertices in the order they were stored in the stack.\n4. Implementation details:\n   a. In the first DFS, we push vertices to a stack after visiting all their adjacent vertices (post-order).\n   b. When transposing the graph, we create a new adjacency list where each edge is reversed.\n   c. In the second DFS, we pop vertices from the stack and explore unvisited nodes in the transposed graph. Each DFS traversal forms an SCC.\n5. Algorithm steps:\n   a. Perform a DFS traversal on the original graph. After visiting all neighbors of a vertex, push it onto the stack.\n   b. Create a transposed graph by reversing all edges.\n   c. Perform DFS traversals on the transposed graph, starting with vertices in the order they come off the stack. Each traversal identifies one SCC.\n6. Example with V = 5, adj = [[1],[2],[0,3],[4],[]]:\n   - First DFS gives stack: [4, 3, 0, 2, 1] (from bottom to top)\n   - Transposed graph: adjT[0] = [2], adjT[1] = [0], adjT[2] = [1], adjT[3] = [2], adjT[4] = [3]\n   - Second DFS:\n     * Start with node 1: Component [1, 0, 2]\n     * Start with node 3: Component [3]\n     * Start with node 4: Component [4]\n   - Result: Three SCCs: [1, 0, 2], [3], and [4]\n7. Time Complexity: O(V + E) where V is the number of vertices and E is the number of edges in the graph. We perform two DFS traversals.\n8. Space Complexity: O(V + E) for the stack, visited array, and transposed adjacency list.",
    "code": "public List<List<Integer>> kosaraju(int V, List<Integer>[] adj) {\n    boolean[] vis = new boolean[V];\n    Stack<Integer> st = new Stack<>();\n    for (int i = 0; i < V; i++) {\n        if (!vis[i]) {\n            dfsKosaraju(i, adj, vis, st);\n        }\n    }\n    List<Integer>[] adjT = new List[V];\n    for (int i = 0; i < V; i++) {\n        adjT[i] = new ArrayList<>();\n    }\n    for (int i = 0; i < V; i++) {\n        for (int it : adj[i]) {\n            adjT[it].add(i);\n        }\n    }\n    Arrays.fill(vis, false);\n    List<List<Integer>> scc = new ArrayList<>();\n    while (!st.isEmpty()) {\n        int node = st.pop();\n        if (!vis[node]) {\n            List<Integer> component = new ArrayList<>();\n            dfsKosarajuRev(node, adjT, vis, component);\n            scc.add(component);\n        }\n    }\n    return scc;\n}\n\nprivate void dfsKosaraju(int node, List<Integer>[] adj, boolean[] vis, Stack<Integer> st) {\n    vis[node] = true;\n    \n    for (int it : adj[node]) {\n        if (!vis[it]) {\n            dfsKosaraju(it, adj, vis, st);\n        }\n    }\n    st.push(node);\n}\n\nprivate void dfsKosarajuRev(int node, List<Integer>[] adj, boolean[] vis, List<Integer> component) {\n    vis[node] = true;\n    component.add(node);\n    \n    for (int it : adj[node]) {\n        if (!vis[it]) {\n            dfsKosarajuRev(it, adj, vis, component);\n        }\n    }\n}"
  },
  {
    "name": "Disjoint Set (Union-Find) Operations",
    "endpoint": "/api/graph/disjoint-set",
    "methodName": "disjointSet",
    "serviceFile": "GraphService.java",
    "defaultInput": { "n": 5, "queries": [["union","0","1"],["union","1","2"],["find","0","2"],["find","0","3"]] },
    "description": "Perform union and find operations on a disjoint set (union-find) data structure.",
    "approach": "1. A Disjoint Set (Union-Find) is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.\n2. It provides two main operations:\n   a. Find: Determine which subset a particular element is in. This can be used to determine if two elements are in the same subset.\n   b. Union: Join two subsets into a single subset.\n3. This implementation includes two key optimizations for efficiency:\n   a. Union by Rank: Always attach the smaller tree to the root of the larger tree to minimize the tree height.\n   b. Path Compression: Flatten the tree structure during find operations by making every visited node point directly to the root.\n4. Implementation details:\n   a. Each element starts as a singleton set with itself as the parent.\n   b. The rank array keeps track of the approximate height of the tree rooted at each element.\n   c. Find operations recursively traverse parent pointers until reaching the root, compressing paths along the way.\n   d. Union operations merge two sets based on their ranks to keep the resulting tree balanced.\n5. Algorithm steps:\n   a. Initialize each element as a separate set with itself as the parent and rank 0.\n   b. Process queries:\n      i. For \"union\" queries:\n         - Find the representatives (roots) of the two elements.\n         - If they are already in the same set, do nothing.\n         - Otherwise, attach the tree with lower rank to the root of the tree with higher rank. If ranks are equal, make one the parent and increment its rank.\n      ii. For \"find\" queries:\n         - Check if two elements belong to the same set by comparing their representatives.\n6. Example with n = 5, queries = [[\"union\",\"0\",\"1\"],[\"union\",\"1\",\"2\"],[\"find\",\"0\",\"2\"],[\"find\",\"0\",\"3\"]]:\n   - Initially, each element is in its own set: parent = [0,1,2,3,4], rank = [0,0,0,0,0]\n   - Union(0,1): Merge sets containing 0 and 1. parent = [0,0,2,3,4], rank = [1,0,0,0,0]\n   - Union(1,2): Merge sets containing 1 and 2. Since 1 is in the same set as 0, this effectively merges sets containing 0 and 2. parent = [0,0,0,3,4], rank = [1,0,0,0,0]\n   - Find(0,2): Check if 0 and 2 are in the same set. They are, so return \"Yes\".\n   - Find(0,3): Check if 0 and 3 are in the same set. They are not, so return \"No\".\n7. Time Complexity: O(α(n)) per operation, where α is the inverse Ackermann function, which grows extremely slowly. For all practical purposes, this is effectively constant time.\n8. Space Complexity: O(n) for the parent and rank arrays.",
    "code": "public List<String> disjointSet(int n, List<List<String>> queries) {\n    int[] parent = new int[n];\n    int[] rank = new int[n];\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n    }\n    List<String> result = new ArrayList<>();\n    for (List<String> query : queries) {\n        String operation = query.get(0);\n        if (operation.equals(\"union\")) {\n            int u = Integer.parseInt(query.get(1));\n            int v = Integer.parseInt(query.get(2));\n            union(u, v, parent, rank);\n            result.add(\"Union performed\");\n        } else if (operation.equals(\"find\")) {\n            int u = Integer.parseInt(query.get(1));\n            int v = Integer.parseInt(query.get(2));\n            boolean sameSet = findPar(u, parent) == findPar(v, parent);\n            result.add(sameSet ? \"Yes\" : \"No\");\n        }\n    }\n    return result;\n}\n\nprivate int findPar(int u, int[] parent) {\n    if (u == parent[u]) return u;\n    return parent[u] = findPar(parent[u], parent);\n}\n\nprivate void union(int u, int v, int[] parent, int[] rank) {\n    u = findPar(u, parent);\n    v = findPar(v, parent);\n    \n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    } else if (rank[v] < rank[u]) {\n        parent[v] = u;\n    } else {\n        parent[v] = u;\n        rank[u]++;\n    }\n}"
  }
]