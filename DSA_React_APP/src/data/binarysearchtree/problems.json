[
  {
    "name": "BST from Preorder",
    "endpoint": "/api/bst/bst-from-preorder",
    "methodName": "bstFromPreorder",
    "serviceFile": "BSTService.java",
    "defaultInput": { "preorder": [8, 5, 1, 7, 10, 12] },
    "description": "Construct a BST from its preorder traversal.",
    "approach": "1. The approach uses the property that in a preorder traversal, the first element is always the root.\n2. For each element in the preorder array, we determine if it should be added to the current subtree based on a bound value.\n3. We use a helper function that takes the preorder array, an upper bound, and a mutable index.\n4. If the current value exceeds the bound or we've used all elements, return null.\n5. Otherwise, create a node with the current value, increment the index, and recursively build left and right subtrees.\n6. For left children, the bound is the parent's value (since all left nodes must be smaller).\n7. For right children, we use the parent's bound (ensuring right subtree values are less than ancestors).\n8. The recursive process naturally builds the entire BST following BST properties.",
    "code": "public BSTResponse.TreeNodeDTO bstFromPreorder(List<Integer> preorder) {\n    TreeNode root = bstFromPreorderHelper(preorder, Integer.MAX_VALUE, new int[]{0});\n    return toDTO(root);\n}\n\nprivate TreeNode bstFromPreorderHelper(List<Integer> preorder, int bound, int[] index) {\n    if (index[0] == preorder.size() || preorder.get(index[0]) > bound) return null;\n    TreeNode root = new TreeNode(preorder.get(index[0]++));\n    root.left = bstFromPreorderHelper(preorder, root.data, index);\n    root.right = bstFromPreorderHelper(preorder, bound, index);\n    return root;\n}\n\nprivate BSTResponse.TreeNodeDTO toDTO(TreeNode node) {\n    if (node == null) return null;\n    BSTResponse.TreeNodeDTO dto = new BSTResponse.TreeNodeDTO(node.data);\n    dto.setLeft(toDTO(node.left));\n    dto.setRight(toDTO(node.right));\n    return dto;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "BST Iterator Inorder",
    "endpoint": "/api/bst/bst-iterator-inorder",
    "methodName": "bstIteratorInorder",
    "serviceFile": "BSTService.java",
    "defaultInput": { "preorder": [8, 5, 1, 7, 10, 12] },
    "description": "Return the inorder traversal of a BST constructed from preorder.",
    "approach": "1. First, construct the BST from the given preorder traversal array using the bstFromPreorderHelper method.\n2. This helper function follows the same approach as in the BST from Preorder problem, using bounds to determine where each node goes.\n3. Create an empty result list to store the inorder traversal elements.\n4. Perform an inorder traversal of the constructed BST using recursion:\n   a. Recursively traverse the left subtree\n   b. Visit the current node and add its value to the result list\n   c. Recursively traverse the right subtree\n5. The inorder traversal of a BST naturally produces elements in ascending order, which is a key property of BSTs.\n6. Return the final inorder traversal list with all elements sorted in ascending order.",
    "code": "public List<Integer> bstIteratorInorder(List<Integer> preorder) {\n    TreeNode root = bstFromPreorderHelper(preorder, Integer.MAX_VALUE, new int[]{0});\n    List<Integer> inorder = new java.util.ArrayList<>();\n    inorderTraversal(root, inorder);\n    return inorder;\n}\n\nprivate TreeNode bstFromPreorderHelper(List<Integer> preorder, int bound, int[] index) {\n    if (index[0] == preorder.size() || preorder.get(index[0]) > bound) return null;\n    TreeNode root = new TreeNode(preorder.get(index[0]++));\n    root.left = bstFromPreorderHelper(preorder, root.data, index);\n    root.right = bstFromPreorderHelper(preorder, bound, index);\n    return root;\n}\n\nprivate void inorderTraversal(TreeNode node, List<Integer> res) {\n    if (node == null) return;\n    inorderTraversal(node.left, res);\n    res.add(node.data);\n    inorderTraversal(node.right, res);\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Delete Node in BST",
    "endpoint": "/api/bst/delete-node",
    "methodName": "deleteNode",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 5, "left": { "data": 3 }, "right": { "data": 6 } }, "key": 3 },
    "description": "Delete a node with a given key from the BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Search for the node with the given key by traversing the BST based on key comparison.\n3. Once the target node is found, handle three possible cases:\n   a. If the node has no left child, replace it with its right child.\n   b. If the node has no right child, replace it with its left child.\n   c. If the node has both children, find the leftmost node in the right subtree (inorder successor).\n4. For case (c), connect the left subtree of the deleted node to the leftmost node of the right subtree.\n5. Replace the deleted node with its right subtree, effectively removing it from the BST while maintaining the BST property.\n6. Special handling for the root node: if the root is the node to be deleted, apply the connector function directly.\n7. Convert the modified BST back to DTO representation and return it.\n8. This approach maintains the BST property where all left children are smaller and all right children are larger than their parent.",
    "code": "public BSTResponse.TreeNodeDTO deleteNode(BSTResponse.TreeNodeDTO rootDto, int key) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode newRoot = deleteNodeInternal(root, key);\n    return toDTO(newRoot);\n}\n\nprivate TreeNode deleteNodeInternal(TreeNode root, int key) {\n    if (root == null) return null;\n    if (root.data == key) {\n        return connector(root);\n    }\n    TreeNode node = root;\n    while (node != null) {\n        if (node.data > key) {\n            if (node.left != null && node.left.data == key) {\n                node.left = connector(node.left);\n                break;\n            } else {\n                node = node.left;\n            }\n        } else {\n            if (node.right != null && node.right.data == key) {\n                node.right = connector(node.right);\n                break;\n            } else {\n                node = node.right;\n            }\n        }\n    }\n    return root;\n}\n\nprivate TreeNode connector(TreeNode root) {\n    if (root.left == null) return root.right;\n    if (root.right == null) return root.left;\n    TreeNode leftChild = root.left;\n    TreeNode leftmostChildInRightSubtree = root.right;\n    while (leftmostChildInRightSubtree.left != null) {\n        leftmostChildInRightSubtree = leftmostChildInRightSubtree.left;\n    }\n    leftmostChildInRightSubtree.left = leftChild;\n    return root.right;\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Floor and Ceil of BST",
    "endpoint": "/api/bst/floor-ceil",
    "methodName": "floorCeilOfBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 8, "left": { "data": 4 }, "right": { "data": 12 } }, "key": 10 },
    "description": "Find the floor and ceil of a given key in a BST.",
    "approach": "1. The approach involves two separate traversals of the BST to find the floor and ceiling values.\n2. For finding the floor (largest value ≤ key):\n   a. Initialize floor as -1 (to handle case when no floor exists).\n   b. Start from the root and traverse the tree.\n   c. If the current node's value equals the key, that's the floor value.\n   d. If current node's value is less than key, update floor and move right.\n   e. If current node's value is greater than key, move left without updating floor.\n3. For finding the ceil (smallest value ≥ key):\n   a. Initialize ceil as -1 (to handle case when no ceil exists).\n   b. Start from the root and traverse the tree again.\n   c. If the current node's value equals the key, that's the ceil value.\n   d. If current node's value is greater than key, update ceil and move left.\n   e. If current node's value is less than key, move right without updating ceil.\n4. Return both floor and ceil values as a list.\n5. This approach leverages the BST property to efficiently find these values without visiting all nodes.",
    "code": "public List<Integer> floorCeilOfBST(BSTResponse.TreeNodeDTO rootDto, int key) {\n    TreeNode root = fromDTO(rootDto);\n    int floor = -1, ceil = -1;\n    TreeNode current = root;\n    while (current != null) {\n        if (current.data == key) {\n            floor = current.data;\n            break;\n        } else if (current.data < key) {\n            floor = current.data;\n            current = current.right;\n        } else {\n            current = current.left;\n        }\n    }\n    current = root;\n    while (current != null) {\n        if (current.data == key) {\n            ceil = current.data;\n            break;\n        } else if (current.data > key) {\n            ceil = current.data;\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return java.util.Arrays.asList(floor, ceil);\n}"
  },
  {
    "name": "Insert into BST",
    "endpoint": "/api/bst/insert-into-bst",
    "methodName": "insertIntoBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 4, "left": { "data": 2 }, "right": { "data": 7 } }, "val": 5 },
    "description": "Insert a value into the BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Handle the edge case: If the root is null, create a new node with the given value and return it.\n3. Use an iterative approach to find the correct insertion position:\n   a. Start from the root node.\n   b. Compare the insertion value with the current node's value.\n   c. If the insertion value is less than the current node's value:\n      i. If the left child is null, create a new node and assign it as the left child.\n      ii. Otherwise, move to the left child and continue the search.\n   d. If the insertion value is greater than or equal to the current node's value:\n      i. If the right child is null, create a new node and assign it as the right child.\n      ii. Otherwise, move to the right child and continue the search.\n4. The iterative process continues until we find a null position where we can insert the new node.\n5. Convert the modified BST back to DTO representation and return it.\n6. This approach maintains the BST property where all values in the left subtree are less than the node and all values in the right subtree are greater than or equal to the node.",
    "code": "public BSTResponse.TreeNodeDTO insertIntoBST(BSTResponse.TreeNodeDTO rootDto, int val) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode newRoot = insertIntoBSTInternal(root, val);\n    return toDTO(newRoot);\n}\n\nprivate TreeNode insertIntoBSTInternal(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n    TreeNode current = root;\n    while (true) {\n        if (val < current.data) {\n            if (current.left == null) {\n                current.left = new TreeNode(val);\n                break;\n            } else {\n                current = current.left;\n            }\n        } else {\n            if (current.right == null) {\n                current.right = new TreeNode(val);\n                break;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n    return root;\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate BSTResponse.TreeNodeDTO toDTO(TreeNode node) {\n    if (node == null) return null;\n    BSTResponse.TreeNodeDTO dto = new BSTResponse.TreeNodeDTO(node.data);\n    dto.setLeft(toDTO(node.left));\n    dto.setRight(toDTO(node.right));\n    return dto;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Check if BST",
    "endpoint": "/api/bst/is-bst",
    "methodName": "isBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 2, "left": { "data": 1 }, "right": { "data": 3 } } },
    "description": "Check if a binary tree is a valid BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use a recursive validation approach with range constraints:\n   a. Initialize the valid range for the root node: (MIN_VALUE, MAX_VALUE).\n   b. For each node, check if its value is within the valid range for that position.\n   c. For the left subtree, update the upper bound to the current node's value (all left descendants must be less than the current node).\n   d. For the right subtree, update the lower bound to the current node's value (all right descendants must be greater than the current node).\n   e. If any node's value falls outside its valid range, return false.\n3. Base case: null nodes are considered valid BSTs.\n4. The recursive check ensures that every node in the tree follows the BST property:\n   a. All values in the left subtree are strictly less than the node's value.\n   b. All values in the right subtree are strictly greater than the node's value.\n   c. Both left and right subtrees must also be valid BSTs.\n5. Return true if all nodes satisfy their respective range constraints.",
    "code": "public boolean isBST(BSTResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    return validateBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n}\n\nprivate boolean validateBST(TreeNode node, int min, int max) {\n    if (node == null) return true;\n    if (node.data <= min || node.data >= max) return false;\n    return validateBST(node.left, min, node.data) && validateBST(node.right, node.data, max);\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Kth Smallest and Largest in BST",
    "endpoint": "/api/bst/kth-smallest-largest",
    "methodName": "kthSmallestLargest",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 5, "left": { "data": 3 }, "right": { "data": 6 } }, "k": 2 },
    "description": "Find the kth smallest and kth largest elements in the BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use the property that the inorder traversal of a BST gives elements in ascending order.\n3. For finding the kth smallest element:\n   a. Perform an inorder traversal (left-root-right).\n   b. Use a counter that decrements with each node visited.\n   c. When the counter reaches zero, we've found the kth smallest element.\n   d. Store this value in a result array and return early from that subtree.\n4. For finding the kth largest element:\n   a. Perform a reverse inorder traversal (right-root-left).\n   b. Use a similar counter approach as for the kth smallest.\n   c. When the counter reaches zero, we've found the kth largest element.\n   d. Store this value in a result array and return early from that subtree.\n5. Return both the kth smallest and kth largest values as a list.\n6. This approach leverages the BST property to efficiently find these values without sorting or storing the entire traversal.",
    "code": "public List<Integer> kthSmallestLargest(BSTResponse.TreeNodeDTO rootDto, int k) {\n    TreeNode root = fromDTO(rootDto);\n    return java.util.Arrays.asList(kthSmallest(root, k), kthLargest(root, k));\n}\n\nprivate int kthSmallest(TreeNode root, int k) {\n    int[] count = {k};\n    int[] result = {-1};\n    inorderKth(root, count, result);\n    return result[0];\n}\n\nprivate void inorderKth(TreeNode node, int[] count, int[] result) {\n    if (node == null) return;\n    inorderKth(node.left, count, result);\n    if (--count[0] == 0) {\n        result[0] = node.data;\n        return;\n    }\n    inorderKth(node.right, count, result);\n}\n\nprivate int kthLargest(TreeNode root, int k) {\n    int[] count = {k};\n    int[] result = {-1};\n    reverseInorderKth(root, count, result);\n    return result[0];\n}\n\nprivate void reverseInorderKth(TreeNode node, int[] count, int[] result) {\n    if (node == null) return;\n    reverseInorderKth(node.right, count, result);\n    if (--count[0] == 0) {\n        result[0] = node.data;\n        return;\n    }\n    reverseInorderKth(node.left, count, result);\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Largest BST Subtree",
    "endpoint": "/api/bst/largest-bst",
    "methodName": "largestBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 10, "left": { "data": 5 }, "right": { "data": 15 } } },
    "description": "Find the size of the largest BST subtree in a binary tree.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use a post-order traversal approach (process left and right children before the current node).\n3. Define a helper NodeValue class to track three values for each subtree:\n   a. minNode: Minimum value in the subtree.\n   b. maxNode: Maximum value in the subtree.\n   c. maxSize: Size of the largest BST in the subtree.\n4. For each node in the post-order traversal:\n   a. Recursively process the left and right subtrees to get their NodeValues.\n   b. Check if the current subtree forms a valid BST:\n      i. The max value in the left subtree must be less than the current node.\n      ii. The min value in the right subtree must be greater than the current node.\n      iii. Both left and right subtrees must themselves be valid BSTs.\n   c. If the subtree is a valid BST:\n      i. Update minNode as the minimum of current node value and left subtree's minimum.\n      ii. Update maxNode as the maximum of current node value and right subtree's maximum.\n      iii. Update maxSize as the sum of left subtree size, right subtree size, and 1 (for the current node).\n   d. If the subtree is not a valid BST:\n      i. Set invalid min/max indicators (MIN_VALUE, MAX_VALUE).\n      ii. maxSize is the maximum of left and right subtrees' maxSize.\n5. Base case: A null node returns {MAX_VALUE, MIN_VALUE, 0} indicating an empty but valid BST.\n6. Return the maxSize of the root, which represents the size of the largest BST in the tree.\n7. This approach has O(n) time complexity as each node is processed once.",
    "code": "public int largestBST(BSTResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    return largestBSTSubtreeHelper(root).maxSize;\n}\n\nprivate static class NodeValue {\n    int minNode, maxNode, maxSize;\n    NodeValue(int minNode, int maxNode, int maxSize) {\n        this.minNode = minNode;\n        this.maxNode = maxNode;\n        this.maxSize = maxSize;\n    }\n}\n\nprivate NodeValue largestBSTSubtreeHelper(TreeNode node) {\n    if (node == null) {\n        return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\n    }\n    NodeValue left = largestBSTSubtreeHelper(node.left);\n    NodeValue right = largestBSTSubtreeHelper(node.right);\n    if (left.maxNode < node.data && node.data < right.minNode) {\n        return new NodeValue(\n            Math.min(node.data, left.minNode),\n            Math.max(node.data, right.maxNode),\n            left.maxSize + right.maxSize + 1\n        );\n    }\n    return new NodeValue(Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(left.maxSize, right.maxSize));\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Search in BST",
    "endpoint": "/api/bst/search-bst",
    "methodName": "searchBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 4, "left": { "data": 2 }, "right": { "data": 7 } }, "val": 2 },
    "description": "Search for a value in the BST and return the subtree rooted at that value.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use an iterative approach for searching in the BST:\n   a. Start from the root node.\n   b. While the current node is not null and its value doesn't match the search value:\n      i. If the search value is less than the current node's value, move to the left child.\n      ii. If the search value is greater than the current node's value, move to the right child.\n   c. The loop continues until either the value is found or a null node is reached.\n3. If the search value is found, return the subtree rooted at that node.\n4. If the search value is not found (reached a null node), return null.\n5. Convert the result back to DTO representation before returning.\n6. This approach leverages the BST property where all left children are smaller and all right children are larger than their parent, allowing for efficient searching with O(h) time complexity, where h is the height of the tree.",
    "code": "public BSTResponse.TreeNodeDTO searchBST(BSTResponse.TreeNodeDTO rootDto, int val) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode result = searchBSTInternal(root, val);\n    return toDTO(result);\n}\n\nprivate TreeNode searchBSTInternal(TreeNode root, int val) {\n    while (root != null && root.data != val) {\n        root = (root.data > val) ? root.left : root.right;\n    }\n    return root;\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate BSTResponse.TreeNodeDTO toDTO(TreeNode node) {\n    if (node == null) return null;\n    BSTResponse.TreeNodeDTO dto = new BSTResponse.TreeNodeDTO(node.data);\n    dto.setLeft(toDTO(node.left));\n    dto.setRight(toDTO(node.right));\n    return dto;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Successor and Predecessor in BST",
    "endpoint": "/api/bst/succ-pred-bst",
    "methodName": "succPredBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 8, "left": { "data": 4 }, "right": { "data": 12 } }, "key": 10 },
    "description": "Find the in-order predecessor and successor of a given key in the BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Initialize predecessor as -1 and successor as MAX_VALUE (to handle cases where they don't exist).\n3. Use a recursive approach to traverse the BST:\n   a. If the current node is null, return.\n   b. If the current node's value is less than the key:\n      i. Update the predecessor to the maximum of current predecessor and node's value.\n      ii. Recursively search in the right subtree (as we need to find the largest value smaller than key).\n   c. If the current node's value is greater than the key:\n      i. Update the successor to the minimum of current successor and node's value.\n      ii. Recursively search in the left subtree (as we need to find the smallest value larger than key).\n   d. If the current node's value equals the key, we have special handling:\n      i. For predecessor: Find the rightmost node in the left subtree.\n      ii. For successor: Find the leftmost node in the right subtree.\n4. After the traversal, check if successor equals MAX_VALUE and convert it to -1 if true.\n5. Return both predecessor and successor as a list.\n6. This approach efficiently finds both values in a single traversal of the BST, with worst-case time complexity O(h), where h is the height of the tree.",
    "code": "public List<Integer> succPredBST(BSTResponse.TreeNodeDTO rootDto, int key) {\n    TreeNode root = fromDTO(rootDto);\n    int[] predecessor = {-1};\n    int[] successor = {Integer.MAX_VALUE};\n    traverseSuccPred(root, key, predecessor, successor);\n    return java.util.Arrays.asList(\n        predecessor[0] == -1 ? -1 : predecessor[0], \n        successor[0] == Integer.MAX_VALUE ? -1 : successor[0]\n    );\n}\n\nprivate void traverseSuccPred(TreeNode node, int key, int[] predecessor, int[] successor) {\n    if (node == null) return;\n    \n    if (node.data < key) {\n        predecessor[0] = Math.max(predecessor[0], node.data);\n        traverseSuccPred(node.right, key, predecessor, successor);\n    } else if (node.data > key) {\n        successor[0] = Math.min(successor[0], node.data);\n        traverseSuccPred(node.left, key, predecessor, successor);\n    } else {\n        if (node.left != null) {\n            TreeNode temp = node.left;\n            while (temp.right != null) {\n                temp = temp.right;\n            }\n            predecessor[0] = temp.data;\n        }\n        \n        if (node.right != null) {\n            TreeNode temp = node.right;\n            while (temp.left != null) {\n                temp = temp.left;\n            }\n            successor[0] = temp.data;\n        }\n    }\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Two Sum in BST",
    "endpoint": "/api/bst/two-sum-bst",
    "methodName": "twoSumBST",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 5, "left": { "data": 3 }, "right": { "data": 6 } }, "k": 9 },
    "description": "Check if there exist two elements in the BST such that their sum is equal to k.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use a two-pointer technique with specialized iterators for BST traversal:\n   a. Create two stacks: one for traversing the tree in ascending order (inorder) and one for traversing in descending order (reverse inorder).\n   b. Initialize the stacks by pushing all leftmost nodes for the inorder stack and all rightmost nodes for the reverse inorder stack.\n3. Use helper methods to get the next smallest element (from leftStack) and the next largest element (from rightStack).\n4. Simulate two pointers moving from opposite ends of the sorted array:\n   a. Get one node from each stack to have the current smallest and largest values.\n   b. While the smallest value is less than the largest value (to avoid using the same node twice):\n      i. Calculate the sum of their values.\n      ii. If the sum equals the target, return true.\n      iii. If the sum is less than the target, move to the next larger element in the ascending order.\n      iv. If the sum is greater than the target, move to the next smaller element in the descending order.\n5. Return false if no such pair is found.\n6. This approach is efficient with O(n) time complexity and O(h) space complexity, where h is the height of the BST.",
    "code": "public boolean twoSumBST(BSTResponse.TreeNodeDTO rootDto, int k) {\n    TreeNode root = fromDTO(rootDto);\n    if (root == null) return false;\n    java.util.Stack<TreeNode> leftStack = new java.util.Stack<>();\n    java.util.Stack<TreeNode> rightStack = new java.util.Stack<>();\n    pushAllLeft(root, leftStack);\n    pushAllRight(root, rightStack);\n    TreeNode left = getNextLeft(leftStack);\n    TreeNode right = getNextRight(rightStack);\n    while (left != null && right != null && left.data < right.data) {\n        int sum = left.data + right.data;\n        if (sum == k) return true;\n        else if (sum < k) left = getNextLeft(leftStack);\n        else right = getNextRight(rightStack);\n    }\n    return false;\n}"
  },
  {
    "name": "Lowest Common Ancestor in BST",
    "endpoint": "/api/bst/lca",
    "methodName": "lca",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 6, "left": { "data": 2 }, "right": { "data": 8 } }, "p": 2, "q": 8 },
    "description": "Find the lowest common ancestor (LCA) of two nodes in the BST.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. Use a recursive approach to find the lowest common ancestor (LCA):\n   a. Base case: If the current node is null or matches either p or q, return the current node.\n   b. Recursively search for p and q in the left subtree.\n   c. Recursively search for p and q in the right subtree.\n   d. If both left and right recursive calls return non-null values, it means p and q are in different subtrees, so the current node is the LCA.\n   e. If only one of the recursive calls returns non-null, return that result up the recursion tree.\n3. Note: This implementation actually uses the general binary tree LCA algorithm, but could be optimized for BSTs by using the property that p and q's positions relative to a node can be determined by value comparison.\n4. A BST-specific optimization would check if both p and q are less than the current node (search left subtree), greater than the current node (search right subtree), or on different sides (current node is LCA).\n5. The function returns the value of the LCA node or -1 if no LCA is found.\n6. The time complexity is O(h) where h is the height of the BST.",
    "code": "public int lca(BSTResponse.TreeNodeDTO rootDto, int p, int q) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode result = lcaInternal(root, p, q);\n    return result != null ? result.data : -1;\n}\n\nprivate TreeNode lcaInternal(TreeNode root, int p, int q) {\n    if (root == null || root.data == p || root.data == q) {\n        return root;\n    }\n    \n    TreeNode left = lcaInternal(root.left, p, q);\n    TreeNode right = lcaInternal(root.right, p, q);\n    \n    if (left != null && right != null) {\n        return root;\n    }\n    \n    return left != null ? left : right;\n}\n\nprivate TreeNode fromDTO(BSTResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Recover BST",
    "endpoint": "/api/bst/recover-tree",
    "methodName": "recoverTree",
    "serviceFile": "BSTService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 3, "right": { "data": 2 } } } },
    "description": "Recover a BST where two nodes are swapped by mistake.",
    "approach": "1. Convert the input DTO to an internal TreeNode representation.\n2. The key insight is that an inorder traversal of a valid BST produces elements in sorted (ascending) order.\n3. When two nodes are swapped, there will be anomalies in this sorted sequence.\n4. Use an inorder traversal to identify the swapped nodes:\n   a. Track four key nodes: first, middle, last, and previous.\n   b. The previous node helps compare adjacent nodes during traversal.\n   c. During inorder traversal, if current node's value is less than previous node's value (violation of BST property):\n      i. If this is the first violation: mark previous node as first and current node as middle.\n      ii. If this is the second violation: mark current node as last.\n5. After traversal, there are two possible scenarios:\n   a. If both first and last nodes are identified (two separate violations), swap their values.\n   b. If only first and middle nodes are identified (adjacent nodes were swapped), swap their values.\n6. Convert the corrected BST back to DTO representation and return it.\n7. This approach has O(n) time complexity and O(h) space complexity (from the recursion stack), where h is the height of the BST.",
    "code": "public BSTResponse.TreeNodeDTO recoverTree(BSTResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode[] first = {null};\n    TreeNode[] middle = {null};\n    TreeNode[] last = {null};\n    TreeNode[] prev = {null};\n    inorderRecover(root, first, middle, last, prev);\n    if (first[0] != null && last[0] != null) {\n        int temp = first[0].data;\n        first[0].data = last[0].data;\n        last[0].data = temp;\n    } else if (first[0] != null && middle[0] != null) {\n        int temp = first[0].data;\n        first[0].data = middle[0].data;\n        middle[0].data = temp;\n    }\n    return toDTO(root);\n}"
  }
]