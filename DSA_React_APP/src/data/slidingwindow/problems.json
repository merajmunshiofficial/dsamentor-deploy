[
  {
    "name": "Longest Repeating Character Replacement",
    "endpoint": "/api/sliding-window/character-replacement",
    "methodName": "characterReplacement",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "s": "ABAB", "k": 2 },
    "description": "Find the length of the longest substring containing the same letter you can get after performing at most k character replacements. You can replace any character in the string with any other character. Example: In string 'ABAB' with k = 2, we can replace 2 characters to get the longest substring with the same letter. We can replace the two 'B's with 'A's to get 'AAAA', which has length 4. Alternatively, we could replace the two 'A's with 'B's to also get a length of 4 ('BBBB'). The key insight is that for any window of length L, we need to have at least (L - k) characters of the same type for it to be valid after k replacements. The calculation involves finding the window with the maximum frequency of any character, where (window_length - max_frequency) ≤ k.",
    "approach": "1. This problem uses the sliding window technique with a frequency counter to find the longest substring where we can make at most k character replacements.\n2. Key insight: For a valid window, (window_length - count_of_most_frequent_character) ≤ k, meaning we can replace at most k characters to make all characters the same.\n3. Steps of the algorithm:\n   a. Maintain a window with left (l) and right (r) pointers.\n   b. Use a frequency array to keep track of character counts in the current window.\n   c. Keep track of the maximum frequency of any character in the current window.\n   d. For each position of the right pointer:\n      - Update the frequency of the current character.\n      - Update the maximum frequency if needed.\n      - If (window_length - max_frequency) > k, shrink the window from the left.\n      - Update the maximum window length seen so far.\n4. The clever part: We don't decrement maxFreq when the window shrinks. This might seem counterintuitive, but it works because:\n   - If the character being removed was the most frequent, the window will shrink until a new valid window is found.\n   - If it wasn't the most frequent, then maxFreq remains correct.\n5. Time Complexity: O(n) where n is the length of the string.\n6. Space Complexity: O(1) since we use a fixed-size array of 26 characters.",
    "code": "public int characterReplacement(String s, int k) {\n    int maxLen = 0;\n    int maxFreq = 0;\n    int l = 0, r = 0;\n    int[] hash = new int[26];\n    while (r < s.length()) {\n        hash[s.charAt(r) - 'A']++;\n        maxFreq = Math.max(maxFreq, hash[s.charAt(r) - 'A']);\n        if ((r - l + 1) - maxFreq > k) {\n            hash[s.charAt(l) - 'A']--;\n            l++;\n        }\n        maxLen = Math.max(maxLen, r - l + 1);\n        r++;\n    }\n    return maxLen;\n}"
  },
  {
    "name": "Longest Substring with K Distinct Characters",
    "endpoint": "/api/sliding-window/k-distinct-char",
    "methodName": "kDistinctChar",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "s": "araaci", "k": 2 },
    "description": "Find the length of the longest substring that contains at most k distinct characters. Example: In the string 'araaci' with k = 2, the longest substring with at most 2 distinct characters is 'araa', which has length 4. This substring contains only the characters 'a' and 'r'. Another valid substring would be 'aaci', which also has 2 distinct characters ('a' and 'c') but is shorter with length 4. The sliding window approach maintains a window that always has at most k distinct characters, expanding when possible and contracting when necessary by tracking character frequencies in a map.",
    "approach": "1. This problem uses the sliding window technique with a hashmap to find the longest substring with at most k distinct characters.\n2. Steps of the algorithm:\n   a. Initialize a HashMap to store character frequencies and two pointers (l and r) for the window.\n   b. Expand the window by moving the right pointer and adding characters to the HashMap.\n   c. If the number of distinct characters (HashMap size) exceeds k:\n      - Shrink the window from the left by decrementing the frequency of the left character.\n      - Remove characters from the HashMap if their frequency becomes 0.\n      - Move the left pointer to the right.\n   d. If the HashMap size is at most k, update the maximum length.\n3. The window invariant: At each step, the window contains at most k distinct characters.\n4. This approach efficiently handles all types of characters (not just lowercase English letters).\n5. Time Complexity: O(n) where n is the length of the string.\n   - Each character is added to the window once and removed at most once.\n6. Space Complexity: O(min(k, n)) for the HashMap storing at most k distinct characters.",
    "code": "public int kDistinctChar(String s, int k) {\n    int n = s.length();\n    int maxLen = 0;\n    HashMap<Character, Integer> mpp = new HashMap<>();\n    int l = 0, r = 0;\n    while(r < n){\n        char charR = s.charAt(r);\n        mpp.put(charR, mpp.getOrDefault(charR, 0) + 1);\n        if(mpp.size() > k){\n            char charL = s.charAt(l);\n            mpp.put(charL, mpp.get(charL) - 1);\n            if(mpp.get(charL) == 0){\n                mpp.remove(charL);\n            }\n            l++;\n        }\n        if(mpp.size() <= k){\n            maxLen = Math.max(maxLen, r - l + 1);\n        }\n        r++;\n    }\n    return maxLen;\n}"
  },
  {
    "name": "Longest Substring Without Repeating Characters",
    "endpoint": "/api/sliding-window/longest-non-repeating-substring",
    "methodName": "longestNonRepeatingSubstring",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "s": "abcabcbb" },
    "description": "Find the length of the longest substring that contains no repeating characters. Example: In the string 'abcabcbb', the longest substring without repeating characters is 'abc', which has a length of 3. Another example is 'pwwkew', where the answer is 'wke' with length 3. Note that the answer must be a substring, not a subsequence, so 'pwke' is not a valid answer because it skips characters. The solution uses a sliding window technique with an array to track the most recent position of each character, allowing the window to efficiently 'jump' when encountering a repeated character instead of starting over.",
    "approach": "1. This problem uses the sliding window technique with an array to track the last seen positions of characters.\n2. Steps of the algorithm:\n   a. Initialize an array 'hash' of size 256 (to cover all ASCII characters) with values -1, indicating no character has been seen yet.\n   b. Use two pointers: left (l) and right (r) to define the current window.\n   c. For each position of the right pointer:\n      - If the current character has been seen before (hash[char] != -1), update the left pointer to max(l, lastSeenIndex + 1).\n        This effectively jumps over the previous occurrence of the character.\n      - Update the maximum length of the non-repeating substring found so far.\n      - Update the last seen position of the current character in the hash array.\n3. The key insight: When encountering a repeated character, we don't need to start over; we can jump the left pointer to just after the previous occurrence.\n4. The use of Math.max(hash[s.charAt(r)] + 1, l) ensures we don't move the left pointer backward if we've already moved past the previous occurrence.\n5. Time Complexity: O(n) where n is the length of the string.\n6. Space Complexity: O(1) since we use a fixed-size array of 256 characters.",
    "code": "public int longestNonRepeatingSubstring(String s) {\n    int n = s.length();\n    int HashLen = 256;\n    int[] hash = new int[HashLen];\n    Arrays.fill(hash, -1);\n    int l = 0, r = 0, maxLen = 0;\n    while (r < n) {\n        if (hash[s.charAt(r)] != -1) {\n            l = Math.max(hash[s.charAt(r)] + 1, l);\n        }\n        int len = r - l + 1;\n        maxLen = Math.max(len, maxLen);\n        hash[s.charAt(r)] = r;\n        r++;\n    }\n    return maxLen;\n}"
  },
  {
    "name": "Max Consecutive Ones III",
    "endpoint": "/api/sliding-window/longest-ones",
    "methodName": "longestOnes",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "nums": [1,1,1,0,0,0,1,1,1,1,0], "k": 2 },
    "description": "Find the length of the longest subarray with at most k zeros that can be flipped to ones. You can flip at most k zeros to convert them to ones. Example: In the array [1,1,1,0,0,0,1,1,1,1,0] with k = 2, the longest subarray would be [1,1,1,0,0,1,1,1,1] (flipping the two 0's in positions 3 and 4), which has a length of 9. If k = 3, we could flip all three 0's to get a continuous array of 1's with length 10. The solution uses a sliding window that maintains at most k zeros, expanding when possible and contracting when the number of zeros exceeds k.",
    "approach": "1. This problem uses the sliding window technique to find the longest subarray with at most k zeros (which can be flipped to ones).\n2. Steps of the algorithm:\n   a. Initialize two pointers, l and r, to define the current window, and a counter 'zeros' to track the number of zeros in the window.\n   b. Expand the window by moving the right pointer:\n      - If the current element is 0, increment the zeros counter.\n   c. If the number of zeros exceeds k:\n      - Shrink the window from the left.\n      - If the element being removed is 0, decrement the zeros counter.\n      - Move the left pointer to the right.\n   d. If the window has at most k zeros, update the maximum length.\n3. The window invariant: At each step, the window contains at most k zeros (which can be flipped).\n4. This approach effectively finds the longest sequence of 1s after flipping at most k 0s.\n5. Time Complexity: O(n) where n is the length of the array.\n   - Each element is processed at most twice (once when entering through the right pointer, once when exiting through the left pointer).\n6. Space Complexity: O(1) as we only use a fixed number of variables regardless of input size.",
    "code": "public int longestOnes(int[] nums, int k) {\n    int n = nums.length;\n    int l = 0, r = 0;\n    int zeros = 0, maxLen = 0;\n    while (r < n) {\n        if(nums[r] == 0) zeros++;\n        if (zeros > k) {\n            if (nums[l] == 0) {\n                zeros--;\n            }\n            l++;\n        }\n        if(zeros <= k){\n            int len = r - l + 1;\n            maxLen = Math.max(maxLen, len);\n        }\n        r++;\n    }\n    return maxLen;\n}"
  },
  {
    "name": "Maximum Points You Can Obtain from Cards",
    "endpoint": "/api/sliding-window/max-score",
    "methodName": "maxScore",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "cardPoints": [1,2,3,4,5,6,1], "k": 3 },
    "description": "Find the maximum score you can obtain by picking exactly k cards from either the beginning or the end of the array. You can take cards in any order, but you must always take from the very left or the very right of the remaining cards. Example: With card points [1,2,3,4,5,6,1] and k = 3, there are multiple ways to pick: taking all 3 from the beginning [1,2,3] scores 6; taking all 3 from the end [6,1,1] scores 8; taking 2 from beginning and 1 from end [1,2,6] scores 9; taking 1 from beginning and 2 from end [1,6,1] scores 8. The maximum score is 9. The solution cleverly tries all combinations by starting with k cards from one end and progressively taking i cards from left and (k-i) cards from right.",
    "approach": "1. This problem asks us to find the maximum score by taking exactly k cards from either the beginning or end of the array.\n2. Key insight: Taking k cards means we're excluding a continuous segment of (n-k) cards from the middle. Thus, we can reframe this as finding the minimum sum subarray of length (n-k).\n3. The implementation uses a different but equivalent approach:\n   a. First, calculate the sum of the first k cards from the left end (lSum) as our initial maximum score.\n   b. Then, iteratively:\n      - Remove one card from the left end (decrement lSum).\n      - Add one card from the right end (increment rSum).\n      - Check if this new combination (some cards from left + some from right) gives a higher score.\n   c. After trying all possible combinations of taking i cards from left and (k-i) cards from right, return the maximum score found.\n4. Time Complexity: O(k) where k is the number of cards we can take.\n   - We do exactly k iterations of removing from left and adding from right.\n5. Space Complexity: O(1) as we only use a fixed number of variables.",
    "code": "public int maxScore(int[] cardPoints, int k) {\n    int lSum = 0, rSum = 0, maxSum = 0;\n    for (int i = 0; i < k; i++) {\n        lSum += cardPoints[i];\n        maxSum = lSum;\n    }\n    int rightIndex = cardPoints.length - 1;\n    for (int i = k - 1; i >= 0; i--) {\n        lSum -= cardPoints[i];\n        rSum += cardPoints[rightIndex];\n        rightIndex--;\n        maxSum = Math.max(maxSum, lSum + rSum);\n    }\n    return maxSum;\n}"
  },
  {
    "name": "Minimum Window Substring",
    "endpoint": "/api/sliding-window/min-window",
    "methodName": "minWindow",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "s": "ADOBECODEBANC", "t": "ABC" },
    "description": "Find the minimum window substring of string s that contains all characters of string t (including duplicates). Example: In the string s = 'ADOBECODEBANC' and t = 'ABC', the minimum window substring is 'BANC', which contains all characters from 'ABC' with length 4. If we tried other windows like 'ADOBEC' (length 6) or 'CODEBA' (length 6), they would be longer. The solution uses a sliding window technique with a character frequency counter to track when all required characters are included in the window, then tries to minimize it by shrinking from the left.",
    "approach": "1. This problem uses the sliding window technique to find the minimum window substring that contains all characters from t.\n2. Steps of the algorithm:\n   a. Create a frequency array for all characters in t to keep track of which characters we need.\n   b. Use two pointers, l and r, to define the current window and a counter to track how many required characters are matched.\n   c. Expand the window by moving the right pointer:\n      - Update the hash array by decrementing the count for the current character.\n      - If the character was needed (hash[char] > 0 before decrementing), increment the matched counter.\n   d. When all characters from t are matched (count == t.length()):\n      - Try to minimize the window by moving the left pointer.\n      - Before moving left, increment the hash count for that character.\n      - If that makes the count positive, it means we're removing a required character, so decrement the match counter.\n      - Continue shrinking until we no longer have a valid window.\n   e. Keep track of the minimum valid window seen so far.\n3. Time Complexity: O(|s| + |t|) where |s| and |t| are the lengths of strings s and t respectively.\n   - We process each character of s at most twice (once through the right pointer, once through the left).\n   - We initially process each character of t once to build the hash array.\n4. Space Complexity: O(1) as we use a fixed-size array of 256 characters.",
    "code": "public String minWindow(String s, String t) {\n    int minLen = Integer.MAX_VALUE;\n    int sIndex = -1;\n    int[] hash = new int[256];\n    for (char c : t.toCharArray()) {\n        hash[c]++;\n    }\n    int count = 0;\n    int l = 0, r = 0;\n    while (r < s.length()) {\n        if (hash[s.charAt(r)] > 0) {\n            count++;\n        }\n        hash[s.charAt(r)]--;\n        while (count == t.length()) {\n            if (r - l + 1 < minLen) {\n                minLen = r - l + 1;\n                sIndex = l;\n            }\n            hash[s.charAt(l)]++;\n            if (hash[s.charAt(l)] > 0) {\n                count--;\n            }\n            l++;\n        }\n        r++;\n    }\n    return (sIndex == -1) ? \"\" : s.substring(sIndex, sIndex + minLen);\n}"
  },
  {
    "name": "Number of Sub-arrays with Odd Sum",
    "endpoint": "/api/sliding-window/number-of-odd-subarrays",
    "methodName": "numberOfOddSubarrays",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "nums": [1,1,2,1,1], "k": 3 },
    "description": "Find the number of subarrays that contain exactly k odd numbers. Example: In the array [1,1,2,1,1] with k = 3, we need to count subarrays with exactly 3 odd numbers. The odd numbers are at positions 0, 1, 3, and 4. The valid subarrays are: [1,1,2,1], [1,2,1,1], and [1,1,2,1,1], so the answer is 3. The solution uses a clever mathematical approach: first count subarrays with at most k odd numbers, then subtract the count of subarrays with at most (k-1) odd numbers, leaving only those with exactly k odd numbers.",
    "approach": "1. This problem uses a mathematical trick with the sliding window technique: to find subarrays with exactly k odd numbers, we can compute (subarrays with at most k odd numbers) - (subarrays with at most k-1 odd numbers).\n2. The helper function counts subarrays with at most 'goal' odd numbers:\n   a. Maintain a window with left and right pointers.\n   b. For each position of the right pointer:\n      - Determine if the current number is odd by taking its modulo 2 (nums[r] % 2) and add this to our running sum.\n      - If the sum exceeds our goal, shrink the window from the left until we're back under the goal.\n      - For each valid window, add the window length (r-l+1) to our count.\n      - This works because for each right pointer position, we're counting all valid subarrays ending at that position.\n3. By calling helper(k) - helper(k-1), we isolate exactly those subarrays that have precisely k odd numbers.\n4. Time Complexity: O(n) where n is the length of the array.\n   - Each element is processed at most twice in each call to helper.\n   - We make two calls to helper, so overall it's still O(n).\n5. Space Complexity: O(1) as we only use a fixed number of variables.",
    "code": "public int numberOfOddSubarrays(int[] nums, int k) {\n    return helper(nums, k) - helper(nums, k - 1);\n}\n\nprivate int helper(int[] nums, int goal) {\n    if (goal < 0) return 0;\n    int l = 0, r = 0; \n    int sum = 0;      \n    int count = 0;   \n    while (r < nums.length) {\n        sum += nums[r] % 2; \n        while (sum > goal) {\n            sum -= nums[l] % 2;  \n            l++;            \n        }\n        count += (r - l + 1);\n        r++; \n    }\n    return count;\n}"
  },
  {
    "name": "Number of Substrings Containing 'a', 'b', and 'c'",
    "endpoint": "/api/sliding-window/number-of-substrings",
    "methodName": "numberOfSubstrings",
    "serviceFile": "SlidingWindowService.java",
    "defaultInput": { "s": "abcabc" },
    "description": "Find the number of substrings that contain at least one occurrence each of the characters 'a', 'b', and 'c'. Example: In the string 'abcabc', the substrings containing all three characters are: 'abc', 'abca', 'abcab', 'abcabc', 'bca', 'bcab', 'bcabc', 'cab', 'cabc', 'abc'. There are 10 such substrings. The solution uses an efficient approach by tracking the last position of each character and calculating how many valid substrings end at each position i. If at position i we have seen all three characters, with the leftmost at position 'min', then all substrings starting from positions 0 to min and ending at position i are valid.",
    "approach": "1. This problem requires counting substrings containing all three characters 'a', 'b', and 'c'.\n2. Key insight: For each position i in the string, we can count how many valid substrings end at position i.\n3. Steps of the algorithm:\n   a. Maintain an array lastSeen[] to track the most recent index of each character ('a', 'b', 'c').\n   b. For each position i in the string:\n      - Update the lastSeen index for the current character.\n      - If we've seen all three characters (none of the lastSeen values are -1):\n        * Find the minimum index among the three characters (this is the leftmost character that completes a valid substring).\n        * Add (1 + min) to our count - this represents all valid substrings ending at position i.\n4. Why add (1 + min)? Because the number of valid substrings ending at position i is equal to the number of valid starting positions, which is (min + 1) (ranging from index 0 to min).\n5. Time Complexity: O(n) where n is the length of the string.\n   - We process each character exactly once.\n6. Space Complexity: O(1) as we use a fixed-size array of 3 elements.",
    "code": "public int numberOfSubstrings(String s) {\n    int[] lastSeen = {-1, -1, -1};\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        lastSeen[s.charAt(i) - 'a'] = i;\n        if (lastSeen[0] != -1 && lastSeen[1] != -1 && lastSeen[2] != -1) {\n            count += 1 + Math.min(Math.min(lastSeen[0], lastSeen[1]), lastSeen[2]);\n        }\n    }\n    return count;\n}"
  }
]