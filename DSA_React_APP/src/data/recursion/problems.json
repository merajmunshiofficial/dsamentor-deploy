[
  {
    "name": "Check Subsequence Sum",
    "endpoint": "/api/recursion/check-subsequence-sum",
    "methodName": "checkSubsequenceSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 5 },
    "description": "Check if there exists a subsequence of the array whose sum equals the target.",
    "approach": "Use recursion to explore all subsequences, including or excluding each element, and check if any sum to the target.",
    "code": "public boolean checkSubsequenceSum(int[] nums, int target) {\n    return solve(0, nums.length, nums, target);\n}\n\nprivate boolean solve(int i, int n, int[] arr, int k) {\n    if (k == 0) return true;\n    if (k < 0) return false;\n    if (i == n) return k == 0;\n    return solve(i + 1, n, arr, k - arr[i]) || solve(i + 1, n, arr, k);\n}"
  },
  {
    "name": "Combination Sum (Unlimited Repeats)",
    "endpoint": "/api/recursion/combination-sum",
    "methodName": "combinationSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [2, 3, 6, 7], "target": 7 },
    "description": "Find all unique combinations of candidates where chosen numbers sum to target (each number can be used unlimited times).",
    "approach": "Use recursion and backtracking to try including each candidate multiple times, building up combinations that sum to the target.",
    "code": "public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func(candidates, candidates.length - 1, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i < 0) {\n        return;\n    }\n    func(v, i - 1, sum, v2, ans);\n    v2.add(v[i]);\n    func(v, i, sum - v[i], v2, ans);\n    v2.remove(v2.size() - 1);\n}"
  },
  {
    "name": "Combination Sum II (No Repeats)",
    "endpoint": "/api/recursion/combination-sum-2",
    "methodName": "combinationSum2",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [10, 1, 2, 7, 6, 1, 5], "target": 8 },
    "description": "Find all unique combinations where chosen numbers sum to target (each number can be used at most once).",
    "approach": "Sort the array and use recursion/backtracking, skipping duplicates to avoid repeated combinations.",
    "code": "public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(candidates);\n    func2(candidates, 0, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func2(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i >= v.length) {\n        return;\n    }\n    for (int j = i; j < v.length; j++) {\n        if (j > i && v[j] == v[j - 1]) {\n            continue;\n        }\n        v2.add(v[j]);\n        func2(v, j + 1, sum - v[j], v2, ans);\n        v2.remove(v2.size() - 1);\n    }\n}"
  },
  {
    "name": "Combination Sum III (K Numbers, 1-9)",
    "endpoint": "/api/recursion/combination-sum-3",
    "methodName": "combinationSum3",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "k": 3, "n": 7 },
    "description": "Find all possible combinations of k numbers that add up to n, using numbers 1-9 each at most once.",
    "approach": "Use recursion and backtracking to build combinations of k numbers from 1-9 that sum to n.",
    "code": "public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func3(n, 1, new ArrayList<>(), k, ans);\n    return ans;\n}\n\nprivate void func3(int sum, int last, List<Integer> nums, int k, List<List<Integer>> ans) {\n    if (sum == 0 && nums.size() == k) {\n        ans.add(new ArrayList<>(nums));\n        return;\n    }\n    if (sum <= 0 || nums.size() > k) return;\n\n    for (int i = last; i <= 9; i++) {\n        if (i <= sum) {\n            nums.add(i);\n            func3(sum - i, i + 1, nums, k, ans);\n            nums.remove(nums.size() - 1);\n        } else {\n            break;\n        }\n    }\n}"
  },
  {
    "name": "Count Subsequences with Target Sum",
    "endpoint": "/api/recursion/count-subsequence-with-target-sum",
    "methodName": "countSubsequenceWithTargetSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 3 },
    "description": "Count the number of subsequences whose sum equals the target.",
    "approach": "Use recursion to count all subsequences that sum to the target by including or excluding each element.",
    "code": "public int countSubsequenceWithTargetSum(int[] nums, int target) {\n    return func4(0, target, nums);\n}\n\nprivate int func4(int ind, int sum, int[] nums) {\n    if (ind == nums.length) {\n        if (sum == 0) return 1;\n        else return 0;\n    }\n    return func4(ind + 1, sum - nums[ind], nums) + func4(ind + 1, sum, nums);\n}"
  },
  {
    "name": "Word Search in 2D Board",
    "endpoint": "/api/recursion/exist",
    "methodName": "exist",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCCED" },
    "description": "Check if a word exists in a 2D board by moving horizontally or vertically to adjacent cells.",
    "approach": "Use DFS recursion to search for the word starting from each cell, marking visited cells temporarily.",
    "code": "public boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == word.charAt(0)) {\n                if (func5(board, i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean func5(char[][] board, int i, int j, String word, int k) {\n    if (k == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || word.charAt(k) != board[i][j]) {\n        return false;\n    }\n\n    char temp = board[i][j];\n    board[i][j] = ' ';\n\n    boolean ans = func5(board, i + 1, j, word, k + 1) ||\n                  func5(board, i - 1, j, word, k + 1) ||\n                  func5(board, i, j + 1, word, k + 1) ||\n                  func5(board, i, j - 1, word, k + 1);\n\n    board[i][j] = temp;\n    return ans;\n}"
  },
  {
    "name": "Rat in a Maze (Find All Paths)",
    "endpoint": "/api/recursion/find-path",
    "methodName": "findPath",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "grid": [[1,0,0,0],[1,1,0,1],[0,1,0,0],[1,1,1,1]] },
    "description": "Find all possible paths for a rat to reach the bottom-right corner of a maze grid.",
    "approach": "Use recursion and backtracking to explore all possible moves (down, right, up, left) and collect valid paths.",
    "code": "public List<String> findPath(int[][] grid) {\n    int n = grid.length;\n    List<String> result = new ArrayList<>();\n    if (grid[0][0] == 0 || grid[n - 1][n - 1] == 0) {\n        return result;\n    }\n    path(grid, 0, 0, \"\", n, result);\n    Collections.sort(result);\n    return result;\n}\n\nprivate void path(int[][] m, int x, int y, String dir, int n, List<String> result) {\n    if (x == n - 1 && y == n - 1) {\n        result.add(dir);\n        return;\n    }\n    if (m[x][y] == 0) return;\n    \n    m[x][y] = 0;\n    \n    if (x < n - 1) path(m, x + 1, y, dir + 'D', n, result);\n    if (y < n - 1) path(m, x, y + 1, dir + 'R', n, result);\n    if (x > 0) path(m, x - 1, y, dir + 'U', n, result);\n    if (y > 0) path(m, x, y - 1, dir + 'L', n, result);\n    \n    m[x][y] = 1;\n}"
  },
  {
    "name": "Generate Parentheses",
    "endpoint": "/api/recursion/generate-parenthesis",
    "methodName": "generateParenthesis",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 3 },
    "description": "Generate all combinations of well-formed parentheses for n pairs.",
    "approach": "Use recursion to build valid parentheses strings by adding '(' or ')' as long as the sequence remains valid.",
    "code": "public List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generate(0, 0, n, \"\", result);\n    return result;\n}\n\nprivate void generate(int open, int close, int n, String current, List<String> result) {\n    if (open == close && open + close == 2 * n) {\n        result.add(current);\n        return;\n    }\n    if (open < n) {\n        generate(open + 1, close, n, current + '(', result);\n    }\n    if (close < open) {\n        generate(open, close + 1, n, current + ')', result);\n    }\n}"
  },
  {
    "name": "Graph Coloring Problem",
    "endpoint": "/api/recursion/graph-coloring",
    "methodName": "graphColoring",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "edges": [[0,1],[1,2],[2,0]], "m": 3, "n": 3 },
    "description": "Determine if a graph can be colored with m colors such that no two adjacent nodes have the same color.",
    "approach": "Use recursion and backtracking to assign colors to each node, checking for safety at each step.",
    "code": "public boolean graphColoring(int[][] edges, int m, int n) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adj.get(edge[0]).add(edge[1]);\n        adj.get(edge[1]).add(edge[0]);\n    }\n    int[] colors = new int[n];\n    return solve6(0, m, n, colors, adj);\n}\n\nprivate boolean solve6(int node, int m, int n, int[] colors, List<List<Integer>> adj) {\n    if (n == node) return true;\n    for (int i = 1; i <= m; i++) {\n        if (isSafe(i, node, colors, adj)) {\n            colors[node] = i;\n            if (solve6(node + 1, m, n, colors, adj)) return true;\n            colors[node] = 0;\n        }\n    }\n    return false;\n}\n\nprivate boolean isSafe(int col, int node, int[] colors, List<List<Integer>> adj) {\n    for (int neighbor : adj.get(node)) {\n        if (colors[neighbor] == col) return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Palindrome Partitioning",
    "endpoint": "/api/recursion/partition",
    "methodName": "partition",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "s": "aab" },
    "description": "Partition a string into all possible palindrome substring combinations.",
    "approach": "Use recursion and backtracking to try every possible partition and check if each substring is a palindrome.",
    "code": "public List<List<String>> partition(String s) {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    dfs(0, s, path, res);\n    return res;\n}\n\nprivate void dfs(int index, String s, List<String> path, List<List<String>> res) {\n    if (index == s.length()) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    for (int i = index; i < s.length(); i++) {\n        if (isPalindrome(s, index, i)) {\n            path.add(s.substring(index, i + 1));\n            dfs(i + 1, s, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\nprivate boolean isPalindrome(String s, int start, int end) {\n    while (start <= end) {\n        if (s.charAt(start++) != s.charAt(end--))\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Letter Combinations of a Phone Number",
    "endpoint": "/api/recursion/letter-combinations",
    "methodName": "letterCombinations",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "digits": "23" },
    "description": "Return all possible letter combinations that the number could represent on a phone keypad.",
    "approach": "Use recursion to build all possible strings by mapping each digit to its corresponding letters.",
    "code": "public List<String> letterCombinations(String digits) {\n    List<String> ans = new ArrayList<>();\n    if (digits.length() == 0) return ans;\n    helper(digits, ans, 0, \"\");\n    return ans;\n}\n\nprivate void helper(String digits, List<String> ans, int index, String current) {\n    if (index == digits.length()) {\n        ans.add(current);\n        return;\n    }\n    String s = map[digits.charAt(index) - '0'];\n    for (int i = 0; i < s.length(); i++) {\n        helper(digits, ans, index + 1, current + s.charAt(i));\n    }\n}\n\nprivate final String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
  },
  {
    "name": "Power Function (x^n)",
    "endpoint": "/api/recursion/my-pow",
    "methodName": "myPow",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "x": 2.0, "n": 10 },
    "description": "Calculate x raised to the power n (x^n) using recursion.",
    "approach": "Use fast exponentiation (divide and conquer) recursively for efficient computation.",
    "code": "public double myPow(double x, int n) {\n    if (n < 0) {\n        return 1.0 / power(x, -1L * n);\n    }\n    return power(x, n);\n}\n\nprivate double power(double x, long n) {\n    if (n == 0) return 1.0;\n    if (n == 1) return x;\n    if (n % 2 == 0) {\n        return power(x * x, n / 2);\n    }\n    return x * power(x, n - 1);\n}"
  },
  {
    "name": "Power Set (All Subsets)",
    "endpoint": "/api/recursion/power-set",
    "methodName": "powerSet",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Generate all possible subsets (the power set) of a set of numbers.",
    "approach": "Use recursion and backtracking to include or exclude each element and build all subsets.",
    "code": "public List<List<Integer>> powerSet(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    List<Integer> current = new ArrayList<>();\n    backtrack(0, nums.length, nums, current, ans);\n    return ans;\n}\n\nprivate void backtrack(int index, int n, int[] nums, List<Integer> current, List<List<Integer>> ans) {\n    if (index == n) {\n        ans.add(new ArrayList<>(current));\n        return;\n    }\n    backtrack(index + 1, n, nums, current, ans);\n    current.add(nums[index]);\n    backtrack(index + 1, n, nums, current, ans);\n    current.remove(current.size() - 1);\n}"
  },
  {
    "name": "N-Queens Problem",
    "endpoint": "/api/recursion/solve-n-queens",
    "methodName": "solveNQueens",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 4 },
    "description": "Solve the N-Queens problem and return all distinct solutions.",
    "approach": "Use recursion and backtracking to place queens row by row, checking for safety at each step.",
    "code": "public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(board[i], '.');\n    }\n    solveNQueensHelper(0, board, result);\n    return result;\n}\n\nprivate void solveNQueensHelper(int row, char[][] board, List<List<String>> result) {\n    if (row == board.length) {\n        List<String> solution = new ArrayList<>();\n        for (char[] rowArray : board) {\n            solution.add(new String(rowArray));\n        }\n        result.add(solution);\n        return;\n    }\n    \n    for (int col = 0; col < board.length; col++) {\n        if (isNQueensSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueensHelper(row + 1, board, result);\n            board[row][col] = '.';\n        }\n    }\n}\n\nprivate boolean isNQueensSafe(char[][] board, int row, int col) {\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    return true;\n}"
  },
  {
    "name": "Sudoku Solver",
    "endpoint": "/api/recursion/solve-sudoku",
    "methodName": "solveSudoku",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] },
    "description": "Solve a given Sudoku puzzle using recursion and backtracking.",
    "approach": "Use recursion to try placing each digit in empty cells, backtracking when a placement is invalid.",
    "code": "public char[][] solveSudoku(char[][] board) {\n    solve(board);\n    return board;\n}\n\nprivate boolean solve(char[][] board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isSudokuSafe(board, i, j, c)) {\n                        board[i][j] = c;\n                        if (solve(board))\n                            return true;\n                        else\n                            board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate boolean isSudokuSafe(char[][] board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c)\n            return false;\n        if (board[row][i] == c)\n            return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Subsets With Duplicates",
    "endpoint": "/api/recursion/subsets-with-dup",
    "methodName": "subsetsWithDup",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 2] },
    "description": "Return all possible subsets of a list of numbers, allowing for duplicates.",
    "approach": "Sort the array and use recursion/backtracking, skipping duplicates to avoid repeated subsets.",
    "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    subsetsWithDupHelper(0, nums, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void subsetsWithDupHelper(int index, int[] nums, List<Integer> current, List<List<Integer>> result) {\n    result.add(new ArrayList<>(current));\n    \n    for (int i = index; i < nums.length; i++) {\n        if (i > index && nums[i] == nums[i - 1]) continue;\n        current.add(nums[i]);\n        subsetsWithDupHelper(i + 1, nums, current, result);\n        current.remove(current.size() - 1);\n    }\n}"
  },
  {
    "name": "Subset Sums",
    "endpoint": "/api/recursion/subset-sums",
    "methodName": "subsetSums",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Return all possible sums of subsets of a list of numbers.",
    "approach": "Use recursion to include or exclude each element and accumulate the sum for each subset.",
    "code": "public List<Integer> subsetSums(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    func(0, 0, nums, ans);\n    return ans;\n}\n\nprivate void func(int ind, int sum, int[] nums, List<Integer> ans) {\n    if (ind == nums.length) {\n        ans.add(sum);\n        return;\n    }\n    func(ind + 1, sum + nums[ind], nums, ans);\n    func(ind + 1, sum, nums, ans);\n}"
  }
]