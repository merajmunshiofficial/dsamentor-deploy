[
  {
    "name": "Check Subsequence Sum",
    "endpoint": "/api/recursion/check-subsequence-sum",
    "methodName": "checkSubsequenceSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 5 },
    "description": "Check if there exists a subsequence of the array whose sum equals the target.",
    "approach": "1. Use recursion to explore all possible subsequences by making binary decisions at each element\n2. At each index, we have two choices: include the current element or exclude it\n3. Base cases: if target becomes 0, we found a valid subsequence; if we reach end without target=0, no valid subsequence\n4. If target becomes negative, prune this path as it's invalid\n5. Recursively call for both choices: solve(i+1, target-arr[i]) for inclusion and solve(i+1, target) for exclusion\n6. Return true if either recursive call returns true (OR operation)",
    "code": "public boolean checkSubsequenceSum(int[] nums, int target) {\n    return solve(0, nums.length, nums, target);\n}\n\nprivate boolean solve(int i, int n, int[] arr, int k) {\n    if (k == 0) return true;\n    if (k < 0) return false;\n    if (i == n) return k == 0;\n    return solve(i + 1, n, arr, k - arr[i]) || solve(i + 1, n, arr, k);\n}"
  },
  {
    "name": "Combination Sum (Unlimited Repeats)",
    "endpoint": "/api/recursion/combination-sum",
    "methodName": "combinationSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [2, 3, 6, 7], "target": 7 },
    "description": "Find all unique combinations of candidates where chosen numbers sum to target (each number can be used unlimited times).",
    "approach": "1. Use recursion with backtracking to explore combinations where numbers can be reused\n2. Start from the last candidate index and work backwards to handle order naturally\n3. For each position, we have two choices: exclude current candidate or include it\n4. If we include current candidate, we can use it again (stay at same index)\n5. Base cases: if sum becomes 0, we found a valid combination; if sum < 0 or index < 0, backtrack\n6. Use a temporary list to build combinations and add copies to result when valid",
    "code": "public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func(candidates, candidates.length - 1, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i < 0) {\n        return;\n    }\n    func(v, i - 1, sum, v2, ans);\n    v2.add(v[i]);\n    func(v, i, sum - v[i], v2, ans);\n    v2.remove(v2.size() - 1);\n}"
  },
  {
    "name": "Combination Sum II (No Repeats)",
    "endpoint": "/api/recursion/combination-sum-2",
    "methodName": "combinationSum2",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [10, 1, 2, 7, 6, 1, 5], "target": 8 },
    "description": "Find all unique combinations where chosen numbers sum to target (each number can be used at most once).",
    "approach": "1. Sort the array first to handle duplicates systematically\n2. Use recursion with backtracking, where each number can only be used once\n3. At each recursive level, iterate through remaining candidates starting from current index\n4. Skip duplicate values at the same recursion level using: if (j > i && v[j] == v[j-1]) continue\n5. This ensures we don't generate duplicate combinations while allowing duplicates within a single combination\n6. Include current candidate, recurse with next index, then backtrack by removing it",
    "code": "public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(candidates);\n    func2(candidates, 0, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func2(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i >= v.length) {\n        return;\n    }\n    for (int j = i; j < v.length; j++) {\n        if (j > i && v[j] == v[j - 1]) {\n            continue;\n        }\n        v2.add(v[j]);\n        func2(v, j + 1, sum - v[j], v2, ans);\n        v2.remove(v2.size() - 1);\n    }\n}"
  },
  {
    "name": "Combination Sum III (K Numbers, 1-9)",
    "endpoint": "/api/recursion/combination-sum-3",
    "methodName": "combinationSum3",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "k": 3, "n": 7 },
    "description": "Find all possible combinations of k numbers that add up to n, using numbers 1-9 each at most once.",
    "approach": "1. Use recursion to build combinations of exactly k numbers from digits 1-9\n2. Maintain current sum, last used number, current combination list, and target k\n3. Base case: if sum equals target n AND we have exactly k numbers, add to result\n4. Early termination: if sum exceeds target or we have more than k numbers, return\n5. For each digit from last+1 to 9, include it if it doesn't exceed remaining sum\n6. Recursively build with updated sum, next starting digit, and incremented count",
    "code": "public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func3(n, 1, new ArrayList<>(), k, ans);\n    return ans;\n}\n\nprivate void func3(int sum, int last, List<Integer> nums, int k, List<List<Integer>> ans) {\n    if (sum == 0 && nums.size() == k) {\n        ans.add(new ArrayList<>(nums));\n        return;\n    }\n    if (sum <= 0 || nums.size() > k) return;\n\n    for (int i = last; i <= 9; i++) {\n        if (i <= sum) {\n            nums.add(i);\n            func3(sum - i, i + 1, nums, k, ans);\n            nums.remove(nums.size() - 1);\n        } else {\n            break;\n        }\n    }\n}"
  },
  {
    "name": "Count Subsequences with Target Sum",
    "endpoint": "/api/recursion/count-subsequence-with-target-sum",
    "methodName": "countSubsequenceWithTargetSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 3 },
    "description": "Count the number of subsequences whose sum equals the target.",
    "approach": "1. Use recursion with inclusion/exclusion pattern to count valid subsequences\n2. At each index, we have two choices: include current element or exclude it\n3. Base case: if we reach end of array, return 1 if sum is 0 (found valid subsequence), else 0\n4. If we include current element, subtract it from target sum and recurse\n5. If we exclude current element, keep sum same and recurse\n6. Return sum of both recursive calls to count all possible valid subsequences",
    "code": "public int countSubsequenceWithTargetSum(int[] nums, int target) {\n    return func4(0, target, nums);\n}\n\nprivate int func4(int ind, int sum, int[] nums) {\n    if (ind == nums.length) {\n        if (sum == 0) return 1;\n        else return 0;\n    }\n    return func4(ind + 1, sum - nums[ind], nums) + func4(ind + 1, sum, nums);\n}"
  },
  {
    "name": "Word Search in 2D Board",
    "endpoint": "/api/recursion/exist",
    "methodName": "exist",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCCED" },
    "description": "Check if a word exists in a 2D board by moving horizontally or vertically to adjacent cells.",
    "approach": "1. Try starting the word search from every cell in the board\n2. Use DFS recursion to explore all 4 directions (up, down, left, right) from current cell\n3. Mark current cell as visited by temporarily changing its value to avoid revisiting\n4. Base cases: if we've matched entire word return true; if out of bounds or character mismatch return false\n5. Recursively search in all 4 directions with next character index\n6. Restore original cell value after recursive calls (backtracking) to allow other paths to use it",
    "code": "public boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == word.charAt(0)) {\n                if (func5(board, i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean func5(char[][] board, int i, int j, String word, int k) {\n    if (k == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || word.charAt(k) != board[i][j]) {\n        return false;\n    }\n\n    char temp = board[i][j];\n    board[i][j] = ' ';\n\n    boolean ans = func5(board, i + 1, j, word, k + 1) ||\n                  func5(board, i - 1, j, word, k + 1) ||\n                  func5(board, i, j + 1, word, k + 1) ||\n                  func5(board, i, j - 1, word, k + 1);\n\n    board[i][j] = temp;\n    return ans;\n}"
  },
  {
    "name": "Rat in a Maze (Find All Paths)",
    "endpoint": "/api/recursion/find-path",
    "methodName": "findPath",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "grid": [[1,0,0,0],[1,1,0,1],[0,1,0,0],[1,1,1,1]] },
    "description": "Find all possible paths for a rat to reach the bottom-right corner of a maze grid.",
    "approach": "1. Start from top-left corner (0,0) and try to reach bottom-right corner (n-1,n-1)\n2. Use recursion with backtracking to explore all 4 directions: Down(D), Right(R), Up(U), Left(L)\n3. Mark current cell as visited (set to 0) to prevent revisiting in current path\n4. Base case: if we reach destination (n-1,n-1), add current path string to result\n5. Try each direction if it's within bounds and cell is not blocked (value = 1)\n6. After exploring each direction, restore cell value (set back to 1) for other paths to use",
    "code": "public List<String> findPath(int[][] grid) {\n    int n = grid.length;\n    List<String> result = new ArrayList<>();\n    if (grid[0][0] == 0 || grid[n - 1][n - 1] == 0) {\n        return result;\n    }\n    path(grid, 0, 0, \"\", n, result);\n    Collections.sort(result);\n    return result;\n}\n\nprivate void path(int[][] m, int x, int y, String dir, int n, List<String> result) {\n    if (x == n - 1 && y == n - 1) {\n        result.add(dir);\n        return;\n    }\n    if (m[x][y] == 0) return;\n    \n    m[x][y] = 0;\n    \n    if (x < n - 1) path(m, x + 1, y, dir + 'D', n, result);\n    if (y < n - 1) path(m, x, y + 1, dir + 'R', n, result);\n    if (x > 0) path(m, x - 1, y, dir + 'U', n, result);\n    if (y > 0) path(m, x, y - 1, dir + 'L', n, result);\n    \n    m[x][y] = 1;\n}"
  },
  {
    "name": "Generate Parentheses",
    "endpoint": "/api/recursion/generate-parenthesis",
    "methodName": "generateParenthesis",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 3 },
    "description": "Generate all combinations of well-formed parentheses for n pairs.",
    "approach": "1. Use recursion to build valid parentheses strings by tracking open and close counts\n2. Base case: when both open and close counts equal n, we have a complete valid string\n3. We can add '(' if current open count is less than n (haven't used all opening brackets)\n4. We can add ')' if current close count is less than open count (maintain validity)\n5. Build string character by character, ensuring we never have more ')' than '(' at any point\n6. This ensures all generated strings are well-formed parentheses combinations",
    "code": "public List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generate(0, 0, n, \"\", result);\n    return result;\n}\n\nprivate void generate(int open, int close, int n, String current, List<String> result) {\n    if (open == close && open + close == 2 * n) {\n        result.add(current);\n        return;\n    }\n    if (open < n) {\n        generate(open + 1, close, n, current + '(', result);\n    }\n    if (close < open) {\n        generate(open, close + 1, n, current + ')', result);\n    }\n}"
  },
  {
    "name": "Graph Coloring Problem",
    "endpoint": "/api/recursion/graph-coloring",
    "methodName": "graphColoring",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "edges": [[0,1],[1,2],[2,0]], "m": 3, "n": 3 },
    "description": "Determine if a graph can be colored with m colors such that no two adjacent nodes have the same color.",
    "approach": "1. Convert edge list to adjacency list representation for efficient neighbor lookup\n2. Use recursion with backtracking to try assigning each of m colors to each node\n3. For each node, try colors 1 to m and check if assignment is safe\n4. A color is safe if no adjacent node already has that color\n5. If current assignment is safe, recursively color the next node\n6. If we successfully color all n nodes, return true; otherwise backtrack and try next color",
    "code": "public boolean graphColoring(int[][] edges, int m, int n) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adj.get(edge[0]).add(edge[1]);\n        adj.get(edge[1]).add(edge[0]);\n    }\n    int[] colors = new int[n];\n    return solve6(0, m, n, colors, adj);\n}\n\nprivate boolean solve6(int node, int m, int n, int[] colors, List<List<Integer>> adj) {\n    if (n == node) return true;\n    for (int i = 1; i <= m; i++) {\n        if (isSafe(i, node, colors, adj)) {\n            colors[node] = i;\n            if (solve6(node + 1, m, n, colors, adj)) return true;\n            colors[node] = 0;\n        }\n    }\n    return false;\n}\n\nprivate boolean isSafe(int col, int node, int[] colors, List<List<Integer>> adj) {\n    for (int neighbor : adj.get(node)) {\n        if (colors[neighbor] == col) return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Palindrome Partitioning",
    "endpoint": "/api/recursion/partition",
    "methodName": "partition",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "s": "aab" },
    "description": "Partition a string into all possible palindrome substring combinations.",
    "approach": "1. Use recursion with backtracking to try all possible ways to partition the string\n2. At each position, try extending the current substring one character at a time\n3. For each potential substring, check if it's a palindrome using two-pointer technique\n4. If current substring is palindrome, add it to current path and recurse on remaining string\n5. Base case: when we reach end of string, add current path to result\n6. Backtrack by removing last added substring to explore other partitioning possibilities",
    "code": "public List<List<String>> partition(String s) {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    dfs(0, s, path, res);\n    return res;\n}\n\nprivate void dfs(int index, String s, List<String> path, List<List<String>> res) {\n    if (index == s.length()) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    for (int i = index; i < s.length(); i++) {\n        if (isPalindrome(s, index, i)) {\n            path.add(s.substring(index, i + 1));\n            dfs(i + 1, s, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\nprivate boolean isPalindrome(String s, int start, int end) {\n    while (start <= end) {\n        if (s.charAt(start++) != s.charAt(end--))\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Letter Combinations of a Phone Number",
    "endpoint": "/api/recursion/letter-combinations",
    "methodName": "letterCombinations",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "digits": "23" },
    "description": "Return all possible letter combinations that the number could represent on a phone keypad.",
    "approach": "1. Create a mapping from digits (2-9) to their corresponding letters on phone keypad\n2. Use recursion to build all possible letter combinations for the input digits\n3. For each digit, iterate through all its possible letters\n4. Base case: when we've processed all digits, add current combination to result\n5. For each letter of current digit, recursively build combinations with remaining digits\n6. Build string incrementally by appending each chosen letter to current combination",
    "code": "public List<String> letterCombinations(String digits) {\n    List<String> ans = new ArrayList<>();\n    if (digits.length() == 0) return ans;\n    helper(digits, ans, 0, \"\");\n    return ans;\n}\n\nprivate void helper(String digits, List<String> ans, int index, String current) {\n    if (index == digits.length()) {\n        ans.add(current);\n        return;\n    }\n    String s = map[digits.charAt(index) - '0'];\n    for (int i = 0; i < s.length(); i++) {\n        helper(digits, ans, index + 1, current + s.charAt(i));\n    }\n}\n\nprivate final String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
  },
  {
    "name": "Power Function (x^n)",
    "endpoint": "/api/recursion/my-pow",
    "methodName": "myPow",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "x": 2.0, "n": 10 },
    "description": "Calculate x raised to the power n (x^n) using recursion.",
    "approach": "1. Use fast exponentiation algorithm with recursion for O(log n) time complexity\n2. Handle negative exponents by taking reciprocal of positive power result\n3. Base cases: x^0 = 1, x^1 = x\n4. For even exponents: x^n = (x^2)^(n/2) - square the base and halve the exponent\n5. For odd exponents: x^n = x * x^(n-1) - multiply by x and recurse with n-1\n6. This divides the problem size by 2 in most cases, leading to logarithmic time complexity",
    "code": "public double myPow(double x, int n) {\n    if (n < 0) {\n        return 1.0 / power(x, -1L * n);\n    }\n    return power(x, n);\n}\n\nprivate double power(double x, long n) {\n    if (n == 0) return 1.0;\n    if (n == 1) return x;\n    if (n % 2 == 0) {\n        return power(x * x, n / 2);\n    }\n    return x * power(x, n - 1);\n}"
  },
  {
    "name": "Power Set (All Subsets)",
    "endpoint": "/api/recursion/power-set",
    "methodName": "powerSet",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Generate all possible subsets (the power set) of a set of numbers.",
    "approach": "1. Use recursion with backtracking to generate all 2^n possible subsets\n2. At each element, we have two choices: include it in current subset or exclude it\n3. Base case: when we reach end of array, add current subset to result\n4. First recurse excluding current element, then include it and recurse again\n5. Use backtracking to remove element after including it to explore other possibilities\n6. This systematically explores all combinations of including/excluding each element",
    "code": "public List<List<Integer>> powerSet(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    List<Integer> current = new ArrayList<>();\n    backtrack(0, nums.length, nums, current, ans);\n    return ans;\n}\n\nprivate void backtrack(int index, int n, int[] nums, List<Integer> current, List<List<Integer>> ans) {\n    if (index == n) {\n        ans.add(new ArrayList<>(current));\n        return;\n    }\n    backtrack(index + 1, n, nums, current, ans);\n    current.add(nums[index]);\n    backtrack(index + 1, n, nums, current, ans);\n    current.remove(current.size() - 1);\n}"
  },
  {
    "name": "N-Queens Problem",
    "endpoint": "/api/recursion/solve-n-queens",
    "methodName": "solveNQueens",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 4 },
    "description": "Solve the N-Queens problem and return all distinct solutions.",
    "approach": "1. Use recursion with backtracking to place queens row by row on the chessboard\n2. For each row, try placing a queen in each column and check if position is safe\n3. A position is safe if no other queen can attack it (no conflicts in column, diagonal, anti-diagonal)\n4. Base case: if we've successfully placed queens in all n rows, add board configuration to result\n5. After placing a queen, recursively try to place remaining queens in subsequent rows\n6. If placement fails, backtrack by removing queen and trying next column position",
    "code": "public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(board[i], '.');\n    }\n    solveNQueensHelper(0, board, result);\n    return result;\n}\n\nprivate void solveNQueensHelper(int row, char[][] board, List<List<String>> result) {\n    if (row == board.length) {\n        List<String> solution = new ArrayList<>();\n        for (char[] rowArray : board) {\n            solution.add(new String(rowArray));\n        }\n        result.add(solution);\n        return;\n    }\n    \n    for (int col = 0; col < board.length; col++) {\n        if (isNQueensSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueensHelper(row + 1, board, result);\n            board[row][col] = '.';\n        }\n    }\n}\n\nprivate boolean isNQueensSafe(char[][] board, int row, int col) {\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    return true;\n}"
  },
  {
    "name": "Sudoku Solver",
    "endpoint": "/api/recursion/solve-sudoku",
    "methodName": "solveSudoku",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] },
    "description": "Solve a given Sudoku puzzle using recursion and backtracking.",
    "approach": "1. Use recursion with backtracking to fill empty cells one by one\n2. Scan board from top-left to find first empty cell (marked with '.')\n3. For each empty cell, try placing digits 1-9 and check if placement is valid\n4. A placement is valid if digit doesn't appear in same row, column, or 3x3 sub-box\n5. If placement is valid, place digit and recursively solve remaining puzzle\n6. If recursive call succeeds, puzzle is solved; otherwise backtrack by removing digit and try next",
    "code": "public char[][] solveSudoku(char[][] board) {\n    solve(board);\n    return board;\n}\n\nprivate boolean solve(char[][] board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isSudokuSafe(board, i, j, c)) {\n                        board[i][j] = c;\n                        if (solve(board))\n                            return true;\n                        else\n                            board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate boolean isSudokuSafe(char[][] board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c)\n            return false;\n        if (board[row][i] == c)\n            return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Subsets With Duplicates",
    "endpoint": "/api/recursion/subsets-with-dup",
    "methodName": "subsetsWithDup",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 2] },
    "description": "Return all possible subsets of a list of numbers, allowing for duplicates.",
    "approach": "1. Sort the input array first to handle duplicates systematically\n2. Use recursion with backtracking, similar to generating power set but with duplicate handling\n3. Add current subset to result at beginning of each recursive call (including empty subset)\n4. For each remaining element, decide whether to include it in current subset\n5. Skip duplicate elements at same recursion level using: if (i > index && nums[i] == nums[i-1]) continue\n6. This ensures we generate each unique subset exactly once even with duplicate input elements",
    "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    subsetsWithDupHelper(0, nums, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void subsetsWithDupHelper(int index, int[] nums, List<Integer> current, List<List<Integer>> result) {\n    result.add(new ArrayList<>(current));\n    \n    for (int i = index; i < nums.length; i++) {\n        if (i > index && nums[i] == nums[i - 1]) continue;\n        current.add(nums[i]);\n        subsetsWithDupHelper(i + 1, nums, current, result);\n        current.remove(current.size() - 1);\n    }\n}"
  },
  {
    "name": "Subset Sums",
    "endpoint": "/api/recursion/subset-sums",
    "methodName": "subsetSums",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Return all possible sums of subsets of a list of numbers.",
    "approach": "1. Use recursion to generate all possible subsets and collect their sums\n2. At each element, we have two choices: include it in current sum or exclude it\n3. Base case: when we reach end of array, add current accumulated sum to result list\n4. First recurse including current element (add to sum), then recurse excluding it (keep sum same)\n5. This generates all 2^n possible subset sums including empty subset (sum = 0)\n6. The recursive tree explores all combinations of including/excluding each element",
    "code": "public List<Integer> subsetSums(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    func(0, 0, nums, ans);\n    return ans;\n}\n\nprivate void func(int ind, int sum, int[] nums, List<Integer> ans) {\n    if (ind == nums.length) {\n        ans.add(sum);\n        return;\n    }\n    func(ind + 1, sum + nums[ind], nums, ans);\n    func(ind + 1, sum, nums, ans);\n}"
  }
]