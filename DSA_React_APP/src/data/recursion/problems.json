[
  {
    "name": "Check Subsequence Sum",
    "endpoint": "/api/recursion/check-subsequence-sum",
    "methodName": "checkSubsequenceSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 5 },
    "description": "Given an array of integers and a target sum, determine if there exists at least one subsequence whose elements sum up exactly to the target value. A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, with array [1, 2, 3] and target 5, the answer is true because the subsequence [2, 3] sums to 5. With array [5, 2, 1] and target 10, the answer would be false since no subsequence sums to 10.",
    "approach": "1. Use recursion to explore all possible subsequences by making binary decisions at each element\n2. At each index, we have two choices: include the current element or exclude it\n3. Base cases: if target becomes 0, we found a valid subsequence; if we reach end without target=0, no valid subsequence\n4. If target becomes negative, prune this path as it's invalid\n5. Recursively call for both choices: solve(i+1, target-arr[i]) for inclusion and solve(i+1, target) for exclusion\n6. Return true if either recursive call returns true (OR operation)",
    "code": "public boolean checkSubsequenceSum(int[] nums, int target) {\n    return solve(0, nums.length, nums, target);\n}\n\nprivate boolean solve(int i, int n, int[] arr, int k) {\n    if (k == 0) return true;\n    if (k < 0) return false;\n    if (i == n) return k == 0;\n    return solve(i + 1, n, arr, k - arr[i]) || solve(i + 1, n, arr, k);\n}"
  },
  {
    "name": "Combination Sum (Unlimited Repeats)",
    "endpoint": "/api/recursion/combination-sum",
    "methodName": "combinationSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [2, 3, 6, 7], "target": 7 },
    "description": "Given an array of distinct integers (candidates) and a target integer (target), find all unique combinations of candidates where the chosen numbers sum to the target. The same number may be chosen from candidates an unlimited number of times. For example, with candidates [2, 3, 6, 7] and target 7, the output would be [[2, 2, 3], [7]]. The combination [2, 2, 3] uses 2 twice (2+2+3=7) and the combination [7] uses 7 once (7=7). Two combinations are different if they contain different frequencies of at least one candidate.",
    "approach": "1. Use recursion with backtracking to explore combinations where numbers can be reused\n2. Start from the last candidate index and work backwards to handle order naturally\n3. For each position, we have two choices: exclude current candidate or include it\n4. If we include current candidate, we can use it again (stay at same index)\n5. Base cases: if sum becomes 0, we found a valid combination; if sum < 0 or index < 0, backtrack\n6. Use a temporary list to build combinations and add copies to result when valid",
    "code": "public List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func(candidates, candidates.length - 1, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i < 0) {\n        return;\n    }\n    func(v, i - 1, sum, v2, ans);\n    v2.add(v[i]);\n    func(v, i, sum - v[i], v2, ans);\n    v2.remove(v2.size() - 1);\n}"
  },
  {
    "name": "Combination Sum II (No Repeats)",
    "endpoint": "/api/recursion/combination-sum-2",
    "methodName": "combinationSum2",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "candidates": [10, 1, 2, 7, 6, 1, 5], "target": 8 },
    "description": "Given an array of integers (candidates) and a target integer (target), find all unique combinations of candidates where the sum equals the target. Each number in candidates may only be used once in the combination. The solution must not contain duplicate combinations. For example, with candidates [10, 1, 2, 7, 6, 1, 5] and target 8, the output would be [[1,1,6], [1,2,5], [1,7], [2,6]]. Note that [1,7] and [7,1] are considered the same combination. The array may contain duplicate values (like 1 appears twice), but each element can only be used once per combination.",
    "approach": "1. Sort the array first to handle duplicates systematically\n2. Use recursion with backtracking, where each number can only be used once\n3. At each recursive level, iterate through remaining candidates starting from current index\n4. Skip duplicate values at the same recursion level using: if (j > i && v[j] == v[j-1]) continue\n5. This ensures we don't generate duplicate combinations while allowing duplicates within a single combination\n6. Include current candidate, recurse with next index, then backtrack by removing it",
    "code": "public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(candidates);\n    func2(candidates, 0, target, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void func2(int[] v, int i, int sum, List<Integer> v2, List<List<Integer>> ans) {\n    if (sum == 0) {\n        ans.add(new ArrayList<>(v2));\n        return;\n    }\n    if (sum < 0 || i >= v.length) {\n        return;\n    }\n    for (int j = i; j < v.length; j++) {\n        if (j > i && v[j] == v[j - 1]) {\n            continue;\n        }\n        v2.add(v[j]);\n        func2(v, j + 1, sum - v[j], v2, ans);\n        v2.remove(v2.size() - 1);\n    }\n}"
  },
  {
    "name": "Combination Sum III (K Numbers, 1-9)",
    "endpoint": "/api/recursion/combination-sum-3",
    "methodName": "combinationSum3",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "k": 3, "n": 7 },
    "description": "Find all possible combinations of k numbers that add up exactly to n, using only numbers 1 through 9, with each number used at most once. Return a list of all possible valid combinations. For example, when k=3 and n=7, the output should be [[1,2,4], [1,3,3], [2,2,3]]. This is because 1+2+4=7, 1+3+3=7, and 2+2+3=7, and each combination uses exactly 3 numbers that sum to 7. For k=3 and n=9, the output would include combinations like [1,2,6], [1,3,5], [2,3,4], etc., where each contains exactly 3 numbers summing to 9.",
    "approach": "1. Use recursion to build combinations of exactly k numbers from digits 1-9\n2. Maintain current sum, last used number, current combination list, and target k\n3. Base case: if sum equals target n AND we have exactly k numbers, add to result\n4. Early termination: if sum exceeds target or we have more than k numbers, return\n5. For each digit from last+1 to 9, include it if it doesn't exceed remaining sum\n6. Recursively build with updated sum, next starting digit, and incremented count",
    "code": "public List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> ans = new ArrayList<>();\n    func3(n, 1, new ArrayList<>(), k, ans);\n    return ans;\n}\n\nprivate void func3(int sum, int last, List<Integer> nums, int k, List<List<Integer>> ans) {\n    if (sum == 0 && nums.size() == k) {\n        ans.add(new ArrayList<>(nums));\n        return;\n    }\n    if (sum <= 0 || nums.size() > k) return;\n\n    for (int i = last; i <= 9; i++) {\n        if (i <= sum) {\n            nums.add(i);\n            func3(sum - i, i + 1, nums, k, ans);\n            nums.remove(nums.size() - 1);\n        } else {\n            break;\n        }\n    }\n}"
  },
  {
    "name": "Count Subsequences with Target Sum",
    "endpoint": "/api/recursion/count-subsequence-with-target-sum",
    "methodName": "countSubsequenceWithTargetSum",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3], "target": 3 },
    "description": "Given an array of integers and a target value, count the total number of subsequences (non-empty) in the array whose elements sum up exactly to the target. A subsequence is formed by selecting elements from the original array without changing their order. For example, with array [1, 2, 3] and target 3, there are 2 subsequences with sum 3: [1, 2] and [3]. With array [1, 1, 1, 1] and target 2, there would be 6 subsequences: four ways to choose two 1's ([1,1] at different positions) and one way to choose [1,1] from the first two positions and one way from the last two positions.",
    "approach": "1. Use recursion with inclusion/exclusion pattern to count valid subsequences\n2. At each index, we have two choices: include current element or exclude it\n3. Base case: if we reach end of array, return 1 if sum is 0 (found valid subsequence), else 0\n4. If we include current element, subtract it from target sum and recurse\n5. If we exclude current element, keep sum same and recurse\n6. Return sum of both recursive calls to count all possible valid subsequences",
    "code": "public int countSubsequenceWithTargetSum(int[] nums, int target) {\n    return func4(0, target, nums);\n}\n\nprivate int func4(int ind, int sum, int[] nums) {\n    if (ind == nums.length) {\n        if (sum == 0) return 1;\n        else return 0;\n    }\n    return func4(ind + 1, sum - nums[ind], nums) + func4(ind + 1, sum, nums);\n}"
  },
  {
    "name": "Word Search in 2D Board",
    "endpoint": "/api/recursion/exist",
    "methodName": "exist",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "word": "ABCCED" },
    "description": "Given an m x n 2D board of characters and a string word, determine if the word exists in the grid. The word can be constructed from adjacent cells (horizontally or vertically neighboring), and each cell can only be used once. For example, in the board [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']] and word 'ABCCED', the answer is true because we can trace the word by moving from 'A' → 'B' → 'C' → 'C' → 'E' → 'D'. For the same board and word 'SEE', the answer would also be true, but for 'ABCB', it would be false because we can't reuse the 'B' cell that was already used in the path.",
    "approach": "1. Try starting the word search from every cell in the board\n2. Use DFS recursion to explore all 4 directions (up, down, left, right) from current cell\n3. Mark current cell as visited by temporarily changing its value to avoid revisiting\n4. Base cases: if we've matched entire word return true; if out of bounds or character mismatch return false\n5. Recursively search in all 4 directions with next character index\n6. Restore original cell value after recursive calls (backtracking) to allow other paths to use it",
    "code": "public boolean exist(char[][] board, String word) {\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[0].length; j++) {\n            if (board[i][j] == word.charAt(0)) {\n                if (func5(board, i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean func5(char[][] board, int i, int j, String word, int k) {\n    if (k == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || word.charAt(k) != board[i][j]) {\n        return false;\n    }\n\n    char temp = board[i][j];\n    board[i][j] = ' ';\n\n    boolean ans = func5(board, i + 1, j, word, k + 1) ||\n                  func5(board, i - 1, j, word, k + 1) ||\n                  func5(board, i, j + 1, word, k + 1) ||\n                  func5(board, i, j - 1, word, k + 1);\n\n    board[i][j] = temp;\n    return ans;\n}"
  },
  {
    "name": "Rat in a Maze (Find All Paths)",
    "endpoint": "/api/recursion/find-path",
    "methodName": "findPath",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "grid": [[1,0,0,0],[1,1,0,1],[0,1,0,0],[1,1,1,1]] },
    "description": "Given a maze represented as an N×N binary matrix (grid) where 1 represents an open cell and 0 represents a blocked cell, find all possible paths for a rat to reach the bottom-right corner (grid[N-1][N-1]) starting from the top-left corner (grid[0][0]). The rat can move in four directions: up (U), down (D), left (L), and right (R), and can only travel through open cells (value 1). For example, in a 4×4 grid [[1,0,0,0],[1,1,0,1],[0,1,0,0],[1,1,1,1]], one possible path is 'DDRR' (Down, Down, Right, Right). The output should be a list of all possible path strings in lexicographical order (alphabetical order).",
    "approach": "1. Start from top-left corner (0,0) and try to reach bottom-right corner (n-1,n-1)\n2. Use recursion with backtracking to explore all 4 directions: Down(D), Right(R), Up(U), Left(L)\n3. Mark current cell as visited (set to 0) to prevent revisiting in current path\n4. Base case: if we reach destination (n-1,n-1), add current path string to result\n5. Try each direction if it's within bounds and cell is not blocked (value = 1)\n6. After exploring each direction, restore cell value (set back to 1) for other paths to use",
    "code": "public List<String> findPath(int[][] grid) {\n    int n = grid.length;\n    List<String> result = new ArrayList<>();\n    if (grid[0][0] == 0 || grid[n - 1][n - 1] == 0) {\n        return result;\n    }\n    path(grid, 0, 0, \"\", n, result);\n    Collections.sort(result);\n    return result;\n}\n\nprivate void path(int[][] m, int x, int y, String dir, int n, List<String> result) {\n    if (x == n - 1 && y == n - 1) {\n        result.add(dir);\n        return;\n    }\n    if (m[x][y] == 0) return;\n    \n    m[x][y] = 0;\n    \n    if (x < n - 1) path(m, x + 1, y, dir + 'D', n, result);\n    if (y < n - 1) path(m, x, y + 1, dir + 'R', n, result);\n    if (x > 0) path(m, x - 1, y, dir + 'U', n, result);\n    if (y > 0) path(m, x, y - 1, dir + 'L', n, result);\n    \n    m[x][y] = 1;\n}"
  },
  {
    "name": "Generate Parentheses",
    "endpoint": "/api/recursion/generate-parenthesis",
    "methodName": "generateParenthesis",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 3 },
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed (valid) parentheses strings. A valid parentheses string has an equal number of opening '(' and closing ')' brackets, and every closing bracket has a corresponding opening bracket that comes before it. For example, when n=3, the output should include: ['((()))', '(()())', '(())()', '()(())', '()()()'], representing all 5 possible valid combinations. When n=2, the output would be ['(())', '()()'], and for n=1, just ['()'].",
    "approach": "1. Use recursion to build valid parentheses strings by tracking open and close counts\n2. Base case: when both open and close counts equal n, we have a complete valid string\n3. We can add '(' if current open count is less than n (haven't used all opening brackets)\n4. We can add ')' if current close count is less than open count (maintain validity)\n5. Build string character by character, ensuring we never have more ')' than '(' at any point\n6. This ensures all generated strings are well-formed parentheses combinations",
    "code": "public List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generate(0, 0, n, \"\", result);\n    return result;\n}\n\nprivate void generate(int open, int close, int n, String current, List<String> result) {\n    if (open == close && open + close == 2 * n) {\n        result.add(current);\n        return;\n    }\n    if (open < n) {\n        generate(open + 1, close, n, current + '(', result);\n    }\n    if (close < open) {\n        generate(open, close + 1, n, current + ')', result);\n    }\n}"
  },
  {
    "name": "Graph Coloring Problem",
    "endpoint": "/api/recursion/graph-coloring",
    "methodName": "graphColoring",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "edges": [[0,1],[1,2],[2,0]], "m": 3, "n": 3 },
    "description": "Given an undirected graph represented as an edge list (edges), determine if it's possible to assign one of m different colors to each node such that no two adjacent nodes have the same color. For example, with a graph having edges [[0,1],[1,2],[2,0]] (a triangle), m=3, and n=3 nodes, the answer is true because we can color node 0 with color 1, node 1 with color 2, and node 2 with color 3. If m=2 for the same graph, the answer would be false because a triangle requires at least 3 colors to ensure no adjacent nodes have the same color. Return true if the graph can be colored with at most m colors, otherwise false.",
    "approach": "1. Convert edge list to adjacency list representation for efficient neighbor lookup\n2. Use recursion with backtracking to try assigning each of m colors to each node\n3. For each node, try colors 1 to m and check if assignment is safe\n4. A color is safe if no adjacent node already has that color\n5. If current assignment is safe, recursively color the next node\n6. If we successfully color all n nodes, return true; otherwise backtrack and try next color",
    "code": "public boolean graphColoring(int[][] edges, int m, int n) {\n    List<List<Integer>> adj = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adj.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adj.get(edge[0]).add(edge[1]);\n        adj.get(edge[1]).add(edge[0]);\n    }\n    int[] colors = new int[n];\n    return solve6(0, m, n, colors, adj);\n}\n\nprivate boolean solve6(int node, int m, int n, int[] colors, List<List<Integer>> adj) {\n    if (n == node) return true;\n    for (int i = 1; i <= m; i++) {\n        if (isSafe(i, node, colors, adj)) {\n            colors[node] = i;\n            if (solve6(node + 1, m, n, colors, adj)) return true;\n            colors[node] = 0;\n        }\n    }\n    return false;\n}\n\nprivate boolean isSafe(int col, int node, int[] colors, List<List<Integer>> adj) {\n    for (int neighbor : adj.get(node)) {\n        if (colors[neighbor] == col) return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Palindrome Partitioning",
    "endpoint": "/api/recursion/partition",
    "methodName": "partition",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "s": "aab" },
    "description": "Given a string s, partition it such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of the string. A palindrome is a string that reads the same backward as forward. For example, with input string 'aab', the output would be [['a','a','b'], ['aa','b']]. This is because both partitions are valid: ['a','a','b'] (three individual characters, where 'a' and 'a' are palindromes of length 1, and 'b' is a single character) and ['aa','b'] ('aa' is a palindrome of length 2, and 'b' is a single character). For string 'aba', the output would include [['a','b','a'], ['aba']] as 'aba' is itself a palindrome.",
    "approach": "1. Use recursion with backtracking to try all possible ways to partition the string\n2. At each position, try extending the current substring one character at a time\n3. For each potential substring, check if it's a palindrome using two-pointer technique\n4. If current substring is palindrome, add it to current path and recurse on remaining string\n5. Base case: when we reach end of string, add current path to result\n6. Backtrack by removing last added substring to explore other partitioning possibilities",
    "code": "public List<List<String>> partition(String s) {\n    List<List<String>> res = new ArrayList<>();\n    List<String> path = new ArrayList<>();\n    dfs(0, s, path, res);\n    return res;\n}\n\nprivate void dfs(int index, String s, List<String> path, List<List<String>> res) {\n    if (index == s.length()) {\n        res.add(new ArrayList<>(path));\n        return;\n    }\n    for (int i = index; i < s.length(); i++) {\n        if (isPalindrome(s, index, i)) {\n            path.add(s.substring(index, i + 1));\n            dfs(i + 1, s, path, res);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n\nprivate boolean isPalindrome(String s, int start, int end) {\n    while (start <= end) {\n        if (s.charAt(start++) != s.charAt(end--))\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Letter Combinations of a Phone Number",
    "endpoint": "/api/recursion/letter-combinations",
    "methodName": "letterCombinations",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "digits": "23" },
    "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent on a phone keypad. The mapping of digits to letters follows the standard telephone keypad: 2 maps to 'abc', 3 maps to 'def', 4 maps to 'ghi', and so on. For example, with input '23', the output would be ['ad','ae','af','bd','be','bf','cd','ce','cf']. This is because digit 2 can be 'a', 'b', or 'c', and digit 3 can be 'd', 'e', or 'f', so all possible combinations are listed. With input '2', the output would simply be ['a','b','c'].",
    "approach": "1. Create a mapping from digits (2-9) to their corresponding letters on phone keypad\n2. Use recursion to build all possible letter combinations for the input digits\n3. For each digit, iterate through all its possible letters\n4. Base case: when we've processed all digits, add current combination to result\n5. For each letter of current digit, recursively build combinations with remaining digits\n6. Build string incrementally by appending each chosen letter to current combination",
    "code": "public List<String> letterCombinations(String digits) {\n    List<String> ans = new ArrayList<>();\n    if (digits.length() == 0) return ans;\n    helper(digits, ans, 0, \"\");\n    return ans;\n}\n\nprivate void helper(String digits, List<String> ans, int index, String current) {\n    if (index == digits.length()) {\n        ans.add(current);\n        return;\n    }\n    String s = map[digits.charAt(index) - '0'];\n    for (int i = 0; i < s.length(); i++) {\n        helper(digits, ans, index + 1, current + s.charAt(i));\n    }\n}\n\nprivate final String[] map = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};"
  },
  {
    "name": "Power Function (x^n)",
    "endpoint": "/api/recursion/my-pow",
    "methodName": "myPow",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "x": 2.0, "n": 10 },
    "description": "Implement a function to calculate x raised to the power n (x^n) efficiently using recursion. The solution should handle both positive and negative integer exponents, as well as edge cases. For example, calculating 2.0^10 would yield 1024.0 (2^10 = 2×2×2×2×2×2×2×2×2×2 = 1024), while 2.0^(-2) would give 0.25 (2^(-2) = 1/2^2 = 1/4 = 0.25). The implementation should achieve logarithmic time complexity using a divide and conquer approach rather than computing multiplication n times linearly.",
    "approach": "1. Use fast exponentiation algorithm with recursion for O(log n) time complexity\n2. Handle negative exponents by taking reciprocal of positive power result\n3. Base cases: x^0 = 1, x^1 = x\n4. For even exponents: x^n = (x^2)^(n/2) - square the base and halve the exponent\n5. For odd exponents: x^n = x * x^(n-1) - multiply by x and recurse with n-1\n6. This divides the problem size by 2 in most cases, leading to logarithmic time complexity",
    "code": "public double myPow(double x, int n) {\n    if (n < 0) {\n        return 1.0 / power(x, -1L * n);\n    }\n    return power(x, n);\n}\n\nprivate double power(double x, long n) {\n    if (n == 0) return 1.0;\n    if (n == 1) return x;\n    if (n % 2 == 0) {\n        return power(x * x, n / 2);\n    }\n    return x * power(x, n - 1);\n}"
  },
  {
    "name": "Power Set (All Subsets)",
    "endpoint": "/api/recursion/power-set",
    "methodName": "powerSet",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets and can be returned in any order. A subset is a collection of elements derived from another set by deleting some (possibly zero) elements without changing the order of the remaining elements. For example, with input [1,2,3], the output would be [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]. This includes the empty set [], all individual elements [1], [2], [3], all pairs [1,2], [1,3], [2,3], and the full set [1,2,3]. For n elements, there will be 2^n total subsets.",
    "approach": "1. Use recursion with backtracking to generate all 2^n possible subsets\n2. At each element, we have two choices: include it in current subset or exclude it\n3. Base case: when we reach end of array, add current subset to result\n4. First recurse excluding current element, then include it and recurse again\n5. Use backtracking to remove element after including it to explore other possibilities\n6. This systematically explores all combinations of including/excluding each element",
    "code": "public List<List<Integer>> powerSet(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    List<Integer> current = new ArrayList<>();\n    backtrack(0, nums.length, nums, current, ans);\n    return ans;\n}\n\nprivate void backtrack(int index, int n, int[] nums, List<Integer> current, List<List<Integer>> ans) {\n    if (index == n) {\n        ans.add(new ArrayList<>(current));\n        return;\n    }\n    backtrack(index + 1, n, nums, current, ans);\n    current.add(nums[index]);\n    backtrack(index + 1, n, nums, current, ans);\n    current.remove(current.size() - 1);\n}"
  },
  {
    "name": "N-Queens Problem",
    "endpoint": "/api/recursion/solve-n-queens",
    "methodName": "solveNQueens",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "n": 4 },
    "description": "The N-Queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. A queen can attack horizontally, vertically, or diagonally. Given an integer n, return all distinct solutions to the N-Queens puzzle as a list of board configurations. Each solution is represented as a list of strings, where each string represents a row and 'Q' marks a queen's position while '.' marks an empty position. For example, for n=4, one possible solution is [['.Q..', '...Q', 'Q...', '..Q.']], visualized as:\n.Q..\n...Q\nQ...\n..Q.\nFor n=4, there are 2 distinct solutions total.",
    "approach": "1. Use recursion with backtracking to place queens row by row on the chessboard\n2. For each row, try placing a queen in each column and check if position is safe\n3. A position is safe if no other queen can attack it (no conflicts in column, diagonal, anti-diagonal)\n4. Base case: if we've successfully placed queens in all n rows, add board configuration to result\n5. After placing a queen, recursively try to place remaining queens in subsequent rows\n6. If placement fails, backtrack by removing queen and trying next column position",
    "code": "public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(board[i], '.');\n    }\n    solveNQueensHelper(0, board, result);\n    return result;\n}\n\nprivate void solveNQueensHelper(int row, char[][] board, List<List<String>> result) {\n    if (row == board.length) {\n        List<String> solution = new ArrayList<>();\n        for (char[] rowArray : board) {\n            solution.add(new String(rowArray));\n        }\n        result.add(solution);\n        return;\n    }\n    \n    for (int col = 0; col < board.length; col++) {\n        if (isNQueensSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueensHelper(row + 1, board, result);\n            board[row][col] = '.';\n        }\n    }\n}\n\nprivate boolean isNQueensSafe(char[][] board, int row, int col) {\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n    \n    return true;\n}"
  },
  {
    "name": "Sudoku Solver",
    "endpoint": "/api/recursion/solve-sudoku",
    "methodName": "solveSudoku",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "board": [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] },
    "description": "Write a program to solve a Sudoku puzzle by filling the empty cells (represented by '.') with digits 1-9. A Sudoku solution must satisfy all the following rules: 1) Each of the digits 1-9 must occur exactly once in each row, 2) Each of the digits 1-9 must occur exactly once in each column, 3) Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The input is a 9×9 grid with some cells already filled with digits and others empty (marked as '.'). For example, given a board with some initial values like '5' in the top-left cell and '3' next to it, your solution should find a valid filling for all empty cells that satisfies all Sudoku constraints.",
    "approach": "1. Use recursion with backtracking to fill empty cells one by one\n2. Scan board from top-left to find first empty cell (marked with '.')\n3. For each empty cell, try placing digits 1-9 and check if placement is valid\n4. A placement is valid if digit doesn't appear in same row, column, or 3x3 sub-box\n5. If placement is valid, place digit and recursively solve remaining puzzle\n6. If recursive call succeeds, puzzle is solved; otherwise backtrack by removing digit and try next",
    "code": "public char[][] solveSudoku(char[][] board) {\n    solve(board);\n    return board;\n}\n\nprivate boolean solve(char[][] board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isSudokuSafe(board, i, j, c)) {\n                        board[i][j] = c;\n                        if (solve(board))\n                            return true;\n                        else\n                            board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate boolean isSudokuSafe(char[][] board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c)\n            return false;\n        if (board[row][i] == c)\n            return false;\n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\n            return false;\n    }\n    return true;\n}"
  },
  {
    "name": "Subsets With Duplicates",
    "endpoint": "/api/recursion/subsets-with-dup",
    "methodName": "subsetsWithDup",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 2] },
    "description": "Given an integer array that may contain duplicates, return all possible subsets (the power set) without duplicate subsets. The solution set must not contain duplicate subsets, and the subsets can be returned in any order. For example, with input [1,2,2], the output would be [[], [1], [2], [1,2], [2,2], [1,2,2]]. Note that [2] appears only once in the output even though there are two 2's in the input, and [1,2] represents including the first 2. In contrast, [2,2] means including both 2's. With input [1,2,2,3], possible subsets would include [], [1], [2], [3], [1,2], [1,3], [2,3], [2,2], [1,2,2], [2,2,3], [1,2,3], [1,2,2,3].",
    "approach": "1. Sort the input array first to handle duplicates systematically\n2. Use recursion with backtracking, similar to generating power set but with duplicate handling\n3. Add current subset to result at beginning of each recursive call (including empty subset)\n4. For each remaining element, decide whether to include it in current subset\n5. Skip duplicate elements at same recursion level using: if (i > index && nums[i] == nums[i-1]) continue\n6. This ensures we generate each unique subset exactly once even with duplicate input elements",
    "code": "public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    subsetsWithDupHelper(0, nums, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void subsetsWithDupHelper(int index, int[] nums, List<Integer> current, List<List<Integer>> result) {\n    result.add(new ArrayList<>(current));\n    \n    for (int i = index; i < nums.length; i++) {\n        if (i > index && nums[i] == nums[i - 1]) continue;\n        current.add(nums[i]);\n        subsetsWithDupHelper(i + 1, nums, current, result);\n        current.remove(current.size() - 1);\n    }\n}"
  },
  {
    "name": "Subset Sums",
    "endpoint": "/api/recursion/subset-sums",
    "methodName": "subsetSums",
    "serviceFile": "RecursionService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Given an array of integers, return a sorted list containing the sums of all possible subsets of the array. A subset is formed by selecting zero or more elements from the array without changing their order. For example, with input [1,2,3], the output would be [0,1,2,3,3,4,5,6]. This is because: empty subset [] sums to 0, subset [1] sums to 1, subset [2] sums to 2, subset [3] sums to 3, subset [1,2] sums to 3, subset [1,3] sums to 4, subset [2,3] sums to 5, and subset [1,2,3] sums to 6. For n elements, there will be 2^n different subset sums (though some values may be repeated).",
    "approach": "1. Use recursion to generate all possible subsets and collect their sums\n2. At each element, we have two choices: include it in current sum or exclude it\n3. Base case: when we reach end of array, add current accumulated sum to result list\n4. First recurse including current element (add to sum), then recurse excluding it (keep sum same)\n5. This generates all 2^n possible subset sums including empty subset (sum = 0)\n6. The recursive tree explores all combinations of including/excluding each element",
    "code": "public List<Integer> subsetSums(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    func(0, 0, nums, ans);\n    return ans;\n}\n\nprivate void func(int ind, int sum, int[] nums, List<Integer> ans) {\n    if (ind == nums.length) {\n        ans.add(sum);\n        return;\n    }\n    func(ind + 1, sum + nums[ind], nums, ans);\n    func(ind + 1, sum, nums, ans);\n}"
  }
]