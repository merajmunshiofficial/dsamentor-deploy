[
  {
    "name": "Divide Two Integers Without Multiplication or Division",
    "endpoint": "/api/bit-manipulation/divide",
    "methodName": "divide",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "dividend": 10, "divisor": 3 },
    "description": "Divide two integers without using multiplication or division.",
    "approach": "1. The problem requires us to find the quotient of two integers without using multiplication or division operators.\n2. We can solve this using a bit manipulation approach that simulates the long division process we learn in elementary school.\n3. First, handle the special cases:\n   a. If dividend equals divisor, return 1.\n   b. Determine the sign of the result based on the signs of dividend and divisor.\n   c. Use absolute values to work with positive numbers for simplicity.\n4. The main algorithm uses the following steps:\n   a. While the dividend is greater than or equal to the divisor, find the largest power of 2 (let's call it p) such that (divisor << p) <= dividend.\n   b. Add (1 << p) to the quotient (this represents adding 2^p to the result).\n   c. Subtract (divisor * 2^p) from the dividend.\n   d. Repeat until the dividend becomes smaller than the divisor.\n5. This approach works because we're effectively finding how many times divisor can fit into dividend, but doing it efficiently by finding the largest chunks at each step.\n6. For example, dividing 22 by 3:\n   - 3 << 2 = 12 fits into 22, so add 4 to result, subtract 12 from 22 = 10 remaining\n   - 3 << 1 = 6 fits into 10, so add 2 to result, subtract 6 from 10 = 4 remaining\n   - 3 << 0 = 3 fits into 4, so add 1 to result, subtract 3 from 4 = 1 remaining\n   - 1 < 3, so we're done, quotient is 4 + 2 + 1 = 7\n7. Handle overflow cases as specified by the problem constraints (like Integer.MIN_VALUE / -1).\n8. Time Complexity: O(log n) where n is the dividend, as we're essentially finding powers of 2.\n9. Space Complexity: O(1) as we only use constant extra space.",
    "code": "public int divide(int dividend, int divisor) {\n    if(dividend == divisor) return 1;\n    boolean isPositive = true;\n    if(dividend >= 0 && divisor < 0) \n        isPositive = false;\n    else if(dividend < 0 && divisor > 0)\n        isPositive = false;\n    int n = Math.abs(dividend);\n    int d = Math.abs(divisor);\n    int ans = 0;\n    while(n >= d) {\n        int count = 0;\n        while(n >= (d << (count+1))) {\n            count++;\n        }\n        ans += (1 << count);\n        n -= d*(1 << count);\n    }\n    if(ans > Integer.MAX_VALUE && isPositive) \n        return Integer.MAX_VALUE;\n    if(ans > Integer.MAX_VALUE && !isPositive)\n        return Integer.MIN_VALUE;\n    return isPositive ? ans : -1*ans;\n}"
  },
  {
    "name": "Single Number (All Others Appear Twice)",
    "endpoint": "/api/bit-manipulation/single-number",
    "methodName": "singleNumber",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "nums": [2, 2, 1] },
    "description": "Find the single number that appears once in an array where all others appear twice.",
    "approach": "1. The problem asks us to find the single number in an array where every other number appears exactly twice.\n2. A straightforward approach would involve using a hash map to count occurrences, but that would require O(n) extra space.\n3. The optimal solution uses the XOR (exclusive or) operation, which has the following key properties:\n   a. XOR of a number with itself is 0: a ^ a = 0\n   b. XOR is commutative: a ^ b = b ^ a\n   c. XOR is associative: (a ^ b) ^ c = a ^ (b ^ c)\n   d. XOR with 0 gives the original number: a ^ 0 = a\n4. The algorithm works as follows:\n   a. Initialize a variable XOR to 0\n   b. Iterate through the array and XOR each element with the running XOR value\n   c. Due to the properties of XOR, elements that appear twice will cancel out (become 0)\n   d. The final XOR value will be the single element that appears only once\n5. For example, with array [2, 2, 1]:\n   - Start with XOR = 0\n   - XOR = 0 ^ 2 = 2\n   - XOR = 2 ^ 2 = 0 (the two 2's cancel out)\n   - XOR = 0 ^ 1 = 1\n   - Result is 1, which is the single number\n6. This approach has excellent performance metrics:\n   - Time Complexity: O(n) where n is the size of the array\n   - Space Complexity: O(1) as we only use a single variable regardless of input size\n7. This bitwise approach is not only efficient but elegant, as it leverages the mathematical properties of XOR to solve the problem in a single pass without extra space.",
    "code": "public int singleNumber(int[] nums) {\n    int XOR = 0;\n    for (int i = 0; i < nums.length; i++) {\n        XOR ^= nums[i];    \n    }\n    return XOR;        \n}"
  },
  {
    "name": "Single Number II (All Others Appear Thrice)",
    "endpoint": "/api/bit-manipulation/single-number-ii",
    "methodName": "singleNumberII",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "nums": [2, 2, 3, 2] },
    "description": "Find the single number that appears once in an array where all others appear three times.",
    "approach": "1. This problem extends the concept from Single Number I but with elements appearing three times instead of twice.\n2. The simple XOR approach won't work here, as XOR cancels out elements that appear twice, not three times.\n3. We need to track which bits have appeared 1 time, 2 times, or 3 times, and then reset the count when a bit appears for the 3rd time.\n4. The solution uses a clever bit manipulation technique that implements a state machine:\n   a. Use two variables, 'ones' and 'twos', to track the bits that have appeared once and twice respectively.\n   b. For each number in the array:\n      i. Update 'ones' to include new bits that appear for the first time and exclude bits that appear for the third time.\n      ii. Update 'twos' to include bits that have appeared twice and exclude bits that appear for the third time.\n5. The state transitions work as follows:\n   a. When a bit appears for the first time: It gets set in 'ones' but not in 'twos'.\n   b. When a bit appears for the second time: It gets cleared from 'ones' and set in 'twos'.\n   c. When a bit appears for the third time: It gets cleared from both 'ones' and 'twos'.\n6. After processing all numbers, 'ones' will contain the bits of the number that appears only once.\n7. The expression (ones ^ nums[i] & ~twos) does the following:\n   a. XOR the current bit with the incoming bit (ones ^ nums[i]).\n   b. But only keep the result if this bit hasn't appeared twice already (~twos).\n8. Similarly, (twos ^ nums[i] & ~ones) updates the bits that have appeared twice.\n9. This implementation is elegant and maintains O(1) space complexity while handling the three-occurrence pattern.\n10. Time Complexity: O(n) where n is the size of the array.\n11. Space Complexity: O(1) as we only use two integer variables regardless of input size.",
    "code": "public int singleNumberII(int[] nums) {\n    int ones = 0, twos = 0;\n    for (int i = 0; i < nums.length; i++) {\n        ones = (ones ^ nums[i] & ~twos);\n        twos = (twos ^ nums[i] & ~ones);\n    }\n    return ones;\n}"
  },
  {
    "name": "Single Number III (Two Singles, All Others Appear Twice)",
    "endpoint": "/api/bit-manipulation/single-number-iii",
    "methodName": "singleNumberIII",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "nums": [1, 2, 1, 3, 2, 5] },
    "description": "Find two single numbers that appear once in an array where all others appear twice.",
    "approach": "1. This problem is an extension of the Single Number problem, but here we need to find two numbers that appear only once while all others appear twice.\n2. Using a simple XOR of all elements won't directly give us the answer, as it would combine the two unique numbers.\n3. The key insight is that the XOR of all elements will give us (a ^ b), where a and b are our two unique numbers.\n4. Since a and b are different, their XOR will have at least one bit set to 1, indicating a position where they differ.\n5. The algorithm works in two phases:\n   a. First, calculate the XOR of all elements in the array, which gives us (a ^ b).\n   b. Find any set bit in this XOR result (a position where a and b differ).\n   c. Use this bit to divide all numbers in the array into two groups:\n      i. Numbers with this bit set to 1\n      ii. Numbers with this bit set to 0\n   d. Since each duplicate number appears twice, both copies will go into the same group.\n   e. More importantly, a and b will go into different groups because they differ at this bit position.\n   f. Now, XOR all numbers in each group separately to find a and b.\n6. To find a set bit position efficiently, the code uses a clever bit manipulation trick: (XOR & (XOR - 1)) ^ XOR.\n   a. (XOR & (XOR - 1)) clears the rightmost set bit in XOR.\n   b. XORing this with XOR isolates just that rightmost set bit.\n7. After dividing the numbers and calculating the two separate XORs, the final step sorts the results to ensure consistent output ordering.\n8. Time Complexity: O(n) where n is the size of the array.\n9. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public int[] singleNumberIII(int[] nums) {\n    int n = nums.length;\n    long XOR = 0;\n    for(int i=0; i < n; i++) {\n        XOR = XOR ^ nums[i];\n    }\n    int rightmost = (int)(XOR & (XOR - 1)) ^ (int)XOR;\n    int XOR1 = 0, XOR2 = 0;\n    for(int i=0; i < n; i++) {\n        if((nums[i] & rightmost) != 0) {\n            XOR1 = XOR1 ^ nums[i];\n        }\n        else {\n            XOR2 = XOR2 ^ nums[i];\n        }\n    }\n    if(XOR1 < XOR2) return new int[]{XOR1, XOR2};\n    return new int[]{XOR2, XOR1};\n}"
  },
  {
    "name": "Power Set (All Subsets)",
    "endpoint": "/api/bit-manipulation/power-set",
    "methodName": "powerSet",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "nums": [1, 2, 3] },
    "description": "Generate all possible subsets (power set) of an array.",
    "approach": "1. The problem requires generating all possible subsets (the power set) of a given array.\n2. For an array of size n, there are exactly 2^n possible subsets, ranging from the empty set to the full set.\n3. We can elegantly solve this using bit manipulation, leveraging the binary representation of numbers to represent subset membership:\n   a. For an array of size n, we generate all numbers from 0 to 2^n - 1 (represented as (1 << n) - 1 in code).\n   b. Each number's binary representation serves as a mask indicating which elements to include in a subset.\n   c. If the ith bit in the mask is set (1), we include the ith element from the array; if it's 0, we exclude it.\n4. The algorithm works as follows:\n   a. Calculate the total number of subsets as 2^n (represented as 1 << n).\n   b. Iterate from 0 to 2^n - 1, with each number representing a unique combination:\n      i. For each number, check which bits are set in its binary representation.\n      ii. For each set bit at position i, include the corresponding element nums[i] in the current subset.\n      iii. Add the constructed subset to the result list.\n5. For example, with [1, 2, 3]:\n   - 0 (binary: 000) represents {} (empty subset)\n   - 1 (binary: 001) represents {1}\n   - 2 (binary: 010) represents {2}\n   - 3 (binary: 011) represents {1, 2}\n   - 4 (binary: 100) represents {3}\n   - 5 (binary: 101) represents {1, 3}\n   - 6 (binary: 110) represents {2, 3}\n   - 7 (binary: 111) represents {1, 2, 3}\n6. This bit manipulation approach is both elegant and efficient:\n   - Time Complexity: O(n * 2^n) where n is the size of the array\n   - Space Complexity: O(n * 2^n) to store all subsets\n7. This method is significantly more efficient than recursive approaches for small to medium-sized inputs.",
    "code": "public List<List<Integer>> powerSet(int[] nums) {\n    int n = nums.length;\n    List<List<Integer>> ans = new ArrayList<>();\n    int count = (1 << n);\n    for (int val = 0; val < count; val++) {\n        List<Integer> subset = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if ((val & (1 << i)) != 0) {\n                subset.add(nums[i]);\n            }\n        }\n        ans.add(subset);\n    }\n    return ans;\n}"
  },
  {
    "name": "Range XOR (L to R)",
    "endpoint": "/api/bit-manipulation/find-range-xor",
    "methodName": "findRangeXOR",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "l": 2, "r": 5 },
    "description": "Find XOR of numbers from L to R.",
    "approach": "1. The problem requires finding the XOR of all integers from L to R (inclusive).\n2. A naive approach would iterate from L to R, calculating the XOR, but this would be inefficient for large ranges.\n3. Instead, we leverage a mathematical property: XOR(L to R) = XOR(1 to R) ⊕ XOR(1 to L-1)\n   - This is because XOR is its own inverse (a ⊕ a = 0), so any number that appears in both ranges cancels out.\n4. For calculating XOR from 1 to n efficiently, we observe a pattern in the XOR results:\n   - XOR from 1 to n follows a cyclic pattern with a period of 4:\n     * If n % 4 = 0, then XOR(1 to n) = n\n     * If n % 4 = 1, then XOR(1 to n) = 1\n     * If n % 4 = 2, then XOR(1 to n) = n+1\n     * If n % 4 = 3, then XOR(1 to n) = 0\n5. This pattern allows us to calculate the XOR of any range in O(1) time, regardless of the size of the range.\n6. For example, to find XOR from 2 to 5:\n   - XOR(1 to 5) = 1 (since 5 % 4 = 1)\n   - XOR(1 to 1) = 1\n   - XOR(2 to 5) = XOR(1 to 5) ⊕ XOR(1 to 1) = 1 ⊕ 1 = 0\n7. The implementation has two functions:\n   a. findRangeXOR(l, r): Applies the formula XOR(L to R) = XOR(1 to R) ⊕ XOR(1 to L-1).\n   b. XORtillN(n): Uses the pattern to efficiently calculate XOR from 1 to n in O(1) time.\n8. Time Complexity: O(1) regardless of the range size.\n9. Space Complexity: O(1) as we use only constant extra space.\n10. This approach showcases how understanding mathematical properties can lead to highly optimized solutions.",
    "code": "public int findRangeXOR(int l, int r) {\n    return XORtillN(l - 1) ^ XORtillN(r);\n}\n\nprivate int XORtillN(int n) {\n    if(n % 4 == 1) return 1;\n    if(n % 4 == 2) return n + 1;\n    if(n % 4 == 3) return 0;\n    return n;\n}"
  },
  {
    "name": "Minimum Bit Flips to Convert Start to Goal",
    "endpoint": "/api/bit-manipulation/min-bits-flip",
    "methodName": "minBitsFlip",
    "serviceFile": "BitManipulationService.java",
    "defaultInput": { "start": 10, "goal": 7 },
    "description": "Find minimum number of bit flips to convert start to goal.",
    "approach": "1. The problem asks for the minimum number of bit flips required to convert one integer (start) to another (goal).\n2. A bit flip changes a 0 to 1 or a 1 to 0 at a specific position in the binary representation.\n3. The key insight is that we only need to flip bits where the two numbers differ. If bits at the same position are identical, no flip is needed.\n4. We can use the XOR operation to identify positions where bits differ:\n   a. When we XOR two numbers, the result has 1s in positions where the bits differ and 0s where they are the same.\n   b. Therefore, the number of 1s in (start ^ goal) equals the number of bit flips needed.\n5. The algorithm works as follows:\n   a. Compute XOR of start and goal to get a number where set bits indicate differing positions.\n   b. Count the number of set bits (1s) in this XOR result.\n6. For counting set bits, we use a standard bit manipulation technique:\n   a. Check if the least significant bit is 1 using (num & 1).\n   b. Right shift the number by 1 position to examine the next bit.\n   c. Repeat for all bits (up to 32 bits for integers in Java).\n7. For example, to convert 10 (binary: 1010) to 7 (binary: 0111):\n   - XOR result: 1010 ^ 0111 = 1101 (3 bits differ)\n   - Count of set bits in 1101 is 3, so 3 bit flips are needed.\n8. Time Complexity: O(1) since we always process 32 bits for an integer.\n9. Space Complexity: O(1) as we use only constant extra space.\n10. This approach is both elegant and optimal, as there's no way to convert between the two numbers with fewer bit flips.",
    "code": "public int minBitsFlip(int start, int goal) {\n    int num = start ^ goal;\n    int count = 0;\n    for (int i = 0; i < 32; i++) {\n        count += (num & 1); \n        num = num >> 1;\n    }\n    return count;\n}"
  }
]