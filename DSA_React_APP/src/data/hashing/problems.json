[
  {
    "name": "Longest Consecutive Sequence",
    "endpoint": "/api/hashing/longest-consecutive",
    "methodName": "longestConsecutive",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [100, 4, 200, 1, 3, 2] },
    "description": "Find the length of the longest consecutive elements sequence in an array.",
    "approach": "1. This problem requires finding the longest consecutive sequence of integers in an unsorted array.\n2. A naive approach would be to sort the array and then find consecutive sequences, but this would take O(n log n) time.\n3. Using a HashSet allows us to solve this more efficiently in O(n) time:\n   a. Insert all array elements into a HashSet for O(1) lookup time.\n   b. For each element in the HashSet:\n      - Check if it's the start of a sequence by verifying that (element-1) is not in the set.\n      - If it's a sequence start, count consecutive elements by checking if (element+1), (element+2), etc. exist in the set.\n      - Update the longest sequence length found so far.\n4. The key optimization is only starting sequence checks from potential sequence beginnings (where num-1 is not present).\n5. This ensures each element is part of at most one sequence check, giving us O(n) time complexity overall.\n6. Steps in detail:\n   a. Add all array elements to a HashSet.\n   b. For each element in the set, if it's a potential sequence start (num-1 not in set):\n      - Initialize count to 1 and start checking consecutive elements.\n      - While (num+count) exists in the set, increment count.\n      - Update the longest sequence found so far.\n7. Time Complexity: O(n) where n is the number of elements in the array.\n   - Each element is added to the HashSet once: O(n).\n   - Each element is checked at most twice: once as a potential sequence start and once as part of a sequence: O(n).\n8. Space Complexity: O(n) for the HashSet storing all unique elements.",
    "code": "public int longestConsecutive(int[] nums) {\n    int n = nums.length;\n    if (n == 0) return 0;\n    int longest = 1;\n    Set<Integer> st = new HashSet<>();\n    for (int i = 0; i < n; i++) {\n        st.add(nums[i]);\n    }\n    for (int it : st) {\n        if (!st.contains(it - 1)) {\n            int cnt = 1;\n            int x = it;\n            while (st.contains(x + 1)) {\n                x = x + 1;\n                cnt = cnt + 1;\n            }\n            longest = Math.max(longest, cnt);\n        }\n    }\n    return longest;\n}"
  },
  {
    "name": "Subarrays with Given Sum",
    "endpoint": "/api/hashing/subarray-sum",
    "methodName": "subarraySum",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [1, 2, 3], "k": 3 },
    "description": "Find the total number of continuous subarrays whose sum equals k.",
    "approach": "1. This problem requires finding the number of continuous subarrays with sum equal to k.\n2. The approach uses the concept of prefix sums combined with a HashMap to efficiently find these subarrays.\n3. A prefix sum at index i represents the sum of all elements from index 0 to i.\n4. The key insight: If we have a prefix sum prefixSum at the current position and we've seen a prefix sum (prefixSum - k) earlier, then the subarray between these positions has a sum of k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix sums and their frequencies, with an entry (0, 1) for empty subarrays.\n   b. Iterate through the array, calculating the running prefix sum.\n   c. For each position:\n      - Check if (currentPrefixSum - k) exists in the map. If it does, add its frequency to the count of valid subarrays.\n      - Update the frequency of the current prefix sum in the map.\n6. The use of a HashMap allows us to efficiently check for the existence of previous prefix sums in O(1) time.\n7. Examples:\n   - For array [1, 2, 3] and k = 3:\n     * At i=0: prefixSum=1, need prefixSum-k=-2 (not found), add (1,1) to map\n     * At i=1: prefixSum=3, need prefixSum-k=0 (found with freq 1), count=1, add (3,1) to map\n     * At i=2: prefixSum=6, need prefixSum-k=3 (found with freq 1), count=2, add (6,1) to map\n     * Final count: 2 ([1,2], [3])\n8. Time Complexity: O(n) where n is the number of elements in the array.\n9. Space Complexity: O(n) for the HashMap storing prefix sums.",
    "code": "public int subarraySum(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n    int currentPrefixSum = 0, subarrayCount = 0;\n    prefixSumMap.put(0, 1);\n    for (int i = 0; i < n; i++) {\n        currentPrefixSum += nums[i];\n        int sumToRemove = currentPrefixSum - k;\n        subarrayCount += prefixSumMap.getOrDefault(sumToRemove, 0);\n        prefixSumMap.put(currentPrefixSum, prefixSumMap.getOrDefault(currentPrefixSum, 0) + 1);\n    }\n    return subarrayCount;\n}"
  },
  {
    "name": "Longest Subarray with Given Sum",
    "endpoint": "/api/hashing/longest-subarray",
    "methodName": "longestSubarray",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [10, 5, 2, 7, 1, 9], "k": 15 },
    "description": "Find the length of the longest subarray with sum equal to k.",
    "approach": "1. This problem requires finding the length of the longest subarray with sum equal to k.\n2. The approach uses prefix sums with a HashMap to efficiently track potential subarrays.\n3. A prefix sum at index i represents the sum of all elements from index 0 to i.\n4. The key insight: If we have a prefix sum prefixSum at the current position and we've seen a prefix sum (prefixSum - k) earlier, then the subarray between these positions has a sum of k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix sums and their earliest occurrence indices.\n   b. Iterate through the array, calculating the running prefix sum.\n   c. For each position i:\n      - If the current prefix sum equals k, then the subarray from index 0 to i has sum k (update maxLength to i+1).\n      - Check if (currentPrefixSum - k) exists in the map. If it does, calculate the length of this subarray and update maxLength if needed.\n      - Store the current prefix sum in the map ONLY if it doesn't already exist (to keep the earliest occurrence).\n6. Unlike the subarray count problem, we need to track the earliest occurrence of each prefix sum to find the longest subarray.\n7. The special case check for prefixSum == k handles subarrays that start from the beginning of the array.\n8. Examples:\n   - For array [10, 5, 2, 7, 1, 9] and k = 15:\n     * At i=0: prefixSum=10, not equal to k, add (10,0) to map\n     * At i=1: prefixSum=15, equal to k, maxLength=2, add (15,1) to map\n     * At i=2: prefixSum=17, check for prefixSum-k=2 (not found), add (17,2) to map\n     * At i=3: prefixSum=24, check for prefixSum-k=9 (not found), add (24,3) to map\n     * At i=4: prefixSum=25, check for prefixSum-k=10 (found at index 0), length=4, maxLength=4, add (25,4) to map\n     * At i=5: prefixSum=34, check for prefixSum-k=19 (not found), add (34,5) to map\n     * Final maxLength: 4 (subarray [5,2,7,1])\n9. Time Complexity: O(n) where n is the number of elements in the array.\n10. Space Complexity: O(n) for the HashMap storing prefix sums.",
    "code": "public int longestSubarray(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n    int currentPrefixSum = 0, maxLength = 0;\n    for (int i = 0; i < n; i++) {\n        currentPrefixSum += nums[i];\n        if (currentPrefixSum == k) {\n            maxLength = i + 1;\n        }\n        if (prefixSumMap.containsKey(currentPrefixSum - k)) {\n            maxLength = Math.max(maxLength, i - prefixSumMap.get(currentPrefixSum - k));\n        }\n        if (!prefixSumMap.containsKey(currentPrefixSum)) {\n            prefixSumMap.put(currentPrefixSum, i);\n        }\n    }\n    return maxLength;\n}"
  },
  {
    "name": "Subarrays with XOR Equal to K",
    "endpoint": "/api/hashing/subarrays-with-xor-k",
    "methodName": "subarraysWithXorK",
    "serviceFile": "HashingService.java",
    "defaultInput": { "nums": [4, 2, 2, 6, 4], "k": 6 },
    "description": "Find the number of subarrays with XOR equal to k.",
    "approach": "1. This problem requires finding the number of subarrays with XOR equal to k.\n2. The approach uses prefix XORs with a HashMap in a similar way to the prefix sum problems.\n3. A prefix XOR at index i represents the XOR of all elements from index 0 to i.\n4. The key mathematical insight: If we have a prefix XOR prefixXOR at the current position and we need to find subarrays with XOR equal to k, then we need to find earlier positions with prefix XOR equal to (prefixXOR ⊕ k).\n   - This is because if prefix XOR of [0...i] is P1 and prefix XOR of [0...j] is P2 (j < i), then XOR of subarray [j+1...i] is P1 ⊕ P2.\n   - So, if we want this subarray XOR to be k, then P1 ⊕ P2 = k, which means P2 = P1 ⊕ k.\n5. Steps of the algorithm:\n   a. Initialize a HashMap to store prefix XORs and their frequencies, with an entry (0, 1) for empty subarrays.\n   b. Iterate through the array, calculating the running prefix XOR.\n   c. For each position:\n      - Calculate xorToRemove = currentXor ⊕ k.\n      - Check if xorToRemove exists in the map. If it does, add its frequency to the count of valid subarrays.\n      - Update the frequency of the current prefix XOR in the map.\n6. Examples:\n   - For array [4, 2, 2, 6, 4] and k = 6:\n     * At i=0: prefixXOR=4, need prefixXOR⊕k=4⊕6=2 (not found), add (4,1) to map\n     * At i=1: prefixXOR=4⊕2=6, need prefixXOR⊕k=6⊕6=0 (found with freq 1), count=1, add (6,1) to map\n     * At i=2: prefixXOR=6⊕2=4, need prefixXOR⊕k=4⊕6=2 (not found), update (4,2) in map\n     * At i=3: prefixXOR=4⊕6=2, need prefixXOR⊕k=2⊕6=4 (found with freq 2), count=3, add (2,1) to map\n     * At i=4: prefixXOR=2⊕4=6, need prefixXOR⊕k=6⊕6=0 (found with freq 1), count=4, update (6,2) in map\n     * Final count: 4\n7. Time Complexity: O(n) where n is the number of elements in the array.\n8. Space Complexity: O(n) for the HashMap storing prefix XORs.",
    "code": "public int subarraysWithXorK(int[] nums, int k) {\n    int n = nums.length;\n    HashMap<Integer, Integer> xorMap = new HashMap<>();\n    int currentXor = 0, subarrayCount = 0;\n    xorMap.put(0, 1);\n    for (int i = 0; i < n; i++) {\n        currentXor ^= nums[i];\n        int xorToRemove = currentXor ^ k;\n        subarrayCount += xorMap.getOrDefault(xorToRemove, 0);\n        xorMap.put(currentXor, xorMap.getOrDefault(currentXor, 0) + 1);\n    }\n    return subarrayCount;\n}"
  }
]