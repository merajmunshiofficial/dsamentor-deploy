[
  {
    "name": "Bubble Sort",
    "endpoint": "/api/sorting/bubble-sort",
    "methodName": "bubbleSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [5, 1, 4, 2, 8] },
    "description": "Sort an array using the bubble sort algorithm.",
    "approach": "1. Bubble Sort is a simple comparison-based sorting algorithm.\n2. The algorithm works by comparing adjacent elements and swapping them if they are in the wrong order, causing larger elements to \"bubble up\" to the end of the array in each pass.\n3. Steps of the algorithm:\n   a. Start from the end of the array and work backwards through iterations.\n   b. For each iteration i, compare adjacent elements from index 0 to i-1.\n   c. If the current element is greater than the next element, swap them.\n   d. After each complete iteration, the largest unsorted element is guaranteed to be in its final position.\n   e. Use an optimization flag (isSwapped) to check if any swaps occurred in a pass. If no swaps occurred, the array is already sorted and we can break early.\n4. Time Complexity:\n   - Best Case: O(n) when the array is already sorted (detected by the isSwapped flag).\n   - Average and Worst Case: O(n²) when the array is in reverse order.\n5. Space Complexity: O(1) as it only requires a constant amount of extra space.\n6. Bubble sort is stable (maintains the relative order of equal elements) and in-place (requires no extra array).\n7. It's simple but inefficient for large datasets compared to more advanced sorting algorithms.",
    "code": "public int[] bubbleSort(int[] nums) {\n    int n = nums.length;\n    for (int i = n - 1; i >= 0; i--) {\n        boolean isSwapped = false;\n        for (int j = 0; j <= i - 1; j++) {\n            if (nums[j] > nums[j + 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j + 1];\n                nums[j + 1] = temp;\n                isSwapped = true;\n            }\n        }\n        if (!isSwapped) {\n            break;\n        }\n    }\n    return nums;\n}"
  },
  {
    "name": "Insertion Sort",
    "endpoint": "/api/sorting/insertion-sort",
    "methodName": "insertionSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [12, 11, 13, 5, 6] },
    "description": "Sort an array using the insertion sort algorithm.",
    "approach": "1. Insertion Sort builds the final sorted array one element at a time.\n2. It's similar to how we sort playing cards in our hands - we pick one card and insert it into its correct position among the already sorted cards.\n3. Steps of the algorithm:\n   a. Assume the first element is already sorted (a single-element array is always sorted).\n   b. For each unsorted element starting from the second element (index 1):\n      - Store the current element in a temporary variable (key).\n      - Shift all elements in the sorted portion that are greater than the key to the right.\n      - Insert the key into its correct position in the sorted portion.\n   c. Repeat until all elements are processed.\n4. Time Complexity:\n   - Best Case: O(n) when the array is already sorted (each element requires only one comparison).\n   - Average and Worst Case: O(n²) when the array is in reverse order (each element must be compared with each sorted element).\n5. Space Complexity: O(1) as it only requires a constant amount of extra space.\n6. Insertion sort is stable (maintains the relative order of equal elements) and in-place (requires no extra array).\n7. It performs well for small arrays or nearly sorted arrays, and is more efficient than bubble sort in practice.",
    "code": "public int[] insertionSort(int[] nums) {\n    int n = nums.length;\n    for (int i = 1; i < n; i++) {\n        int key = nums[i];\n        int j = i - 1;\n        while (j >= 0 && nums[j] > key) {\n            nums[j + 1] = nums[j];\n            j = j - 1;\n        }\n        nums[j + 1] = key;\n    }\n    return nums;\n}"
  },
  {
    "name": "Merge Sort",
    "endpoint": "/api/sorting/merge-sort",
    "methodName": "mergeSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [38, 27, 43, 3, 9, 82, 10] },
    "description": "Sort an array using the merge sort algorithm.",
    "approach": "1. Merge Sort is an efficient, divide-and-conquer sorting algorithm based on the principle of merging two sorted arrays.\n2. The algorithm divides the input array into two halves, recursively sorts them, and then merges the sorted halves.\n3. Steps of the algorithm:\n   a. Divide: If the array has more than one element, divide it into two halves.\n   b. Conquer: Recursively sort the two halves.\n   c. Merge: Merge the two sorted halves to produce a single sorted array.\n4. The merge operation:\n   - Create a temporary array to store the merged result.\n   - Use two pointers to track positions in the two halves.\n   - Compare elements from both halves and add the smaller element to the temporary array.\n   - After one half is exhausted, add all remaining elements from the other half.\n   - Copy the temporary array back to the original array.\n5. Time Complexity: O(n log n) for all cases (best, average, and worst).\n   - The division step takes O(log n) levels of recursion.\n   - Each level processes all n elements during merging.\n6. Space Complexity: O(n) for the temporary arrays used during merging.\n7. Merge sort is stable (maintains the relative order of equal elements).\n8. It's not in-place (requires additional space proportional to the array size).\n9. Merge sort is particularly efficient for large datasets and is often used as a component in other algorithms.",
    "code": "public int[] mergeSort(int[] arr) {\n    mergeSort(arr, 0, arr.length - 1);\n    return arr;\n}\n\nprivate void merge(int[] arr, int low, int mid, int high) {\n    List<Integer> temp = new ArrayList<>();\n    int left = low;\n    int right = mid + 1;\n    while (left <= mid && right <= high) {\n        if (arr[left] <= arr[right]) {\n            temp.add(arr[left]);\n            left++;\n        } else {\n            temp.add(arr[right]);\n            right++;\n        }\n    }\n    while (left <= mid) {\n        temp.add(arr[left]);\n        left++;\n    }\n    while (right <= high) {\n        temp.add(arr[right]);\n        right++;\n    }\n    for (int i = low; i <= high; i++) {\n        arr[i] = temp.get(i - low);\n    }\n}\n\nprivate void mergeSort(int[] arr, int low, int high) {\n    if (low >= high)\n        return;\n    int mid = (low + high) / 2;\n    mergeSort(arr, low, mid);\n    mergeSort(arr, mid + 1, high);\n    merge(arr, low, mid, high);\n}"
  },
  {
    "name": "Quick Sort",
    "endpoint": "/api/sorting/quick-sort",
    "methodName": "quickSort",
    "serviceFile": "SortingService.java",
    "defaultInput": { "nums": [10, 7, 8, 9, 1, 5] },
    "description": "Sort an array using the quick sort algorithm.",
    "approach": "1. Quick Sort is an efficient, divide-and-conquer sorting algorithm that uses a pivot element to partition the array.\n2. Steps of the algorithm:\n   a. Choose a pivot element from the array (in this implementation, the first element is chosen as the pivot).\n   b. Partition: Rearrange the array so that all elements less than or equal to the pivot come before it, and all elements greater than the pivot come after it. The pivot is now in its final sorted position.\n   c. Recursively apply the above steps to the sub-arrays formed on either side of the pivot.\n3. The partition process:\n   - Use two pointers i and j starting from low+1 and high respectively.\n   - Move i to the right until finding an element greater than pivot.\n   - Move j to the left until finding an element less than or equal to pivot.\n   - If i < j, swap the elements at i and j.\n   - Repeat until i crosses j.\n   - Finally, swap the pivot with the element at position j to place the pivot in its correct sorted position.\n4. Time Complexity:\n   - Best and Average Case: O(n log n)\n   - Worst Case: O(n²) when the array is already sorted and the first element is always chosen as pivot\n5. Space Complexity: O(log n) for the recursion stack in the average case, O(n) in the worst case.\n6. Quick sort is not stable (may change the relative order of equal elements) but is in-place (requires only O(log n) extra space for recursion).\n7. It's generally faster than other O(n log n) sorting algorithms in practice due to its cache-friendly behavior and lower constant factors.",
    "code": "public int[] quickSort(int[] arr) {\n    quickSort(arr, 0, arr.length - 1);\n    return arr;\n}\n\nprivate int partition(int[] arr, int low, int high) {\n    int pivot = arr[low];\n    int i = low;\n    int j = high;\n    while (i < j) {\n        while (i <= high - 1 && arr[i] <= pivot) {\n            i++;\n        }\n        while (j >= low + 1 && arr[j] > pivot) {\n            j--;\n        }\n        if (i < j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[low];\n    arr[low] = arr[j];\n    arr[j] = temp;\n    return j;\n}\n\nprivate void quickSort(int[] arr, int low, int high) {\n    if (low < high) {\n        int pIndex = partition(arr, low, high);\n        quickSort(arr, low, pIndex - 1);\n        quickSort(arr, pIndex + 1, high);\n    }\n}"
  }
]