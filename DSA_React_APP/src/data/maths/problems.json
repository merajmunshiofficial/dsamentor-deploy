[
  {
    "name": "Prime Factors of Numbers",
    "endpoint": "/api/maths/prime-factors",
    "methodName": "primeFactors",
    "serviceFile": "MathsService.java",
    "defaultInput": { "numbers": [12, 15, 100] },
    "description": "Given a list of integers, find the prime factorization of each number. The prime factorization is a list of prime numbers that, when multiplied together, give the original number. For example, for the number 12, the prime factors are [2, 2, 3] because 2 × 2 × 3 = 12. For 15, the prime factors are [3, 5] because 3 × 5 = 15. And for 100, the prime factors are [2, 2, 5, 5] because 2 × 2 × 5 × 5 = 100. The challenge is to efficiently compute the prime factors for multiple numbers, handling cases from small inputs to large numbers that may have complex factorizations. The output should be a list of lists, where each inner list contains the prime factors for the corresponding input number.",
    "approach": "1. Finding prime factors for multiple numbers can be optimized using a precomputation technique called the Sieve of Eratosthenes with a modification to track the Smallest Prime Factor (SPF) for each number.\n2. The algorithm has two main parts:\n   a. Preprocessing: Compute the smallest prime factor for each number up to a maximum value.\n   b. Factorization: For each query number, repeatedly divide by its smallest prime factor to get all prime factors.\n3. For preprocessing, we use a modified Sieve of Eratosthenes:\n   a. Initialize an array SPF where SPF[i] = 1 for all i.\n   b. For each number i from 2 to MAX_N:\n      i. If SPF[i] is still 1, it means i is prime.\n      ii. For all multiples j of i, if SPF[j] is still 1, set SPF[j] = i (indicating i is the smallest prime factor of j).\n   c. After this step, for any number n, SPF[n] will be its smallest prime factor (or 1 if n is 1).\n4. For factorization of a number n:\n   a. Look up SPF[n] to find its smallest prime factor.\n   b. Add this factor to our result list.\n   c. Divide n by SPF[n] to get a smaller number.\n   d. Repeat until n becomes 1.\n5. For multiple queries, we perform the preprocessing step only once, making subsequent factorizations very efficient.\n6. Example: For n = 12\n   - SPF[12] = 2, so add 2 to factors, n = 12/2 = 6\n   - SPF[6] = 2, so add 2 to factors, n = 6/2 = 3\n   - SPF[3] = 3, so add 3 to factors, n = 3/3 = 1\n   - n = 1, so we stop. Factors of 12 are [2, 2, 3]\n7. Time Complexity: O(MAX_N log log MAX_N) for preprocessing and O(log n) for each factorization.\n8. Space Complexity: O(MAX_N) for storing the SPF array.",
    "code": "private static final int MAX_N = 100000;\nprivate int[] SPF = new int[MAX_N + 1];\nprivate boolean sieveDone = false;\n\nprivate void sieve() {\n    if (sieveDone) return;\n    Arrays.fill(SPF, 1);\n    for (int i = 2; i <= MAX_N; i++) {\n        if (SPF[i] == 1) {\n            for (int j = i; j <= MAX_N; j += i) {\n                if (SPF[j] == 1) {\n                    SPF[j] = i;\n                }\n            }\n        }\n    }\n    sieveDone = true;\n}\n\nprivate List<Integer> primeFact(int n) {\n    List<Integer> ans = new ArrayList<>();\n    while (n != 1) {\n        ans.add(SPF[n]);\n        n = n / SPF[n];\n    }\n    return ans;\n}\n\npublic List<List<Integer>> primeFactors(List<Integer> numbers) {\n    sieve();\n    List<List<Integer>> ans = new ArrayList<>();\n    for (int n : numbers) {\n        ans.add(primeFact(n));\n    }\n    return ans;\n}"
  },
  {
    "name": "All Primes Up to N",
    "endpoint": "/api/maths/prime-till-n",
    "methodName": "primeTillN",
    "serviceFile": "MathsService.java",
    "defaultInput": { "n": 30 },
    "description": "Given a positive integer n, find all prime numbers less than or equal to n. A prime number is a natural number greater than 1 that is not divisible by any number other than 1 and itself. For example, if n = 30, the output should be [2, 3, 5, 7, 11, 13, 17, 19, 23, 29], which are all the prime numbers from 2 to 30. For n = 10, the output would be [2, 3, 5, 7]. The challenge is to efficiently identify all primes up to a potentially large value of n, without checking each number individually for primality. This is a fundamental problem in number theory with applications in cryptography, factorization, and other areas of mathematics and computer science.",
    "approach": "1. The problem asks for all prime numbers up to a given limit n.\n2. The most efficient way to find all primes up to a certain limit is using the Sieve of Eratosthenes algorithm, which is what we implement here.\n3. The Sieve of Eratosthenes works by iteratively marking the multiples of each prime number as composite (not prime):\n   a. Start with a boolean array `isPrime` of size n+1, initialized as all true.\n   b. Numbers 0 and 1 are not prime, but we can skip them since we start from 2.\n   c. Iterate from 2 to n:\n      i. If the current number i is marked as prime (isPrime[i] is true):\n         - Add i to our list of prime numbers.\n         - Mark all multiples of i as not prime, starting from i² (since all smaller multiples would have been marked by smaller primes already).\n      ii. If the current number is marked as not prime, skip it.\n4. This approach efficiently identifies all primes because:\n   a. Every composite number has a prime factorization.\n   b. We mark a number as composite only through its prime factors.\n   c. By the time we reach a number, all its prime factors have been processed.\n5. The optimization of starting from i² when marking multiples significantly reduces the number of operations.\n6. Example: For n = 10\n   - Start with [2,3,4,5,6,7,8,9,10] all marked as potentially prime\n   - Process 2: Add 2 to primes, mark 4,6,8,10 as not prime\n   - Process 3: Add 3 to primes, mark 9 as not prime\n   - Process 4: Already marked as not prime, skip\n   - Process 5: Add 5 to primes (no multiples to mark in our range)\n   - Process 6-10: Either already marked as not prime or no multiples in range\n   - Result: [2,3,5,7] are the primes up to 10\n7. Time Complexity: O(n log log n), which is very efficient for large n.\n8. Space Complexity: O(n) for the boolean array and the result list.",
    "code": "public List<Integer> primeTillN(int n) {\n    boolean[] isPrime = new boolean[n + 1];\n    Arrays.fill(isPrime, true);\n    List<Integer> ans = new ArrayList<>();\n    for (long i = 2; i <= n; i++) {\n        if (isPrime[(int) i]) {\n            ans.add((int) i);\n            for (long val = i * i; val <= n; val += i) {\n                isPrime[(int) val] = false;\n            }\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Count of Primes in Ranges",
    "endpoint": "/api/maths/primes-in-range",
    "methodName": "primesInRange",
    "serviceFile": "MathsService.java",
    "defaultInput": { "ranges": [[10, 20], [1, 10], [15, 30]] },
    "description": "Given multiple ranges defined by pairs of integers [start, end], determine the count of prime numbers within each range (inclusive of both start and end). For example, for the range [10, 20], the prime numbers are 11, 13, 17, and 19, so the count is 4. For the range [1, 10], the prime numbers are 2, 3, 5, and 7, so the count is 4. For the range [15, 30], the prime numbers are 17, 19, 23, and 29, so the count is also 4. The challenge is to efficiently compute these counts for multiple ranges without repeatedly checking each number for primality in each range. The solution should handle potentially large ranges and many range queries efficiently. This is a practical extension of the prime counting function from number theory.",
    "approach": "1. This problem asks us to find the count of prime numbers in multiple ranges [start, end].\n2. A naive approach would be to check each number in each range, but that would be inefficient for multiple queries.\n3. Instead, we use a two-step approach:\n   a. First, use the Sieve of Eratosthenes to identify all prime numbers up to the maximum end value across all ranges.\n   b. Then, use prefix sums to efficiently count primes in any range.\n4. The Sieve of Eratosthenes efficiently marks all prime numbers:\n   a. Create a boolean array `isPrime` of size maxVal+1, initially all set to true.\n   b. Iterate from 2 to sqrt(maxVal):\n      i. If isPrime[i] is true, mark all its multiples starting from i² as false (not prime).\n   c. After this process, isPrime[i] will be true only for prime numbers.\n5. The prefix sum technique allows us to answer range queries in O(1) time:\n   a. Create an array `primeCount` where primeCount[i] stores the count of primes from 1 to i.\n   b. For each i from 1 to maxVal, set primeCount[i] = primeCount[i-1] + (1 if i is prime, 0 otherwise).\n6. For each range query [start, end]:\n   a. The count of primes in the range is primeCount[end] - primeCount[start-1].\n   b. Handle the special case where start = 0 (return primeCount[end] directly).\n7. Example calculation:\n   - For range [10, 20], primes are 11, 13, 17, 19 (count = 4)\n   - For range [1, 10], primes are 2, 3, 5, 7 (count = 4)\n   - For range [15, 30], primes are 17, 19, 23, 29 (count = 4)\n8. Time Complexity: O(maxVal * log log maxVal) for the sieve + O(maxVal) for prefix sum + O(queries) for answering queries.\n9. Space Complexity: O(maxVal) for the isPrime and primeCount arrays.\n10. This approach is very efficient for multiple range queries as it performs the heavy computation only once.",
    "code": "public List<Integer> primesInRange(List<int[]> ranges) {\n    if (ranges == null || ranges.isEmpty()) {\n        return new ArrayList<>();\n    }\n    int maxVal = 0;\n    for (int[] query : ranges) {\n        maxVal = Math.max(maxVal, query[1]);\n    }\n    boolean[] isPrime = new boolean[maxVal + 1];\n    Arrays.fill(isPrime, true);\n    for (int i = 2; i * i <= maxVal; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= maxVal; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int[] primeCount = new int[maxVal + 1];\n    for (int i = 1; i <= maxVal; i++) {\n        primeCount[i] = primeCount[i - 1];\n        if (isPrime[i]) {\n            primeCount[i]++;\n        }\n    }\n    List<Integer> result = new ArrayList<>();\n    for (int[] query : ranges) {\n        int start = query[0];\n        int end = query[1];\n        if (start == 0) {\n            result.add(primeCount[end]);\n        } else {\n            result.add(primeCount[end] - primeCount[start - 1]);\n        }\n    }\n    return result;\n}"
  }
]