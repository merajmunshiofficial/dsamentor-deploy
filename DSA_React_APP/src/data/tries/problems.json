[
  {
    "name": "Count Distinct Substrings",
    "endpoint": "/api/tries/count-distinct",
    "methodName": "countDistinct",
    "serviceFile": "TriesService.java",
    "defaultInput": { "s": "ababa" },
    "description": "Count the number of distinct substrings in a given string using a trie.",
    "approach": "Insert all suffixes of the string into a trie and count the number of new nodes created.",
    "code": "static class Node26 {\n    Node26[] links = new Node26[26];\n    boolean containsKey(char ch) { return links[ch - 'a'] != null; }\n    void put(char ch, Node26 node) { links[ch - 'a'] = node; }\n    Node26 get(char ch) { return links[ch - 'a']; }\n}\n\npublic int countDistinct(String s) {\n    int c = 0;\n    Node26 root = new Node26();\n    for (int i = 0; i < s.length(); i++) {\n        Node26 node = root;\n        for (int j = i; j < s.length(); j++) {\n            if (!node.containsKey(s.charAt(j))) {\n                c++;\n                node.put(s.charAt(j), new Node26());\n            }\n            node = node.get(s.charAt(j));\n        }\n    }\n    return c + 1;\n}"
  },
  {
    "name": "Find Maximum XOR of Two Numbers in an Array",
    "endpoint": "/api/tries/find-maximum-xor",
    "methodName": "findMaximumXOR",
    "serviceFile": "TriesService.java",
    "defaultInput": { "nums": [3, 10, 5, 25, 2, 8] },
    "description": "Find the maximum XOR of any two numbers in an array using a binary trie.",
    "approach": "Insert all numbers into a binary trie and for each number, find the number in the trie that gives the maximum XOR.",
    "code": "static class Node2 {\n    Node2[] links = new Node2[2];\n    boolean containsKey(int bit) { return links[bit] != null; }\n    Node2 get(int bit) { return links[bit]; }\n    void put(int bit, Node2 node) { links[bit] = node; }\n}\n\nstatic class Trie {\n    private Node2 root;\n    Trie() { root = new Node2(); }\n    void insert(int num) {\n        Node2 node = root;\n        for (int i = 31; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            if (!node.containsKey(bit)) {\n                node.put(bit, new Node2());\n            }\n            node = node.get(bit);\n        }\n    }\n    int getMax(int num) {\n        Node2 node = root;\n        int maxNum = 0;\n        for (int i = 31; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            if (node.containsKey(1 - bit)) {\n                maxNum |= (1 << i);\n                node = node.get(1 - bit);\n            } else {\n                node = node.get(bit);\n            }\n        }\n        return maxNum;\n    }\n}\n\npublic int findMaximumXOR(int[] nums) {\n    Trie trie = new Trie();\n    for (int num : nums) trie.insert(num);\n    int maxi = 0;\n    for (int num : nums) {\n        maxi = Math.max(maxi, trie.getMax(num));\n    }\n    return maxi;\n}"
  }
]