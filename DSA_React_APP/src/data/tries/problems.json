[
  {
    "name": "Count Distinct Substrings",
    "endpoint": "/api/tries/count-distinct",
    "methodName": "countDistinct",
    "serviceFile": "TriesService.java",
    "defaultInput": { "s": "ababa" },
    "description": "Count the number of distinct substrings in a given string using a trie data structure. A substring is a contiguous sequence of characters within a string. For example, in the string 'ababa', the distinct substrings are '', 'a', 'ab', 'aba', 'abab', 'ababa', 'b', 'ba', 'bab', 'baba'. Note that 'a' appears multiple times in the original string but is counted only once. The total count is 10. A trie efficiently tracks unique substrings by representing them as paths from the root node, with each new branch representing a previously unseen substring pattern.",
    "approach": "1. Create a trie data structure with a Node class that has links to 26 possible characters (a-z).\n2. Iterate through each position in the string as starting points for substrings.\n3. For each starting position, insert all possible suffixes into the trie.\n4. While inserting, if a new node needs to be created for a character, increment a counter - this represents a new unique substring.\n5. Return counter + 1 (to account for the empty string as a distinct substring).\n6. This approach efficiently tracks unique substrings without explicitly storing them, as each path in the trie represents a unique substring.",
    "code": "static class Node26 {\n    Node26[] links = new Node26[26];\n    boolean containsKey(char ch) { return links[ch - 'a'] != null; }\n    void put(char ch, Node26 node) { links[ch - 'a'] = node; }\n    Node26 get(char ch) { return links[ch - 'a']; }\n}\n\npublic int countDistinct(String s) {\n    int c = 0;\n    Node26 root = new Node26();\n    for (int i = 0; i < s.length(); i++) {\n        Node26 node = root;\n        for (int j = i; j < s.length(); j++) {\n            if (!node.containsKey(s.charAt(j))) {\n                c++;\n                node.put(s.charAt(j), new Node26());\n            }\n            node = node.get(s.charAt(j));\n        }\n    }\n    return c + 1;\n}"
  },
  {
    "name": "Find Maximum XOR of Two Numbers in an Array",
    "endpoint": "/api/tries/find-maximum-xor",
    "methodName": "findMaximumXOR",
    "serviceFile": "TriesService.java",
    "defaultInput": { "nums": [3, 10, 5, 25, 2, 8] },
    "description": "Find the maximum possible XOR value between any two numbers in an array using a binary trie. The XOR (exclusive OR) operation results in 1 for bits that differ between the two numbers and 0 for bits that are the same. Example: For the array [3, 10, 5, 25, 2, 8], we need to find which pair gives the maximum XOR. Looking at their binary representations: 3 (011), 10 (1010), 5 (101), 25 (11001), 2 (10), 8 (1000). The maximum XOR is 28, obtained from 5 XOR 25: 101 XOR 11001 = 11100 (28). The binary trie is used to efficiently find, for each number, another number in the array that would maximize the XOR value by traversing in the opposite bit direction where possible.",
    "approach": "1. Create a binary trie data structure where each node has links to at most two children (representing 0 and 1 bits).\n2. Insert all numbers from the array into the trie by considering their binary representation from most significant bit (31st bit for integers) to least significant bit (0th bit).\n3. For each number in the array, find the maximum XOR value it can produce with any other number in the array:\n   a. Start traversing the trie from the root for each bit of the current number from MSB to LSB.\n   b. For each bit, try to go in the opposite direction (if current bit is 0, try to go to 1 path and vice versa) to maximize XOR value.\n   c. If the opposite bit exists in trie, take that path and set the corresponding bit in the result.\n   d. Otherwise, follow the same bit path.\n4. Keep track of the maximum XOR value found across all numbers.\n5. Time Complexity: O(N * 32) where N is the number of elements in the array and 32 is the number of bits in an integer.\n6. Space Complexity: O(N * 32) for storing the trie.",
    "code": "static class Node2 {\n    Node2[] links = new Node2[2];\n    boolean containsKey(int bit) { return links[bit] != null; }\n    Node2 get(int bit) { return links[bit]; }\n    void put(int bit, Node2 node) { links[bit] = node; }\n}\n\nstatic class Trie {\n    private Node2 root;\n    Trie() { root = new Node2(); }\n    void insert(int num) {\n        Node2 node = root;\n        for (int i = 31; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            if (!node.containsKey(bit)) {\n                node.put(bit, new Node2());\n            }\n            node = node.get(bit);\n        }\n    }\n    int getMax(int num) {\n        Node2 node = root;\n        int maxNum = 0;\n        for (int i = 31; i >= 0; i--) {\n            int bit = (num >> i) & 1;\n            if (node.containsKey(1 - bit)) {\n                maxNum |= (1 << i);\n                node = node.get(1 - bit);\n            } else {\n                node = node.get(bit);\n            }\n        }\n        return maxNum;\n    }\n}\n\npublic int findMaximumXOR(int[] nums) {\n    Trie trie = new Trie();\n    for (int num : nums) trie.insert(num);\n    int maxi = 0;\n    for (int num : nums) {\n        maxi = Math.max(maxi, trie.getMax(num));\n    }\n    return maxi;\n}"
  }
]