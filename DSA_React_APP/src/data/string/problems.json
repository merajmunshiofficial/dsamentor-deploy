[
  {
    "name": "Count and Say Sequence",
    "endpoint": "/api/string/count-and-say",
    "methodName": "countAndSay",
    "serviceFile": "StringService.java",
    "defaultInput": { "n": 4 },
    "description": "Generate the n-th term of the count-and-say sequence.",
    "approach": "1. Base case: The first term (n=1) is \"1\".\n2. For subsequent terms, generate them by describing the previous term.\n3. To generate the next term:\n   a. Start with an empty string result.\n   b. Count consecutive identical digits in the previous term.\n   c. For each group of consecutive identical digits, append the count followed by the digit to the result.\n4. For example:\n   - n=1: \"1\"\n   - n=2: \"11\" (one 1)\n   - n=3: \"21\" (two 1s)\n   - n=4: \"1211\" (one 2, one 1)\n   - n=5: \"111221\" (one 1, one 2, two 1s)\n5. The algorithm uses recursion to build up from n=1 to the desired n.\n6. Time Complexity: O(2^n) as each term can potentially double in length.\n7. Space Complexity: O(2^n) for storing the string.",
    "code": "public String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String prev = countAndSay(n - 1);\n    int len = prev.length();\n    StringBuilder ans = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < len; i++) {\n        if (prev.charAt(i) == prev.charAt(i - 1)) count++;\n        else {\n            ans.append(count).append(prev.charAt(i - 1));\n            count = 1;\n        }\n    }\n    ans.append(count).append(prev.charAt(len - 1));\n    return ans.toString();\n}"
  },
  {
    "name": "Minimum Parenthesis Reversals",
    "endpoint": "/api/string/count-rev",
    "methodName": "countRev",
    "serviceFile": "StringService.java",
    "defaultInput": { "s": "(()))(" },
    "description": "Find the minimum number of reversals to balance a parenthesis string.",
    "approach": "1. First, check if the string length is odd. If it is, it's impossible to balance the parentheses, so return -1.\n2. Initialize two counters: 'open' for unmatched opening parentheses and 'close' for unmatched closing parentheses.\n3. Iterate through the string character by character:\n   a. If the current character is an opening parenthesis '(', increment the 'open' counter.\n   b. If the current character is a closing parenthesis ')':\n      - If there are unmatched opening parentheses (open > 0), decrement the 'open' counter (matching a pair).\n      - Otherwise, increment the 'close' counter (this is an unmatched closing parenthesis).\n4. After processing the entire string:\n   a. For each unmatched opening parenthesis, we need to reverse it to become a closing one.\n   b. For each unmatched closing parenthesis, we need to reverse it to become an opening one.\n5. The total number of reversals needed is calculated as: (open/2 + open%2 + close/2 + close%2).\n   - This formula handles the fact that we can match parentheses in pairs after reversal.\n6. Time Complexity: O(n) where n is the length of the string.\n7. Space Complexity: O(1) as we only use constant extra space.",
    "code": "public int countRev(String s) {\n    int n = s.length();\n    if (n % 2 != 0) return -1;\n    int open = 0, close = 0;\n    for (int i = 0; i < n; i++) {\n        if (s.charAt(i) == '(') open++;\n        else {\n            if (open > 0) open--;\n            else close++;\n        }\n    }\n    return (open / 2) + (open % 2) + (close / 2) + (close % 2);\n}"
  },
  {
    "name": "Reverse Words in String",
    "endpoint": "/api/string/reverse-words",
    "methodName": "reverseWords",
    "serviceFile": "StringService.java",
    "defaultInput": { "s": "  hello world  " },
    "description": "Reverse the order of words in a string, trimming spaces.",
    "approach": "1. Reverse the entire string as a first step. This puts the words in reverse order but with each word's characters also reversed.\n2. Then iterate through the reversed string to identify and reverse each individual word:\n   a. Skip any leading spaces.\n   b. Once a non-space character is found, mark the start of a word.\n   c. Process characters until a space or end of string is reached.\n   d. Reverse the characters of this word (which restores the original character order within the word).\n   e. Add a single space after each word (except the last one).\n3. Handle any trailing spaces and trim the result to the correct length.\n4. This in-place algorithm uses two pointers:\n   - 'j' for reading through the original (reversed) string.\n   - 'i' for writing the final result.\n5. Time Complexity: O(n) where n is the length of the string.\n6. Space Complexity: O(1) for the in-place algorithm (excluding the StringBuilder which is used as a mutable string representation).",
    "code": "public String reverseWords(String s) {\n    int n = s.length();\n    StringBuilder sb = new StringBuilder(s);\n    reverseString(sb, 0, n - 1);\n    int i = 0, j = 0, start, end;\n    while (j < n) {\n        while (j < n && sb.charAt(j) == ' ') j++;\n        if (j == n) break;\n        start = i;\n        while (j < n && sb.charAt(j) != ' ') {\n            if (i < sb.length()) sb.setCharAt(i++, sb.charAt(j++));\n            else { sb.append(sb.charAt(j++)); i++; }\n        }\n        end = i - 1;\n        reverseString(sb, start, end);\n        if (j < n) {\n            if (i < sb.length()) sb.setCharAt(i++, ' ');\n            else { sb.append(' '); i++; }\n        }\n    }\n    if (i > 0 && sb.charAt(i - 1) == ' ') i--;\n    return sb.substring(0, i);\n}\n\nprivate void reverseString(StringBuilder s, int start, int end) {\n    while (start < end) {\n        char temp = s.charAt(start);\n        s.setCharAt(start, s.charAt(end));\n        s.setCharAt(end, temp);\n        start++; end--;\n    }\n}"
  },
  {
    "name": "KMP Pattern Search",
    "endpoint": "/api/string/kmp-search",
    "methodName": "kmpSearch",
    "serviceFile": "StringService.java",
    "defaultInput": { "pattern": "abc", "text": "ababcabcababc" },
    "description": "Find all indices of a pattern in text using the KMP algorithm.",
    "approach": "1. The KMP (Knuth-Morris-Pratt) algorithm efficiently finds all occurrences of a pattern in a text without backtracking.\n2. Steps of the algorithm:\n   a. Concatenate the pattern, a special character ('$'), and the text to form a single string.\n   b. Compute the LPS (Longest Proper Prefix which is also Suffix) array for this concatenated string.\n   c. The LPS array stores, for each position i, the length of the longest proper prefix of the substring s[0...i] which is also a suffix of this substring.\n   d. Check the LPS values in the portion corresponding to the text:\n      - If LPS[i] equals the pattern length, it means a full match is found starting at position (i - 2*pattern.length()).\n3. The LPS array computation uses a two-pointer technique:\n   a. Keep track of the length of the current matching prefix (j).\n   b. Try to extend this match for each new character.\n   c. If characters don't match, fall back using previously computed LPS values until a match is found or we're back at the beginning.\n4. Time Complexity: O(n + m) where n is the length of the text and m is the length of the pattern.\n5. Space Complexity: O(n + m) for storing the concatenated string and the LPS array.",
    "code": "public List<Integer> kmpSearch(String pattern, String text) {\n    String s = pattern + '$' + text;\n    int[] lps = computeLPS(s);\n    int n = text.length(), m = pattern.length();\n    List<Integer> ans = new ArrayList<>();\n    for (int i = m + 1; i < s.length(); i++) {\n        if (lps[i] == m) ans.add(i - 2 * m);\n    }\n    return ans;\n}\n\nprivate int[] computeLPS(String s) {\n    int n = s.length();\n    int[] lps = new int[n];\n    int i = 1, j = 0;\n    while (i < n) {\n        if (s.charAt(i) == s.charAt(j)) {\n            lps[i] = j + 1; i++; j++;\n        } else {\n            while (j > 0 && s.charAt(i) != s.charAt(j)) j = lps[j - 1];\n            if (s.charAt(i) == s.charAt(j)) { lps[i] = j + 1; j++; }\n            i++;\n        }\n    }\n    return lps;\n}"
  },
  {
    "name": "Rabin-Karp Pattern Search",
    "endpoint": "/api/string/rabin-karp-search",
    "methodName": "rabinKarpSearch",
    "serviceFile": "StringService.java",
    "defaultInput": { "pattern": "abc", "text": "ababcabcababc" },
    "description": "Find all indices of a pattern in text using the Rabin-Karp algorithm (naive version).",
    "approach": "1. This is a naive implementation of pattern matching (not the actual Rabin-Karp algorithm which uses rolling hash functions).\n2. For each possible starting position in the text:\n   a. Compare the substring starting at that position with the pattern character by character.\n   b. If all characters match, record the starting index as a match.\n   c. If any character doesn't match, move to the next starting position.\n3. The actual Rabin-Karp algorithm would:\n   a. Compute a hash value for the pattern.\n   b. Compute hash values for all m-length substrings of the text using a rolling hash function.\n   c. Only compare the actual strings when hash values match, avoiding unnecessary character comparisons.\n4. Time Complexity of this naive approach: O((n-m+1) * m) where n is the length of the text and m is the length of the pattern.\n   - In worst case: O(n*m) when most positions require full pattern comparison.\n5. Space Complexity: O(1) for the algorithm itself (excluding the result list).",
    "code": "public List<Integer> rabinKarpSearch(String pattern, String text) {\n    int n = pattern.length(), m = text.length();\n    List<Integer> ans = new ArrayList<>();\n    for (int i = 0; i <= m - n; i++) {\n        boolean flag = true;\n        for (int j = 0; j < n; j++) {\n            if (text.charAt(i + j) != pattern.charAt(j)) { flag = false; break; }\n        }\n        if (flag) ans.add(i);\n    }\n    return ans;\n}"
  },
  {
    "name": "Z-Algorithm Pattern Search",
    "endpoint": "/api/string/z-algorithm-search",
    "methodName": "zAlgorithmSearch",
    "serviceFile": "StringService.java",
    "defaultInput": { "pattern": "xyz", "text": "xyzabxyzabxyz" },
    "description": "Find all indices of a pattern in text using the Z-algorithm.",
    "approach": "1. The Z-Algorithm efficiently finds all occurrences of a pattern in a text using the Z-array.\n2. The Z-array Z[i] represents the length of the longest substring starting at i that is also a prefix of the string.\n3. Steps of the algorithm:\n   a. Concatenate the pattern, a special character ('$'), and the text to form a single string.\n   b. Compute the Z-array for this concatenated string.\n   c. For each position i in the text part:\n      - If Z[i] equals the pattern length, it means a full pattern match starts at position (i - pattern.length() - 1).\n4. The Z-array computation uses a 'Z-box' technique with two pointers:\n   a. 'left' and 'right' define a substring (Z-box) that matches a prefix of the string.\n   b. If the current index i is outside the Z-box, directly compute Z[i] by comparing characters.\n   c. If i is inside the Z-box, use previously computed Z values as a starting point, then extend if possible.\n5. Time Complexity: O(n + m) where n is the length of the text and m is the length of the pattern.\n6. Space Complexity: O(n + m) for storing the concatenated string and the Z-array.",
    "code": "public List<Integer> zAlgorithmSearch(String text, String pattern) {\n    String s = pattern + '$' + text;\n    int[] z = computeZarray(s);\n    int n = text.length(), m = pattern.length();\n    List<Integer> ans = new ArrayList<>();\n    for (int i = m + 1; i < s.length(); i++) {\n        if (z[i] == m) ans.add(i - (m + 1));\n    }\n    return ans;\n}\n\nprivate int[] computeZarray(String s) {\n    int n = s.length();\n    int[] z = new int[n];\n    int left = 0, right = 0;\n    for (int i = 1; i < n; i++) {\n        if (i > right) {\n            while (i + z[i] < n && s.charAt(i + z[i]) == s.charAt(z[i])) z[i]++;\n            left = i; right = i + z[i] - 1;\n        } else {\n            if (i + z[i - left] <= right) z[i] = z[i - left];\n            else {\n                z[i] = right - i + 1;\n                while (i + z[i] < n && s.charAt(i + z[i]) == s.charAt(z[i])) z[i]++;\n                left = i; right = i + z[i] - 1;\n            }\n        }\n    }\n    return z;\n}"
  },
  {
    "name": "Longest Happy Prefix",
    "endpoint": "/api/string/longest-happy-prefix",
    "methodName": "longestHappyPrefix",
    "serviceFile": "StringService.java",
    "defaultInput": { "s": "ababab" },
    "description": "Find the longest happy prefix (LPS) of a string.",
    "approach": "1. A 'happy prefix' is a non-empty string that is both a prefix and a suffix of the original string.\n2. This problem asks for the longest such prefix (which is equivalent to finding the LPS - Longest Prefix which is also a Suffix).\n3. The approach uses the LPS array computation from the KMP (Knuth-Morris-Pratt) algorithm:\n   a. The LPS array stores, for each position i, the length of the longest proper prefix of substring s[0...i] that is also a suffix of this substring.\n   b. The last value in the LPS array (LPS[n-1]) represents the length of the longest prefix which is also a suffix for the entire string.\n4. After computing the LPS array, the answer is the substring from index 0 to LPS[n-1].\n5. The LPS array computation uses a two-pointer technique:\n   a. Track the length of the current matching prefix (j).\n   b. For each new character, try to extend this match.\n   c. If characters don't match, fall back using previously computed LPS values until a match is found or we're back at the beginning.\n6. Time Complexity: O(n) where n is the length of the string.\n7. Space Complexity: O(n) for storing the LPS array.",
    "code": "public String longestHappyPrefix(String s) {\n    int[] lps = computeLPS(s);\n    return s.substring(0, lps[s.length() - 1]);\n}\n\nprivate int[] computeLPS(String s) {\n    int n = s.length();\n    int[] lps = new int[n];\n    int i = 1, j = 0;\n    while (i < n) {\n        if (s.charAt(i) == s.charAt(j)) {\n            lps[i] = j + 1; i++; j++;\n        } else {\n            while (j > 0 && s.charAt(i) != s.charAt(j)) j = lps[j - 1];\n            if (s.charAt(i) == s.charAt(j)) { lps[i] = j + 1; j++; }\n            i++;\n        }\n    }\n    return lps;\n}"
  },
  {
    "name": "Shortest Palindrome by Prepending",
    "endpoint": "/api/string/shortest-palindrome",
    "methodName": "shortestPalindrome",
    "serviceFile": "StringService.java",
    "defaultInput": { "s": "aacecaaa" },
    "description": "Find the shortest palindrome by prepending characters to the string.",
    "approach": "1. This problem requires finding the minimum number of characters to add at the beginning of the string to make it a palindrome.\n2. The key insight is to find the longest palindromic prefix of the string - we only need to prepend the reverse of the remaining characters.\n3. Steps of the algorithm:\n   a. Create a reversed copy of the input string.\n   b. Concatenate the original string, a special character ('$'), and the reversed string.\n   c. Compute the LPS (Longest Prefix which is also Suffix) array for this concatenated string.\n   d. The last value in the LPS array represents the length of the longest palindromic prefix of the original string.\n   e. The characters we need to prepend are the reverse of the remaining characters (those not part of the longest palindromic prefix).\n4. For example, with input \"aacecaaa\":\n   - Reversed: \"aaacecaa\"\n   - Concatenated: \"aacecaaa$aaacecaa\"\n   - The LPS array's last value tells us the longest palindromic prefix length\n   - We prepend the reverse of the remaining characters to form \"aaacecaaa\"\n5. Time Complexity: O(n) where n is the length of the string.\n6. Space Complexity: O(n) for storing the concatenated string and LPS array.",
    "code": "public String shortestPalindrome(String s) {\n    StringBuilder revs = new StringBuilder(s).reverse();\n    String str = s + \"$\" + revs;\n    int[] lps = computeLPS(str);\n    int ans = s.length() - lps[lps.length - 1];\n    String toAdd = revs.substring(0, ans);\n    return toAdd + s;\n}\n\nprivate int[] computeLPS(String s) {\n    int n = s.length();\n    int[] lps = new int[n];\n    int i = 1, j = 0;\n    while (i < n) {\n        if (s.charAt(i) == s.charAt(j)) {\n            lps[i] = j + 1; i++; j++;\n        } else {\n            while (j > 0 && s.charAt(i) != s.charAt(j)) j = lps[j - 1];\n            if (s.charAt(i) == s.charAt(j)) { lps[i] = j + 1; j++; }\n            i++;\n        }\n    }\n    return lps;\n}"
  }
]