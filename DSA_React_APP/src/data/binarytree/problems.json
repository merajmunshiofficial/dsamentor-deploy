[
  {
    "name": "Inorder Traversal",
    "endpoint": "/api/binary-tree/inorder-traversal",
    "methodName": "inorderTraversal",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "right": { "data": 2, "left": { "data": 3 } } } },
    "description": "Implement a function that returns the inorder traversal of a binary tree. In inorder traversal, we visit the left subtree first, then the root node, and finally the right subtree (Left-Root-Right). For example, given a binary tree with root value 1, right child 2, and its left child 3, the inorder traversal would be [1, 3, 2]. This traversal is particularly important because it visits nodes in ascending order in a binary search tree.",
    "approach": "1. Use recursive depth-first traversal following Left-Root-Right pattern\n2. Base case: if current node is null, return (end of subtree)\n3. First recursively traverse the left subtree\n4. Then visit (process) the current node by adding its value to result\n5. Finally recursively traverse the right subtree\n6. This order ensures values are collected in ascending order for BST",
    "code": "public List<Integer> inorderTraversal(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    inorderHelper(root, result);\n    return result;\n}\n\nprivate void inorderHelper(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n    inorderHelper(node.left, result);\n    result.add(node.data);\n    inorderHelper(node.right, result);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Preorder Traversal",
    "endpoint": "/api/binary-tree/preorder-traversal",
    "methodName": "preorderTraversal",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function that returns the preorder traversal of a binary tree. In preorder traversal, we visit the root node first, then the left subtree, and finally the right subtree (Root-Left-Right). For example, given a binary tree with root value 1, left child 2, and right child 3, the preorder traversal would be [1, 2, 3]. This traversal is useful for creating a copy of the tree or for prefix expression of an expression tree.",
    "approach": "1. Use recursive depth-first traversal following Root-Left-Right pattern\n2. Base case: if current node is null, return (end of subtree)\n3. First visit (process) the current node by adding its value to result\n4. Then recursively traverse the left subtree\n5. Finally recursively traverse the right subtree\n6. This pattern processes parent before children, useful for tree reconstruction",
    "code": "public List<Integer> preorderTraversal(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    preorderHelper(root, result);\n    return result;\n}\n\nprivate void preorderHelper(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n    result.add(node.data);\n    preorderHelper(node.left, result);\n    preorderHelper(node.right, result);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Postorder Traversal",
    "endpoint": "/api/binary-tree/postorder-traversal",
    "methodName": "postorderTraversal",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function that returns the postorder traversal of a binary tree. In postorder traversal, we visit the left subtree first, then the right subtree, and finally the root node (Left-Right-Root). For example, given a binary tree with root value 1, left child 2, and right child 3, the postorder traversal would be [2, 3, 1]. This traversal is essential for deletion operations as it processes children before their parents and is used in mathematical expressions where operators follow their operands.",
    "approach": "1. Use recursive depth-first traversal following Left-Right-Root pattern\n2. Base case: if current node is null, return (end of subtree)\n3. First recursively traverse the left subtree\n4. Then recursively traverse the right subtree\n5. Finally visit (process) the current node by adding its value to result\n6. This pattern processes children before parent, useful for deletion operations",
    "code": "public List<Integer> postorderTraversal(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    postorderHelper(root, result);\n    return result;\n}\n\nprivate void postorderHelper(TreeNode node, List<Integer> result) {\n    if (node == null) return;\n    postorderHelper(node.left, result);\n    postorderHelper(node.right, result);\n    result.add(node.data);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Level Order Traversal",
    "endpoint": "/api/binary-tree/level-order-traversal",
    "methodName": "levelOrderTraversal",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 9 }, "right": { "data": 20, "left": { "data": 15 }, "right": { "data": 7 } } } },
    "description": "Implement a function that returns the level order traversal of a binary tree (also known as breadth-first traversal). The function should return nodes level by level from top to bottom. For example, given a tree with root value 3, left child 9, and right child 20 (which has children 15 and 7), the level order traversal would be [[3], [9, 20], [15, 7]]. Level order traversal is useful for problems requiring processing nodes based on their distance from the root.",
    "approach": "1. Use BFS (Breadth-First Search) with a queue to traverse level by level\n2. Initialize queue with root node if it exists\n3. For each level, record current queue size to process exactly that many nodes\n4. Process all nodes at current level: poll from queue and add to current level list\n5. For each processed node, add its children to queue for next level\n6. Add completed level to result and continue until queue is empty",
    "code": "public List<List<Integer>> levelOrderTraversal(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.data);\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n    }\n    return result;\n}"
  },
  {
    "name": "Maximum Depth of Binary Tree",
    "endpoint": "/api/binary-tree/max-depth",
    "methodName": "maxDepth",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 9 }, "right": { "data": 20, "left": { "data": 15 }, "right": { "data": 7 } } } },
    "description": "Implement a function that finds the maximum depth (or height) of a binary tree. The maximum depth is the number of nodes along the longest path from the root node to the farthest leaf node. For example, given a binary tree with root value 3, left child 9, and right child 20 (which has children 15 and 7), the maximum depth would be 3. The calculation is: level of root (1) + the maximum of depth of left subtree (1) and depth of right subtree (2) = 1 + 2 = 3.",
    "approach": "1. Use recursive approach where depth = 1 + maximum depth of left and right subtrees\n2. Base case: if node is null, return depth 0\n3. Recursively calculate depth of left subtree\n4. Recursively calculate depth of right subtree\n5. Return 1 (current node) + max(leftDepth, rightDepth)\n6. The recursion naturally explores all paths and finds the longest one",
    "code": "public int maxDepth(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    return maxDepthHelper(root);\n}\n\nprivate int maxDepthHelper(TreeNode node) {\n    if (node == null) return 0;\n    return Math.max(maxDepthHelper(node.left), maxDepthHelper(node.right)) + 1;\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Check if Binary Tree is Balanced",
    "endpoint": "/api/binary-tree/is-balanced",
    "methodName": "isBalanced",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 9 }, "right": { "data": 20, "left": { "data": 15 }, "right": { "data": 7 } } } },
    "description": "Implement a function to determine if a binary tree is height-balanced. A height-balanced binary tree is one where the depth of the two subtrees of every node never differs by more than 1. For example, a tree with root 3, left child 9, and right child 20 (with left child 15 and right child 7) is balanced because the depth of the left subtree (1) and right subtree (2) differ by only 1. However, a tree with root 1, left child 2 (with left child 3 and left child 4), and no right child would be unbalanced because the depth of the left subtree (3) and right subtree (0) differ by more than 1.",
    "approach": "1. Use optimized approach that checks balance while calculating height in single pass\n2. Return -1 as signal for unbalanced tree, otherwise return actual height\n3. For each node, recursively get heights of left and right subtrees\n4. If either subtree is unbalanced (returns -1), propagate -1 upward\n5. If height difference between subtrees > 1, current subtree is unbalanced, return -1\n6. Otherwise return 1 + max(leftHeight, rightHeight) for current subtree height",
    "code": "public boolean isBalanced(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    return isBalancedHelper(root) != -1;\n}\n\nprivate int isBalancedHelper(TreeNode node) {\n    if (node == null) return 0;\n    \n    int leftHeight = isBalancedHelper(node.left);\n    if (leftHeight == -1) return -1;\n    \n    int rightHeight = isBalancedHelper(node.right);\n    if (rightHeight == -1) return -1;\n    \n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    return Math.max(leftHeight, rightHeight) + 1;\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Check if Two Trees are Same",
    "endpoint": "/api/binary-tree/is-same-tree",
    "methodName": "isSameTree",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "p": { "data": 1, "left": { "data": 2 } }, "q": { "data": 1, "left": { "data": 2 } } },
    "description": "Implement a function to check if two binary trees are identical. Two binary trees are considered identical if they have the same structure and the same values at corresponding nodes. For example, two trees both with root value 1 and left child 2 would be identical. However, if one tree has root 1, left child 2, and the other has root 1, right child 2, they would not be identical despite having the same values, as their structure differs.",
    "approach": "1. Use recursive approach to compare trees node by node\n2. Base case: if both nodes are null, they are identical (return true)\n3. If one node is null and other is not, they are different (return false)\n4. If both nodes exist, compare their values for equality\n5. Recursively check if left subtrees are same AND right subtrees are same\n6. Return true only if current nodes match AND both subtrees are identical",
    "code": "public boolean isSameTree(BinaryTreeResponse.TreeNodeDTO pDto, BinaryTreeResponse.TreeNodeDTO qDto) {\n    TreeNode p = fromDTO(pDto);\n    TreeNode q = fromDTO(qDto);\n    return isSameTreeHelper(p, q);\n}\n\nprivate boolean isSameTreeHelper(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (p == null || q == null) return false;\n    return p.data == q.data && \n           isSameTreeHelper(p.left, q.left) && \n           isSameTreeHelper(p.right, q.right);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Check if Binary Tree is Symmetric",
    "endpoint": "/api/binary-tree/is-symmetric",
    "methodName": "isSymmetric",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2, "left": { "data": 3 }, "right": { "data": 4 } }, "right": { "data": 2, "left": { "data": 4 }, "right": { "data": 3 } } } },
    "description": "Implement a function to determine if a binary tree is symmetric around its center (mirror image of itself). A tree is symmetric if its left subtree is a mirror reflection of its right subtree. For example, a tree with root 1, left child 2 (with left child 3 and right child 4), and right child 2 (with left child 4 and right child 3) is symmetric. The symmetry check compares left.left with right.right and left.right with right.left to ensure they form mirror images.",
    "approach": "1. A tree is symmetric if left and right subtrees are mirror images of each other\n2. Check symmetry by comparing left subtree with right subtree using helper function\n3. For two subtrees to be mirrors: left.data == right.data\n4. left's left subtree should mirror right's right subtree\n5. left's right subtree should mirror right's left subtree\n6. Handle null cases: both null = symmetric, one null = not symmetric",
    "code": "public boolean isSymmetric(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    if (root == null) return true;\n    return isSymmetricHelper(root.left, root.right);\n}\n\nprivate boolean isSymmetricHelper(TreeNode left, TreeNode right) {\n    if (left == null && right == null) return true;\n    if (left == null || right == null) return false;\n    return left.data == right.data && \n           isSymmetricHelper(left.left, right.right) && \n           isSymmetricHelper(left.right, right.left);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Lowest Common Ancestor",
    "endpoint": "/api/binary-tree/lowest-common-ancestor",
    "methodName": "lowestCommonAncestor",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 5 }, "right": { "data": 1 } }, "p": 5, "q": 1 },
    "description": "Implement a function to find the lowest common ancestor (LCA) of two nodes in a binary tree. The LCA is the deepest node that has both nodes as descendants. For example, in a tree with root 3, left child 5, and right child 1, the LCA of nodes 5 and 1 would be node 3. If one node is a descendant of the other, that node itself is the LCA. The function should efficiently traverse the tree once to find both nodes and identify their common ancestor.",
    "approach": "1. Use a recursive DFS approach to find both nodes and their common ancestor simultaneously.\n2. The key insight is that for any node:\n   a. If it's null or equals either p or q, return the node itself\n   b. If both left and right subtrees return non-null, current node is the LCA\n   c. If one subtree returns null, return the non-null result from other subtree\n3. Algorithm steps:\n   a. Base case: if current node is null or equals p or q, return current node\n   b. Recursively search in left and right subtrees\n   c. If both recursive calls return non-null, current node is LCA\n   d. Otherwise, return the non-null value (or null if both are null)\n4. Example with tree [3,5,1]:\n   - Start at root 3: search left for 5, right for 1\n   - Left subtree finds 5, right subtree finds 1\n   - Both are non-null, so 3 is the LCA\n5. Time Complexity: O(N) where N is number of nodes\n6. Space Complexity: O(H) where H is tree height",
    "code": "public int lowestCommonAncestor(BinaryTreeResponse.TreeNodeDTO rootDto, int p, int q) {\n    TreeNode root = fromDTO(rootDto);\n    TreeNode result = lcaHelper(root, p, q);\n    return result != null ? result.data : -1;\n}\n\nprivate TreeNode lcaHelper(TreeNode node, int p, int q) {\n    if (node == null || node.data == p || node.data == q) {\n        return node;\n    }\n    \n    TreeNode left = lcaHelper(node.left, p, q);\n    TreeNode right = lcaHelper(node.right, p, q);\n    \n    if (left != null && right != null) {\n        return node;\n    }\n    \n    return left != null ? left : right;\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Diameter of Binary Tree",
    "endpoint": "/api/binary-tree/diameter",
    "methodName": "diameterOfBinaryTree",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function to find the diameter of a binary tree. The diameter (or width) is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. For example, in a tree with root 1, left child 2, and right child 3, the diameter is 2 (the path from node 2 to node 3). In a more complex tree with root 1, left child 2 (with left child 4 and right child 5), and right child 3, the diameter is 3 (the path from node 4 to node 5 through node 2). The calculation involves finding the maximum sum of left and right subtree heights for each node.",
    "approach": "1. Use a recursive approach that calculates height while tracking maximum diameter.\n2. For each node, the potential diameter through it is left_height + right_height.\n3. Key implementation details:\n   a. Use a single recursive function that returns height but updates diameter\n   b. Maintain diameter as a global variable (array of size 1 in Java)\n   c. For each node, calculate:\n      - Left subtree height\n      - Right subtree height\n      - Update max diameter if current path is longer\n      - Return max height of left/right + 1\n4. Example with tree [1,2,3,4,5]:\n   - At leaf nodes 4,5: height=0, diameter=0\n   - At node 2: left_height=1, right_height=1, diameter=2\n   - At root 1: left_height=2, right_height=1, diameter=3\n5. Time Complexity: O(N) - visit each node once\n6. Space Complexity: O(H) - recursion stack depth equals tree height\n7. The approach is optimal as we need to visit each node at least once",
    "code": "public int diameterOfBinaryTree(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    int[] diameter = {0};\n    diameterHelper(root, diameter);\n    return diameter[0];\n}\n\nprivate int diameterHelper(TreeNode node, int[] diameter) {\n    if (node == null) return 0;\n    \n    int leftHeight = diameterHelper(node.left, diameter);\n    int rightHeight = diameterHelper(node.right, diameter);\n    \n    diameter[0] = Math.max(diameter[0], leftHeight + rightHeight);\n    \n    return Math.max(leftHeight, rightHeight) + 1;\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Maximum Path Sum",
    "endpoint": "/api/binary-tree/max-path-sum",
    "methodName": "findMaxPathSum",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function to find the maximum path sum in a binary tree. A path is a sequence of nodes where each pair of adjacent nodes has a connection. The path sum is the sum of the node values in the path. The path may start and end at any node and doesn't need to pass through the root. For example, in a tree with root 1, left child 2, and right child 3, the maximum path sum is 6 (the path 2 -> 1 -> 3). For a tree with root -10, left child 9, and right child 20 (with left child 15 and right child 7), the maximum path sum is 42 (the path 15 -> 20 -> 7).",
    "approach": "1. Use a recursive approach that handles both negative and positive values.\n2. For each node, consider four possibilities:\n   a. Node alone\n   b. Node + left path\n   c. Node + right path\n   d. Node + both paths (complete path through node)\n3. Key implementation details:\n   a. Use global variable to track maximum path sum\n   b. For each node recursively calculate:\n      - Best path sum from left (max with 0 to handle negatives)\n      - Best path sum from right (max with 0)\n      - Update global max with complete path through node\n      - Return best single path (node + max(left,right))\n4. Example with tree [-10,9,20,null,null,15,7]:\n   - At leaf 15: return 15, max=15\n   - At leaf 7: return 7, max=15\n   - At node 20: path=42 (15+20+7), return 35 (20+15)\n   - Final result = 42\n5. Time Complexity: O(N) for single tree traversal\n6. Space Complexity: O(H) for recursion stack\n7. Handle negative values by taking max with 0 when calculating paths",
    "code": "public int findMaxPathSum(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    int[] maxSum = {Integer.MIN_VALUE};\n    maxPathSumHelper(root, maxSum);\n    return maxSum[0];\n}\n\nprivate int maxPathSumHelper(TreeNode node, int[] maxSum) {\n    if (node == null) return 0;\n    \n    int leftSum = Math.max(0, maxPathSumHelper(node.left, maxSum));\n    int rightSum = Math.max(0, maxPathSumHelper(node.right, maxSum));\n    \n    maxSum[0] = Math.max(maxSum[0], node.data + leftSum + rightSum);\n    \n    return node.data + Math.max(leftSum, rightSum);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Right Side View",
    "endpoint": "/api/binary-tree/right-side-view",
    "methodName": "rightSideView",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function to return the right side view of a binary tree. The right side view shows what you would see if you were standing to the right of the tree and looking at it from the side. It returns the rightmost node at each level of the tree. For example, in a tree with root 1, left child 2, and right child 3, the right side view would be [1, 3]. For a tree with root 1, left child 2 (with right child 5), and right child 3 (with right child 4), the right side view would be [1, 3, 4].",
    "approach": "1. Use level-order traversal (BFS) to process nodes level by level.\n2. Key implementation details:\n   a. Use a queue to maintain nodes at current level\n   b. Track size of each level to identify rightmost node\n   c. For each level:\n      - Process all nodes in current level\n      - Add last node's value to result\n      - Queue up next level's nodes\n3. Algorithm steps:\n   a. Initialize queue with root and result list\n   b. While queue not empty:\n      - Get current level size\n      - Process all nodes at this level\n      - Add last node to result\n      - Add children to queue\n4. Example with tree [1,2,3,null,5,null,4]:\n   - Level 1: [1] → add 1\n   - Level 2: [2,3] → add 3\n   - Level 3: [5,4] → add 4\n   - Result: [1,3,4]\n5. Time Complexity: O(N) - visit each node once\n6. Space Complexity: O(W) - W is maximum width of tree\n7. Alternative: Could use DFS with level tracking, but BFS is more intuitive",
    "code": "public List<Integer> rightSideView(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            if (i == levelSize - 1) {\n                result.add(node.data);\n            }\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n    }\n    return result;\n}"
  },
  {
    "name": "All Root to Leaf Paths",
    "endpoint": "/api/binary-tree/all-root-to-leaf-paths",
    "methodName": "allRootToLeafPaths",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2, "left": { "data": 3 }, "right": { "data": 4 } }, "right": { "data": 5 } } },
    "description": "Implement a function to return all paths from the root to every leaf node in a binary tree. A leaf node is a node with no children. Each path should be represented as a string of node values connected by '->'. For example, in a tree with root 1, left child 2 (with left child 3 and right child 4), and right child 5, the function would return [\"1->2->3\", \"1->2->4\", \"1->5\"]. This problem tests your ability to use depth-first search (DFS) to explore all possible paths in a tree.",
    "approach": "1. Use DFS with path tracking to find all root-to-leaf paths.\n2. Key implementation details:\n   a. Maintain current path as a string during traversal\n   b. Add path delimiters ('->') between nodes\n   c. When reaching a leaf node, add complete path to result\n3. Algorithm steps:\n   a. Base case: if node is null, return\n   b. Add current node to path string\n   c. If current node is leaf (no children), add path to result\n   d. Otherwise, recursively traverse left and right subtrees\n4. Example with tree [1,2,3,4,5]:\n   - Start at root 1: path='1'\n   - Go left to 2: path='1->2'\n   - Go left to 4: path='1->2->4', add to result\n   - Backtrack, go right to 5: path='1->2->5', add to result\n   - Backtrack, go right to 3: path='1->3', add to result\n5. Time Complexity: O(N) - visit each node once\n6. Space Complexity: O(H) for recursion, O(N) for storing paths\n7. Handle empty string case separately for first node",
    "code": "public List<String> allRootToLeafPaths(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<String> result = new ArrayList<>();\n    if (root == null) return result;\n    rootToLeafHelper(root, \"\", result);\n    return result;\n}\n\nprivate void rootToLeafHelper(TreeNode node, String path, List<String> result) {\n    if (node == null) return;\n    \n    String currentPath = path.isEmpty() ? String.valueOf(node.data) : path + \"->\" + node.data;\n    \n    if (node.left == null && node.right == null) {\n        result.add(currentPath);\n        return;\n    }\n    \n    rootToLeafHelper(node.left, currentPath, result);\n    rootToLeafHelper(node.right, currentPath, result);\n}\n\nprivate TreeNode fromDTO(BinaryTreeResponse.TreeNodeDTO dto) {\n    if (dto == null) return null;\n    TreeNode node = new TreeNode(dto.getData());\n    node.left = fromDTO(dto.getLeft());\n    node.right = fromDTO(dto.getRight());\n    return node;\n}\n\nprivate static class TreeNode {\n    int data;\n    TreeNode left, right;\n    TreeNode(int val) { data = val; }\n}"
  },
  {
    "name": "Zigzag Level Order Traversal",
    "endpoint": "/api/binary-tree/zigzag-level-order",
    "methodName": "zigzagLevelOrder",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 9 }, "right": { "data": 20, "left": { "data": 15 }, "right": { "data": 7 } } } },
    "description": "Implement a function to return the zigzag level order traversal of a binary tree. In zigzag traversal, the nodes are processed level by level, alternating between left-to-right and right-to-left order. For example, in a tree with root 3, left child 9, and right child 20 (with left child 15 and right child 7), the zigzag level order traversal would be [[3], [20, 9], [15, 7]]. The first level (root) is traversed from left to right, the second level from right to left, the third level from left to right, and so on.",
    "approach": "1. Use level-order traversal with direction tracking.\n2. Key implementation details:\n   a. Use a queue for level-order traversal\n   b. Use boolean flag to track traversal direction\n   c. For each level:\n      - If left-to-right: add nodes at end of current level list\n      - If right-to-left: add nodes at beginning of current level list\n3. Algorithm steps:\n   a. Initialize queue with root and direction flag\n   b. For each level:\n      - Get level size\n      - Process all nodes at current level\n      - Add nodes based on direction\n      - Toggle direction for next level\n4. Example with tree [3,9,20,null,null,15,7]:\n   - Level 1 (L→R): [3]\n   - Level 2 (R→L): [20,9]\n   - Level 3 (L→R): [15,7]\n5. Time Complexity: O(N) - visit each node once\n6. Space Complexity: O(W) - W is maximum width of tree\n7. Alternative: Could use two stacks, but queue is simpler",
    "code": "public List<List<Integer>> zigzagLevelOrder(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<List<Integer>> result = new ArrayList<>();\n    if (root == null) return result;\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    boolean leftToRight = true;\n    while (!queue.isEmpty()) {\n        int levelSize = queue.size();\n        List<Integer> level = new ArrayList<>();\n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            if (leftToRight) {\n                level.add(node.data);\n            } else {\n                level.add(0, node.data);\n            }\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n        result.add(level);\n        leftToRight = !leftToRight;\n    }\n    return result;\n}"
  },
  {
    "name": "Build Tree from Inorder and Postorder",
    "endpoint": "/api/binary-tree/build-tree",
    "methodName": "buildTree",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "inorder": [9,3,15,20,7], "postorder": [9,15,7,20,3] },
    "description": "Implement a function to construct a binary tree from its inorder and postorder traversal arrays. The inorder traversal visits nodes in the order (left, root, right), while postorder traversal visits them in the order (left, right, root). For example, given inorder traversal [9, 3, 15, 20, 7] and postorder traversal [9, 15, 7, 20, 3], you should construct a tree with root 3, left child 9, and right child 20 (with left child 15 and right child 7). The key insight is that the last element of the postorder traversal is always the root, and its position in the inorder traversal divides the tree into left and right subtrees.",
    "approach": "1. Use recursion with efficient node location using HashMap.\n2. Key insights:\n   a. Last element of postorder is always the root\n   b. Root's position in inorder divides into left and right subtrees\n   c. Size of left subtree in postorder equals size in inorder\n3. Algorithm steps:\n   a. Create HashMap of inorder values to indices for O(1) lookup\n   b. For each subtree construction:\n      - Get root value from end of postorder range\n      - Find root's position in inorder using HashMap\n      - Calculate sizes of left and right subtrees\n      - Recursively build left and right subtrees\n4. Example with inorder=[9,3,15,20,7], postorder=[9,15,7,20,3]:\n   - Root is 3 (last in postorder)\n   - In inorder: [9] [3] [15,20,7] → left size=1, right size=3\n   - Left subtree: inorder=[9], postorder=[9]\n   - Right subtree: inorder=[15,20,7], postorder=[15,7,20]\n5. Time Complexity: O(N) with HashMap, O(N²) without\n6. Space Complexity: O(N) for HashMap + recursion stack\n7. Handle edge cases: empty arrays, single node trees",
    "code": "public BinaryTreeResponse.TreeNodeDTO buildTree(int[] inorder, int[] postorder) {\n    Map<Integer, Integer> inorderMap = new HashMap<>();\n    for (int i = 0; i < inorder.length; i++) {\n        inorderMap.put(inorder[i], i);\n    }\n    TreeNode root = buildTreeHelper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1, inorderMap);\n    return toDTO(root);\n}"
  },
  {
    "name": "Boundary Traversal",
    "endpoint": "/api/binary-tree/boundary-traversal",
    "methodName": "boundaryTraversal",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2, "left": { "data": 4 }, "right": { "data": 5 } }, "right": { "data": 3, "right": { "data": 6 } } } },
    "description": "Implement a function to return the boundary traversal of a binary tree. The boundary traversal includes all nodes on the boundary of the tree in an anti-clockwise direction, starting from the root. It includes: 1) the root, 2) all nodes on the left boundary (excluding leaf nodes), 3) all leaf nodes from left to right, and 4) all nodes on the right boundary from bottom to top (excluding leaf nodes). For example, in a tree with root 1, left child 2 (with left child 4 and right child 5), and right child 3 (with right child 6), the boundary traversal would be [1, 2, 4, 5, 6, 3].",
    "approach": "1. Break down the traversal into four distinct parts.\n2. Key components:\n   a. Root node (handled separately)\n   b. Left boundary (excluding leaves)\n   c. All leaf nodes (left to right)\n   d. Right boundary (excluding leaves, in reverse order)\n3. Algorithm steps:\n   a. Add root to result\n   b. Process left boundary:\n      - Follow leftmost path, add non-leaf nodes\n      - If no left child, try right child\n   c. Add all leaf nodes using inorder traversal\n   d. Process right boundary in reverse:\n      - Store nodes in stack or reverse final list\n      - Follow rightmost path, add non-leaf nodes\n4. Example with tree [1,2,3,4,5,null,6]:\n   - Root: 1\n   - Left boundary: 2\n   - Leaves: 4,5,6\n   - Right boundary (reverse): 3\n   - Final result: [1,2,4,5,6,3]\n5. Time Complexity: O(N) - visit each node at most twice\n6. Space Complexity: O(H) for recursion\n7. Handle special cases: single node, skewed trees",
    "code": "public List<Integer> boundaryTraversal(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    result.add(root.data);\n    addLeftBoundary(root.left, result);\n    addLeaves(root.left, result);\n    addLeaves(root.right, result);\n    addRightBoundary(root.right, result);\n    return result;\n}"
  },
  {
    "name": "Bottom View",
    "endpoint": "/api/binary-tree/bottom-view",
    "methodName": "bottomView",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 20, "left": { "data": 8, "left": { "data": 5 }, "right": { "data": 3, "left": { "data": 10 }, "right": { "data": 14 } } }, "right": { "data": 22, "right": { "data": 25 } } } },
    "description": "Implement a function to return the bottom view of a binary tree. The bottom view shows the nodes visible when looking at the tree from the bottom, with nodes at the same horizontal distance overriding each other (the lower level node is visible). For example, in a tree with root 20, left child 8 (with left child 5 and right child 3 which has left child 10 and right child 14), and right child 22 (with right child 25), the bottom view would be [5, 10, 3, 14, 25]. This requires tracking horizontal distance from the root and keeping only the deepest node at each horizontal position.",
    "approach": "1. Use level order traversal with horizontal distance tracking.\n2. Key implementation details:\n   a. Use TreeMap to maintain nodes sorted by horizontal distance\n   b. Use Queue with Pair(node, distance) for level traversal\n   c. Always update map with latest node at each distance\n3. Algorithm steps:\n   a. Initialize TreeMap (distance → node value) and Queue\n   b. For each node in level order:\n      - Update map with current node (overwriting any previous)\n      - Add left child with distance-1\n      - Add right child with distance+1\n   c. Return map values in order\n4. Example with tree [20,8,22,5,3,null,25]:\n   - Root 20 at d=0\n   - Level 1: 8(d=-1), 22(d=1)\n   - Level 2: 5(d=-2), 3(d=0), 25(d=2)\n   - Final map: {-2:5, -1:10, 0:3, 1:14, 2:25}\n5. Time Complexity: O(N log W) where W is width of tree\n6. Space Complexity: O(W) for queue and map\n7. TreeMap ensures horizontal order in result",
    "code": "public List<Integer> bottomView(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Map<Integer, Integer> map = new TreeMap<>();\n    Queue<Pair> queue = new LinkedList<>();\n    queue.offer(new Pair(root, 0));\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        TreeNode node = pair.node;\n        int hd = pair.horizontalDistance;\n        map.put(hd, node.data);\n        if (node.left != null) {\n            queue.offer(new Pair(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new Pair(node.right, hd + 1));\n        }\n    }\n    for (int val : map.values()) {\n        result.add(val);\n    }\n    return result;\n}"
  },
  {
    "name": "Top View",
    "endpoint": "/api/binary-tree/top-view",
    "methodName": "topView",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function to return the top view of a binary tree. The top view shows the nodes visible when looking at the tree from the top, with only the first node encountered at each horizontal distance being visible. For example, in a tree with root 1, left child 2, and right child 3, the top view would be [2, 1, 3]. In a more complex tree with root 1, left child 2 (with left child 4 and right child 5), and right child 3 (with left child 6 and right child 7), the top view would be [4, 2, 1, 3, 7]. This requires level order traversal and tracking the horizontal distance of each node from the root.",
    "approach": "1. Use level order traversal with horizontal distance tracking.\n2. Key implementation details:\n   a. Use TreeMap to maintain nodes sorted by horizontal distance\n   b. Use Queue with Pair(node, distance) for level traversal\n   c. Only insert into map if distance not seen before\n3. Algorithm steps:\n   a. Initialize TreeMap (distance → first node value) and Queue\n   b. For each node in level order:\n      - If distance not in map, add node value\n      - Process left child with distance-1\n      - Process right child with distance+1\n   c. Return map values in order\n4. Example with tree [1,2,3,4,5,6,7]:\n   - Root 1 at d=0: map={0:1}\n   - Level 1: 2(d=-1), 3(d=1): map={-1:2, 0:1, 1:3}\n   - Level 2: try 4(d=-2), 5(d=0), 6(d=0), 7(d=2)\n   - Final map: {-2:4, -1:2, 0:1, 1:3, 2:7}\n5. Time Complexity: O(N log W) where W is width of tree\n6. Space Complexity: O(W) for queue and map\n7. First node at each distance remains in map",
    "code": "public List<Integer> topView(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Map<Integer, Integer> map = new TreeMap<>();\n    Queue<Pair> queue = new LinkedList<>();\n    queue.offer(new Pair(root, 0));\n    while (!queue.isEmpty()) {\n        Pair pair = queue.poll();\n        TreeNode node = pair.node;\n        int hd = pair.horizontalDistance;\n        if (!map.containsKey(hd)) {\n            map.put(hd, node.data);\n        }\n        if (node.left != null) {\n            queue.offer(new Pair(node.left, hd - 1));\n        }\n        if (node.right != null) {\n            queue.offer(new Pair(node.right, hd + 1));\n        }\n    }\n    for (int val : map.values()) {\n        result.add(val);\n    }\n    return result;\n}"
  },
  {
    "name": "Nodes at Distance K",
    "endpoint": "/api/binary-tree/distance-k",
    "methodName": "distanceK",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 3, "left": { "data": 5 }, "right": { "data": 1 } }, "target": 5, "k": 1 },
    "description": "Implement a function to find all nodes that are exactly K distance away from a target node in a binary tree. The distance between two nodes is the number of edges on the shortest path between them. For example, in a tree with root 3, left child 5, and right child 1, if the target is node 5 and K=1, the result would be [3] (only the parent of 5 is at distance 1). If K=2 and the target is still 5, the result would be [1] (the sibling subtree node). The challenge is to handle nodes that are K distance away by going up through parent nodes, which requires building a parent mapping.",
    "approach": "1. Use combination of DFS and BFS with parent tracking.\n2. Key implementation details:\n   a. Build parent map using DFS to enable upward traversal\n   b. Find target node in tree\n   c. Use BFS from target to find nodes at distance K\n   d. Track visited nodes to avoid cycles\n3. Algorithm steps:\n   a. Create parent mapping for all nodes\n   b. Locate target node using DFS\n   c. Start BFS from target:\n      - Track distance from target\n      - Explore in all three directions:\n        * Left child\n        * Right child\n        * Parent (using parent map)\n      - When distance=K, add nodes to result\n4. Example with tree [3,5,1,6,2,0,8] target=5 K=2:\n   - Build parent map: 5→3, 6→5, 2→5, 1→3, etc.\n   - Start BFS from 5:\n   - Distance 1: nodes 3,6,2\n   - Distance 2: nodes 1,7 (result)\n5. Time Complexity: O(N) for parent map + O(N) for BFS\n6. Space Complexity: O(N) for parent map and queue\n7. Handle edge cases: target not found, K=0, empty tree",
    "code": "public List<Integer> distanceK(BinaryTreeResponse.TreeNodeDTO rootDto, int target, int k) {\n    TreeNode root = fromDTO(rootDto);\n    List<Integer> result = new ArrayList<>();\n    if (root == null) return result;\n    Map<TreeNode, TreeNode> parentMap = new HashMap<>();\n    buildParentMap(root, parentMap);\n    TreeNode targetNode = findTargetNode(root, target);\n    if (targetNode == null) return result;\n    Set<TreeNode> visited = new HashSet<>();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(targetNode);\n    visited.add(targetNode);\n    int distance = 0;\n    while (!queue.isEmpty() && distance <= k) {\n        int size = queue.size();\n        for (int i = 0; i < size; i++) {\n            TreeNode node = queue.poll();\n            if (distance == k) {\n                result.add(node.data);\n            }\n            if (node.left != null && !visited.contains(node.left)) {\n                queue.offer(node.left);\n                visited.add(node.left);\n            }\n            if (node.right != null && !visited.contains(node.right)) {\n                queue.offer(node.right);\n                visited.add(node.right);\n            }\n            TreeNode parent = parentMap.get(node);\n            if (parent != null && !visited.contains(parent)) {\n                queue.offer(parent);\n                visited.add(parent);\n            }\n        }\n        distance++;\n    }\n    return result;\n}"
  },
  {
    "name": "Serialize Binary Tree",
    "endpoint": "/api/binary-tree/serialize",
    "methodName": "serialize",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "root": { "data": 1, "left": { "data": 2 }, "right": { "data": 3 } } },
    "description": "Implement a function to serialize a binary tree into a string representation that can later be deserialized back into an identical tree structure. Serialization converts the tree into a format that can be easily stored or transmitted. For example, a tree with root 1, left child 2, and right child 3 might be serialized as \"1,2,3,null,null,null,null\". The implementation should handle all possible tree structures, including empty trees, and ensure no information is lost during the serialization process.",
    "approach": "1. Use level-order traversal with null marker representation.\n2. Key implementation details:\n   a. Use StringBuilder for efficient string construction\n   b. Include null children in serialization\n   c. Use queue for level-order traversal\n   d. Remove trailing nulls for efficiency\n3. Algorithm steps:\n   a. Handle empty tree case separately\n   b. Initialize queue with root and StringBuilder\n   c. For each node in level order:\n      - Append node value or 'null' to string\n      - Add both children to queue (even if null)\n   d. Clean up trailing nulls and commas\n4. Example with tree [1,2,3,null,null,4,5]:\n   - Process 1: sb='1,'\n   - Process 2,3: sb='1,2,3,'\n   - Process null,null,4,5: sb='1,2,3,null,null,4,5'\n   - Clean trailing: no change needed\n5. Time Complexity: O(N) for traversal\n6. Space Complexity: O(W) for queue, O(N) for string\n7. Format should be consistent for deserialization",
    "code": "public String serialize(BinaryTreeResponse.TreeNodeDTO rootDto) {\n    TreeNode root = fromDTO(rootDto);\n    if (root == null) return \"null\";\n    StringBuilder sb = new StringBuilder();\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        TreeNode node = queue.poll();\n        if (node == null) {\n            sb.append(\"null,\");\n        } else {\n            sb.append(node.data).append(\",\");\n            queue.offer(node.left);\n            queue.offer(node.right);\n        }\n    }\n    String result = sb.toString();\n    while (result.endsWith(\"null,\")) {\n        result = result.substring(0, result.length() - 5);\n    }\n    if (result.endsWith(\",\")) {\n        result = result.substring(0, result.length() - 1);\n    }\n    return result;\n}"
  },
  {
    "name": "Deserialize Binary Tree",
    "endpoint": "/api/binary-tree/deserialize",
    "methodName": "deserialize",
    "serviceFile": "BinaryTreeService.java",
    "defaultInput": { "data": "1,2,3,null,null,4,5" },
    "description": "Implement a function to deserialize a string representation back into its original binary tree structure. This is the reverse of tree serialization. For example, given the serialized string \"1,2,3,null,null,4,5\", the function should reconstruct a tree with root 1, left child 2, and right child 3 (with left child 4 and right child 5). The deserialization process must correctly interpret null values to reconstruct the exact structure of the original tree, preserving both the topology and node values.",
    "approach": "1. Use level-order reconstruction with queue.\n2. Key implementation details:\n   a. Parse input string into array of values\n   b. Use queue to track nodes needing children\n   c. Handle null values explicitly\n   d. Process two values at a time (left and right child)\n3. Algorithm steps:\n   a. Handle empty/null input cases\n   b. Create root from first value\n   c. Add root to queue\n   d. Process remaining values in pairs:\n      - Poll node from queue\n      - Create left child if value isn't 'null'\n      - Create right child if value isn't 'null'\n      - Add non-null children to queue\n4. Example with \"1,2,3,null,null,4,5\":\n   - Create root(1): queue=[1]\n   - Process 2,3: root.left=2, root.right=3, queue=[2,3]\n   - Process null,null: 2.left=null, 2.right=null, queue=[3]\n   - Process 4,5: 3.left=4, 3.right=5\n5. Time Complexity: O(N) where N is number of nodes\n6. Space Complexity: O(W) for queue (W is max width)\n7. Handle edge cases: malformed input, trailing values",
    "code": "public BinaryTreeResponse.TreeNodeDTO deserialize(String data) {\n    if (data.equals(\"null\") || data.isEmpty()) return null;\n    String[] values = data.split(\",\");\n    if (values.length == 0) return null;\n    TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int i = 1;\n    while (!queue.isEmpty() && i < values.length) {\n        TreeNode node = queue.poll();\n        if (!values[i].equals(\"null\")) {\n            node.left = new TreeNode(Integer.parseInt(values[i]));\n            queue.offer(node.left);\n        }\n        i++;\n        if (i >= values.length) break;\n        if (!values[i].equals(\"null\")) {\n            node.right = new TreeNode(Integer.parseInt(values[i]));\n            queue.offer(node.right);\n        }\n        i++;\n    }\n    return toDTO(root);\n}"
  }
]