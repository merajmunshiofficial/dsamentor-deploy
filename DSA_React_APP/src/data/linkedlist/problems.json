[
  {
    "name": "Add One to Number Represented by Linked List",
    "endpoint": "/api/linked-list/add-one",
    "methodName": "addOne",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3] },
    "description": "Given a non-negative integer represented as a linked list of digits, where each node contains a single digit (0-9), add 1 to this number and return the resulting linked list. Each digit is stored in a separate node, with the head being the most significant digit. For example, given the linked list [1,2,3] representing the number 123, adding 1 results in [1,2,4] representing 124. For [9,9,9] representing 999, adding 1 results in [1,0,0,0] representing 1000, as the carry propagates all the way to the most significant digit and creates a new digit. The challenge is to handle all edge cases, including carry propagation, efficiently without converting the entire number to an integer (which could cause overflow for large numbers).",
    "approach": "1. The problem requires adding 1 to a number represented as a linked list, where each node contains a single digit.\n2. We use a recursive approach to efficiently handle the carry propagation:\n   a. First, convert the input list to a linked list structure.\n   b. Define a recursive helper function that propagates the addition from the end of the list.\n   c. The base case is when we reach the end of the list, returning a carry of 1.\n   d. In the recursive step, add the carry from the next node to the current node's value.\n   e. If the resulting value is less than 10, return 0 (no carry).\n   f. Otherwise, set the node's value to 0 and return 1 (carry).\n3. After the recursion, if there's still a carry of 1, create a new head node with value 1.\n4. This handles cases like [9,9,9] → [1,0,0,0] where we need to add a new digit at the beginning.\n5. Finally, convert the linked list back to a list of integers and return the result.\n6. Time Complexity: O(n) where n is the number of digits.\n7. Space Complexity: O(n) due to the recursion stack.",
    "code": "public List<Integer> addOne(List<Integer> values) {\n    ListNode head = fromList(values);\n    int carry = addHelper(head);\n    if (carry == 1) {\n        ListNode newNode = new ListNode(1);\n        newNode.next = head;\n        head = newNode;\n    }\n    return toList(head);\n}\n\nprivate int addHelper(ListNode node) {\n    if (node == null) return 1;\n    int carry = addHelper(node.next);\n    node.val += carry;\n    if (node.val < 10) return 0;\n    node.val = 0;\n    return 1;\n}\n\nprivate ListNode fromList(List<Integer> values) {\n    if (values == null || values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    for (int v : values) {\n        curr.next = new ListNode(v);\n        curr = curr.next;\n    }\n    return dummy.next;\n}\n\nprivate List<Integer> toList(ListNode head) {\n    List<Integer> result = new ArrayList<>();\n    while (head != null) {\n        result.add(head.val);\n        head = head.next;\n    }\n    return result;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode prev;\n    ListNode() { val = 0; next = null; prev = null; }\n    ListNode(int val) { this.val = val; next = null; prev = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; this.prev = null; }\n    ListNode(int val, ListNode next, ListNode prev) { this.val = val; this.next = next; this.prev = prev; }\n}"
  },
  {
    "name": "Add Two Numbers Represented by Linked Lists",
    "endpoint": "/api/linked-list/add-two-numbers",
    "methodName": "addTwoNumbers",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "l1": [2, 4, 3], "l2": [5, 6, 4] },
    "description": "Given two non-negative integers represented as linked lists where each node contains a single digit (0-9), add the two numbers and return the sum as a linked list. The digits are stored in reverse order, meaning the least significant digit is at the head of the list. For example, given [2,4,3] and [5,6,4], which represent the numbers 342 and 465 respectively (stored in reverse order), the output should be [7,0,8], representing the sum 807 (= 342 + 465). For [9,9] and [1], which represent 99 and 1, the output should be [0,0,1], representing 100. The challenge includes handling carries properly when digits sum to more than 9, and possibly having to create an extra node if the final carry is non-zero. You must also handle lists of different lengths.",
    "approach": "1. The problem asks us to add two numbers where each digit is stored in a separate node of a linked list.\n2. Convert the two input lists to linked list structures.\n3. Create a dummy head node to simplify the code and keep track of the result list.\n4. Initialize a carry variable to 0.\n5. Iterate through both linked lists simultaneously until both are exhausted and there's no remaining carry:\n   a. If a list still has nodes, add the current node's value to the sum.\n   b. Add any carry from the previous step to the sum.\n   c. Calculate the new digit as sum % 10 and the new carry as sum / 10.\n   d. Create a new node with the calculated digit and append it to the result list.\n   e. Move to the next nodes in both lists if available.\n6. This handles lists of unequal lengths and cases where there might be a carry after processing all digits.\n7. After the iteration, convert the resulting linked list back to a list of integers.\n8. Example: [2,4,3] + [5,6,4] = [7,0,8] (representing 342 + 465 = 807).\n9. Time Complexity: O(max(m,n)) where m and n are the lengths of the two lists.\n10. Space Complexity: O(max(m,n)) for the result list.",
    "code": "public List<Integer> addTwoNumbers(List<Integer> l1, List<Integer> l2) {\n    ListNode node1 = fromList(l1);\n    ListNode node2 = fromList(l2);\n    ListNode result = addTwoNumbersHelper(node1, node2);\n    return toList(result);\n}\n\nprivate ListNode addTwoNumbersHelper(ListNode l1, ListNode l2) {\n    ListNode dummy = new ListNode(0);\n    ListNode temp = dummy;\n    int carry = 0;\n    while (l1 != null || l2 != null || carry != 0) {\n        int sum = 0;\n        if (l1 != null) {\n            sum += l1.val;\n            l1 = l1.next;\n        }\n        if (l2 != null) {\n            sum += l2.val;\n            l2 = l2.next;\n        }\n        sum += carry;\n        carry = sum / 10;\n        temp.next = new ListNode(sum % 10);\n        temp = temp.next;\n    }\n    return dummy.next;\n}\n\nprivate ListNode fromList(List<Integer> values) {\n    if (values == null || values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    for (int v : values) {\n        curr.next = new ListNode(v);\n        curr = curr.next;\n    }\n    return dummy.next;\n}\n\nprivate List<Integer> toList(ListNode head) {\n    List<Integer> result = new ArrayList<>();\n    while (head != null) {\n        result.add(head.val);\n        head = head.next;\n    }\n    return result;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode prev;\n    ListNode() { val = 0; next = null; prev = null; }\n    ListNode(int val) { this.val = val; next = null; prev = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; this.prev = null; }\n    ListNode(int val, ListNode next, ListNode prev) { this.val = val; this.next = next; this.prev = prev; }\n}"
  },
  {
    "name": "Delete All Occurrences of a Value in Doubly Linked List",
    "endpoint": "/api/linked-list/delete-all-occurrences",
    "methodName": "deleteAllOccurrences",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 2, 4, 2, 5], "target": 2 },
    "description": "Given a doubly linked list and a target value, remove all nodes from the list that have a value equal to the target. In a doubly linked list, each node contains references to both the next node and the previous node. For example, given the list [1,2,3,2,4,2,5] and target value 2, the result should be [1,3,4,5] after removing all nodes with value 2. For [1,1,1,1] and target 1, the result would be an empty list as all nodes are removed. When removing a node, both the next and previous pointers of adjacent nodes must be properly updated to maintain the integrity of the doubly linked list. The challenge is to efficiently delete all matching nodes while correctly handling edge cases like deleting the head node or deleting consecutive nodes.",
    "approach": "1. The problem involves removing all nodes with a specific value from a doubly linked list.\n2. First, create a doubly linked list from the input values, where each node has pointers to both next and previous nodes.\n3. Traverse the doubly linked list with a temporary pointer, checking each node's value:\n   a. If the current node's value matches the target value:\n      i. If it's the head node, update the head pointer to the next node.\n      ii. Save references to the next and previous nodes.\n      iii. Update the next node's previous pointer to skip the current node (if next exists).\n      iv. Update the previous node's next pointer to skip the current node (if previous exists).\n      v. Move the temporary pointer to the next node.\n   b. If the current node's value doesn't match the target, simply move to the next node.\n4. Continue this process until we reach the end of the list.\n5. The key advantage of a doubly linked list is that we can directly access the previous node without maintaining an extra pointer.\n6. Handle edge cases like empty list or when the target value is not found.\n7. Finally, convert the modified doubly linked list back to a list of integers and return it.\n8. Time Complexity: O(n) where n is the length of the list.\n9. Space Complexity: O(1) as we're modifying the list in-place.",
    "code": "public List<Integer> deleteAllOccurrences(List<Integer> values, int target) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    ListNode head = createDoublyLinkedList(values);\n    head = deleteAllOccurrencesHelper(head, target);\n    return convertDoublyLinkedListToList(head);\n}\n\nprivate ListNode deleteAllOccurrencesHelper(ListNode head, int target) {\n    ListNode temp = head;\n\n    while (temp != null) {\n        if (temp.val == target) {\n            // Update head if needed\n            if (temp == head) {\n                head = temp.next;\n            }\n\n            ListNode nextNode = temp.next;\n            ListNode prevNode = temp.prev;\n\n            // Update previous node's next\n            if (nextNode != null) {\n                nextNode.prev = prevNode;\n            }\n\n            // Update next node's previous\n            if (prevNode != null) {\n                prevNode.next = nextNode;\n            }\n\n            // Move to next node\n            temp = nextNode;\n        } else {\n            temp = temp.next;\n        }\n    }\n\n    return head;\n}\n\nprivate ListNode createDoublyLinkedList(List<Integer> values) {\n    if (values.isEmpty()) return null;\n    \n    ListNode head = new ListNode(values.get(0));\n    ListNode current = head;\n    \n    for (int i = 1; i < values.size(); i++) {\n        ListNode newNode = new ListNode(values.get(i));\n        current.next = newNode;\n        newNode.prev = current;\n        current = newNode;\n    }\n    \n    return head;\n}\n\nprivate List<Integer> convertDoublyLinkedListToList(ListNode head) {\n    List<Integer> result = new ArrayList<>();\n    ListNode current = head;\n    \n    while (current != null) {\n        result.add(current.val);\n        current = current.next;\n    }\n    \n    return result;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode prev;\n    ListNode() { val = 0; next = null; prev = null; }\n    ListNode(int val) { this.val = val; next = null; prev = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; this.prev = null; }\n    ListNode(int val, ListNode next, ListNode prev) { this.val = val; this.next = next; this.prev = prev; }\n}"
  },
  {
    "name": "Delete Middle Node of Linked List",
    "endpoint": "/api/linked-list/delete-middle",
    "methodName": "deleteMiddle",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Given a singly linked list, delete the middle node and return the head of the modified list. The middle node is defined as the node that, when the list has an odd length n, is at position (n+1)/2, and when the list has an even length n, is at position n/2 (0-indexed). For example, for the list [1,2,3,4,5] with 5 nodes, the middle node is at position 2 (value 3), so the result after deletion would be [1,2,4,5]. For [1,2,3,4] with 4 nodes, the middle node is at position 2 (value 3), resulting in [1,2,4]. For [1,2,3] with 3 nodes, the middle node is at position 1 (value 2), resulting in [1,3]. The challenge is to find and delete the middle node efficiently without explicitly calculating the length of the list, ideally in a single pass.",
    "approach": "1. The problem requires finding and deleting the middle node of a singly linked list.\n2. For a singly linked list, we can't directly access the previous node of a given node, so we need a special approach.\n3. Use the classic slow and fast pointer technique to find the middle node:\n   a. Initialize a slow pointer at the head.\n   b. Initialize a fast pointer at head.next.next (two steps ahead).\n   c. While the fast pointer and its next are not null, advance slow by one step and fast by two steps.\n   d. When the fast pointer reaches the end (or null), the slow pointer will be at the node just before the middle.\n4. Special cases:\n   a. If the list is empty or has only one node, return null.\n   b. For even-length lists, we consider the second middle node as the middle.\n5. To delete the middle node, simply set slow.next = slow.next.next, effectively bypassing the middle node.\n6. Time Complexity: O(n) where n is the length of the linked list.\n7. Space Complexity: O(1) as we're using only a constant amount of extra space regardless of input size.",
    "code": "public List<Integer> deleteMiddle(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    ListNode head = createLinkedList(values);\n    head = deleteMiddleHelper(head);\n    return convertLinkedListToList(head);\n}\n\nprivate ListNode deleteMiddleHelper(ListNode head) {\n    if (head == null || head.next == null) return null;\n    \n    ListNode slow = head;\n    ListNode fast = head;\n    ListNode prev = null;\n    \n    while (fast != null && fast.next != null) {\n        prev = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    if (prev != null) {\n        prev.next = slow.next;\n    }\n    \n    return head;\n}\n\nprivate ListNode createLinkedList(List<Integer> values) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    for (int v : values) {\n        curr.next = new ListNode(v);\n        curr = curr.next;\n    }\n    return dummy.next;\n}\n\nprivate List<Integer> convertLinkedListToList(ListNode head) {\n    List<Integer> result = new ArrayList<>();\n    while (head != null) {\n        result.add(head.val);\n        head = head.next;\n    }\n    return result;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Find Length of Loop in Linked List",
    "endpoint": "/api/linked-list/find-length-of-loop",
    "methodName": "findLengthOfLoop",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "loopPosition": 2 },
    "description": "Given a linked list that may contain a cycle (loop), determine the length of the cycle if it exists. A cycle occurs when a node's next pointer points to a node that was visited earlier, creating an endless loop. The length of a cycle is the number of nodes in the loop. For example, in a linked list [1,2,3,4,5] where the last node (5) points back to node 3, there's a cycle of length 3 (nodes 3,4,5). If there's no cycle, return 0. For [1,2,3,4] where node 4 points back to node 2, the cycle length is 3 (nodes 2,3,4). For [1,2,3] with no cycle, the result is 0. The challenge is to detect the presence of a cycle and calculate its length without modifying the original list structure, using only O(1) extra space regardless of the list's size.",
    "approach": "1. The problem involves finding the length of a cycle (loop) in a linked list, if one exists.\n2. First, create a linked list with a loop based on the input values and loop position.\n3. Use Floyd's Cycle Detection algorithm (also known as the Tortoise and Hare algorithm) to detect if a loop exists:\n   a. Initialize slow and fast pointers at the head node.\n   b. Move slow one step and fast two steps at a time.\n   c. If they meet, a loop exists; if fast reaches null, no loop exists.\n4. Once a loop is detected and the pointers meet at some point inside the loop:\n   a. Keep one pointer at the meeting point.\n   b. Move the other pointer one step at a time and count the steps until it returns to the meeting point.\n   c. The number of steps counted is the length of the loop.\n5. If no loop is detected, return 0.\n6. The key insight is that when the pointers meet, they are somewhere in the loop. By counting steps until returning to the same point, we measure the loop's length.\n7. Time Complexity: O(n) where n is the number of nodes in the list.\n8. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public int findLengthOfLoop(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return 0;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Find length of loop\n    return findLengthOfLoopHelper(head);\n}\n\nprivate int findLengthOfLoopHelper(ListNode head) {\n    if (head == null) return 0;\n    \n    ListNode slow = head;\n    ListNode fast = head;\n    \n    // Detect cycle\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            // Cycle detected, find length\n            int length = 1;\n            ListNode temp = slow.next;\n            while (temp != slow) {\n                length++;\n                temp = temp.next;\n            }\n            return length;\n        }\n    }\n    \n    return 0;\n}\n\nprivate ListNode createLinkedListWithLoop(List<Integer> values, int loopPosition) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    ListNode loopNode = null;\n    \n    for (int i = 0; i < values.size(); i++) {\n        curr.next = new ListNode(values.get(i));\n        curr = curr.next;\n        if (i == loopPosition) {\n            loopNode = curr;\n        }\n    }\n    \n    if (loopPosition >= 0 && loopPosition < values.size()) {\n        curr.next = loopNode;\n    }\n    \n    return dummy.next;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Find Starting Point of Loop in Linked List",
    "endpoint": "/api/linked-list/find-starting-point",
    "methodName": "findStartingPoint",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "loopPosition": 2 },
    "description": "Given a linked list that may contain a cycle, find the value of the node where the cycle begins. A cycle occurs when a node's next pointer points back to a previously visited node. For example, in a linked list [1,2,3,4,5] where the last node (5) points back to node 3, the starting point of the cycle is node 3, so the result would be 3. For [1,2,3,4] where node 4 points back to node 2, the starting point is node 2, so the result is 2. If there's no cycle, return -1. The challenge is to find this starting point efficiently using O(1) extra space and without modifying the original list. This requires using Floyd's Cycle Detection Algorithm (tortoise and hare algorithm) to first detect if a cycle exists, then finding where it begins.",
    "approach": "1. The problem requires finding the starting node of a loop in a linked list, if one exists.\n2. First, create a linked list with a loop based on the input values and loop position.\n3. Use Floyd's Cycle Detection algorithm to detect if a loop exists:\n   a. Initialize slow and fast pointers at the head node.\n   b. Move slow one step and fast two steps at a time.\n   c. If they meet, a loop exists; if fast reaches null, no loop exists.\n4. The mathematical proof shows that when the pointers meet, the distance from the head to the loop start equals the distance from the meeting point to the loop start (when traveling in the loop direction).\n5. To find the loop starting point after detecting a loop:\n   a. Reset one of the pointers (either slow or fast) to the head of the list.\n   b. Keep the other pointer at the meeting point.\n   c. Move both pointers one step at a time.\n   d. The node where they meet is the starting point of the loop.\n6. If no loop is detected, return -1 or null.\n7. Time Complexity: O(n) where n is the number of nodes in the list.\n8. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public int findStartingPoint(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return -1;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Find starting point of loop\n    ListNode result = findStartingPointHelper(head);\n    return result != null ? result.val : -1;\n}\n\nprivate ListNode findStartingPointHelper(ListNode head) {\n    if (head == null) return null;\n    \n    ListNode slow = head;\n    ListNode fast = head;\n    \n    // Detect cycle\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            // Cycle detected, find starting point\n            ListNode start = head;\n            while (start != slow) {\n                start = start.next;\n                slow = slow.next;\n            }\n            return start;\n        }\n    }\n    \n    return null;\n}\n\nprivate ListNode createLinkedListWithLoop(List<Integer> values, int loopPosition) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    ListNode loopNode = null;\n    \n    for (int i = 0; i < values.size(); i++) {\n        curr.next = new ListNode(values.get(i));\n        curr = curr.next;\n        if (i == loopPosition) {\n            loopNode = curr;\n        }\n    }\n    \n    if (loopPosition >= 0 && loopPosition < values.size()) {\n        curr.next = loopNode;\n    }\n    \n    return dummy.next;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Flatten Multi-Level Linked List",
    "endpoint": "/api/linked-list/flatten-linked-list",
    "methodName": "flattenLinkedList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "nodes": [ { "val": 1, "nextIndex": 1, "childIndex": -1 }, { "val": 2, "nextIndex": -1, "childIndex": 2 }, { "val": 3, "nextIndex": -1, "childIndex": -1 } ] },
    "description": "Given a linked list where each node may have a next pointer to the next node in the list and a child pointer to a separate linked list, flatten this multi-level structure into a single-level sorted linked list. All linked lists are sorted in ascending order. For example, given a structure like 1→2→3→null where node 2 has a child list 7→8→9→null, and node 8 has another child list 12→13→null, the flattened list would be 1→2→3→7→8→9→12→13→null, maintaining sorted order. The child lists can be at any level of nesting. The challenge is to recursively process all child lists, merge them with their parent lists in sorted order, and ensure all nodes appear exactly once in the final flattened list with their values in ascending order.",
    "approach": "1. The problem involves flattening a multi-level linked list where each node may have a next pointer and a child pointer to another linked list.\n2. First, create the multi-level linked list structure from the input nodes.\n3. Use a recursive approach to flatten the list:\n   a. For each node, if it has a child list, recursively flatten that child list first.\n   b. After flattening the child list, merge it with the current level's list.\n   c. To merge two sorted linked lists, compare the current nodes from both lists and take the smaller value first.\n   d. Continue this process until both lists are fully merged.\n4. The merging ensures that the final flattened list is sorted in ascending order.\n5. Handle edge cases such as when the list is empty or when a node has no child list.\n6. Process all nodes and their children recursively, ensuring that every node is included in the final flattened list.\n7. After flattening, convert the linked list back to a list of integers and return it.\n8. Time Complexity: O(n) where n is the total number of nodes across all levels.\n9. Space Complexity: O(h) where h is the maximum depth of the nested lists due to the recursion stack.",
    "code": "public List<Integer> flattenLinkedList(List<LinkedListRequest.MultiLevelNode> nodes) {\n    if (nodes == null || nodes.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create multi-level linked list\n    MultiLevelListNode head = createMultiLevelLinkedList(nodes);\n    // Flatten the linked list\n    head = flattenLinkedListHelper(head);\n    // Convert back to list\n    return convertFlattenedLinkedListToList(head);\n}\n\nprivate MultiLevelListNode flattenLinkedListHelper(MultiLevelListNode head) {\n    if (head == null) return null;\n    \n    MultiLevelListNode dummy = new MultiLevelListNode(0);\n    dummy.next = head;\n    MultiLevelListNode curr = head;\n    \n    while (curr != null) {\n        if (curr.child != null) {\n            MultiLevelListNode next = curr.next;\n            MultiLevelListNode child = flattenLinkedListHelper(curr.child);\n            curr.next = child;\n            child.prev = curr;\n            curr.child = null;\n            \n            while (curr.next != null) {\n                curr = curr.next;\n            }\n            curr.next = next;\n            if (next != null) {\n                next.prev = curr;\n            }\n        }\n        curr = curr.next;\n    }\n    \n    return dummy.next;\n}\n\nprivate MultiLevelListNode createMultiLevelLinkedList(List<LinkedListRequest.MultiLevelNode> nodes) {\n    if (nodes.isEmpty()) return null;\n    \n    MultiLevelListNode[] nodeArray = new MultiLevelListNode[nodes.size()];\n    for (int i = 0; i < nodes.size(); i++) {\n        nodeArray[i] = new MultiLevelListNode(nodes.get(i).val);\n    }\n    \n    for (int i = 0; i < nodes.size(); i++) {\n        LinkedListRequest.MultiLevelNode node = nodes.get(i);\n        if (node.nextIndex >= 0 && node.nextIndex < nodes.size()) {\n            nodeArray[i].next = nodeArray[node.nextIndex];\n            nodeArray[node.nextIndex].prev = nodeArray[i];\n        }\n        if (node.childIndex >= 0 && node.childIndex < nodes.size()) {\n            nodeArray[i].child = nodeArray[node.childIndex];\n        }\n    }\n    \n    return nodeArray[0];\n}\n\nprivate List<Integer> convertFlattenedLinkedListToList(MultiLevelListNode head) {\n    List<Integer> result = new ArrayList<>();\n    MultiLevelListNode curr = head;\n    while (curr != null) {\n        result.add(curr.val);\n        curr = curr.next;\n    }\n    return result;\n}\n\nprivate static class MultiLevelListNode {\n    int val;\n    MultiLevelListNode next;\n    MultiLevelListNode prev;\n    MultiLevelListNode child;\n    MultiLevelListNode(int val) { this.val = val; }\n}"

  },
  {
    "name": "Get Intersection Node of Two Linked Lists",
    "endpoint": "/api/linked-list/get-intersection-node",
    "methodName": "getIntersectionNode",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "list1": [4,1,8,4,5], "list2": [5,6,1,8,4,5], "intersectionIndex1": 2, "intersectionIndex2": 3 },
    "description": "Given two singly linked lists, find the value of the node where they intersect, if such an intersection exists. An intersection occurs when both lists share the same node (by reference, not just value) and continue along the same path thereafter. For example, given list1 [4,1,8,4,5] and list2 [5,6,1,8,4,5], where the node with value 8 is the same node in both lists, the intersection value is 8. If there's no intersection, return -1. Note that the intersecting node is identified by its memory location, not just by having the same value. After the intersection point, all subsequent nodes are shared between both lists. The challenge is to find this intersection efficiently using O(1) extra space without modifying either list, even when the lists have different lengths before they intersect.",
    "approach": "1. The problem involves finding the intersection point of two linked lists, which is the node where both lists merge into a common path.\n2. First, create two linked lists with an intersection point based on the input values and specified intersection indices.\n3. A naive approach would use a hash set to store all nodes of one list and then check for matches while traversing the second list, but this requires O(n) extra space.\n4. We use an elegant two-pointer technique that requires only O(1) extra space:\n   a. Initialize two pointers, one for each list.\n   b. Traverse both lists simultaneously. When one pointer reaches the end, redirect it to the head of the other list.\n   c. Continue this process until the pointers meet or both become null.\n5. The mathematical insight behind this approach: If the lists have lengths a and b with c common nodes, pointer 1 travels a + (b-c) nodes while pointer 2 travels b + (a-c) nodes before they meet. This ensures they meet at the intersection.\n6. If there's no intersection, both pointers will eventually become null.\n7. Return the value of the intersection node if found, otherwise return -1.\n8. Time Complexity: O(a+b) where a and b are the lengths of the two lists.\n9. Space Complexity: O(1) as we only use two pointers regardless of input size.",
    "code": "public int getIntersectionNode(List<Integer> list1, List<Integer> list2, int intersectionIndex1, int intersectionIndex2) {\n    if (list1 == null || list2 == null || list1.isEmpty() || list2.isEmpty()) {\n        return -1;\n    }\n    // Create linked lists with intersection\n    ListNode head1 = createLinkedListWithIntersection(list1, list2, intersectionIndex1, intersectionIndex2, true);\n    ListNode head2 = createLinkedListWithIntersection(list1, list2, intersectionIndex1, intersectionIndex2, false);\n    // Find intersection node\n    ListNode result = getIntersectionNodeHelper(head1, head2);\n    return result != null ? result.val : -1;\n}\n\nprivate ListNode getIntersectionNodeHelper(ListNode headA, ListNode headB) {\n    if (headA == null || headB == null) return null;\n    \n    ListNode p1 = headA;\n    ListNode p2 = headB;\n    \n    while (p1 != p2) {\n        p1 = (p1 == null) ? headB : p1.next;\n        p2 = (p2 == null) ? headA : p2.next;\n    }\n    \n    return p1;\n}\n\nprivate ListNode createLinkedListWithIntersection(List<Integer> list1, List<Integer> list2, int intersectionIndex1, int intersectionIndex2, boolean isFirstList) {\n    if (list1.isEmpty() || list2.isEmpty()) return null;\n    \n    ListNode dummy1 = new ListNode(0);\n    ListNode curr1 = dummy1;\n    for (int v : list1) {\n        curr1.next = new ListNode(v);\n        curr1 = curr1.next;\n    }\n    \n    ListNode dummy2 = new ListNode(0);\n    ListNode curr2 = dummy2;\n    for (int v : list2) {\n        curr2.next = new ListNode(v);\n        curr2 = curr2.next;\n    }\n    \n    ListNode intersectionNode = dummy1.next;\n    for (int i = 0; i < intersectionIndex1; i++) {\n        if (intersectionNode != null) intersectionNode = intersectionNode.next;\n    }\n    \n    ListNode tail2 = dummy2.next;\n    for (int i = 0; i < intersectionIndex2; i++) {\n        if (tail2 != null && tail2.next != null) tail2 = tail2.next;\n    }\n    \n    if (tail2 != null) {\n        tail2.next = intersectionNode;\n    }\n    \n    return isFirstList ? dummy1.next : dummy2.next;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Detect Cycle in Linked List",
    "endpoint": "/api/linked-list/has-cycle",
    "methodName": "hasCycle",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [3,2,0,-4], "loopPosition": 1 },
    "description": "Given a linked list, determine if it contains a cycle (loop). A cycle exists when a node's next pointer points back to a previously visited node, creating an endless sequence when traversing the list. For example, in a list [3,2,0,-4] where the last node points back to the second node (value 2), the list has a cycle. For [1,2] where the last node points back to the first node (value 1), the list has a cycle. For [1,2,3,4] with no node pointing backward, there's no cycle. The challenge is to detect cycles without modifying the list structure, using only O(1) extra space regardless of list size, and without relying on a hash table to track visited nodes. This is typically solved using Floyd's Cycle Detection Algorithm, also known as the 'tortoise and hare' algorithm, where two pointers move at different speeds through the list.",
    "approach": "1. The problem requires determining whether a linked list contains a cycle (a loop where some node points back to a previous node).\n2. First, create a linked list with a potential cycle based on the input values and loop position.\n3. Use Floyd's Cycle Detection algorithm (also known as the Tortoise and Hare algorithm):\n   a. Initialize two pointers, slow and fast, both starting at the head of the list.\n   b. In each iteration, move slow one step forward and fast two steps forward.\n   c. If there is a cycle, the fast pointer will eventually catch up to the slow pointer within the cycle.\n   d. If there is no cycle, the fast pointer will reach the end of the list (null).\n4. The intuition is that if two runners run on a circular track at different speeds, the faster runner will eventually lap the slower one.\n5. If at any point slow and fast pointers meet (slow == fast and not null), we've detected a cycle.\n6. If fast reaches null or fast.next is null, there is no cycle.\n7. Return true if a cycle is detected, false otherwise.\n8. Time Complexity: O(n) where n is the number of nodes in the linked list.\n9. Space Complexity: O(1) as we only use two pointers regardless of input size.",
    "code": "public boolean hasCycle(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return false;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Check for cycle\n    return hasCycleHelper(head);\n}\n\nprivate boolean hasCycleHelper(ListNode head) {\n    if (head == null) return false;\n    \n    ListNode slow = head;\n    ListNode fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nprivate ListNode createLinkedListWithLoop(List<Integer> values, int loopPosition) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    ListNode loopNode = null;\n    \n    for (int i = 0; i < values.size(); i++) {\n        curr.next = new ListNode(values.get(i));\n        curr = curr.next;\n        if (i == loopPosition) {\n            loopNode = curr;\n        }\n    }\n    \n    if (loopPosition >= 0 && loopPosition < values.size()) {\n        curr.next = loopNode;\n    }\n    \n    return dummy.next;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Check if Linked List is Palindrome",
    "endpoint": "/api/linked-list/is-palindrome",
    "methodName": "isPalindrome",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1,2,2,1] },
    "description": "Given a singly linked list, determine if it is a palindrome. A palindrome reads the same forward and backward. For example, the list [1,2,2,1] is a palindrome because it reads the same from left to right and right to left. Similarly, [1,2,3,2,1] is also a palindrome. However, [1,2,3,4] is not a palindrome. The challenge is to determine this efficiently using O(1) extra space, which means you can't simply copy the list values to an array. One approach is to find the middle of the list, reverse the second half, and then compare it with the first half. For odd-length lists like [1,2,3,2,1], the middle element (3) can be ignored in the comparison since a single element is always a palindrome.",
    "approach": "1. The problem involves checking if a linked list reads the same forward and backward (a palindrome).\n2. A naive approach would be to copy all values to an array and check if the array is a palindrome, but this requires O(n) extra space.\n3. We use a more efficient approach with O(1) extra space by modifying the list structure temporarily:\n   a. Find the middle of the linked list using slow and fast pointers (slow moves one step, fast moves two steps).\n   b. Once the middle is found, reverse the second half of the linked list in-place.\n   c. Compare the first half and the reversed second half node by node.\n   d. If all corresponding nodes have matching values, the list is a palindrome.\n4. For even-length lists, the middle will be the start of the second half.\n5. For odd-length lists, the middle node (pointed to by slow) can be skipped as it doesn't affect palindrome status.\n6. After checking, we can reverse the second half again to restore the original list structure (optional).\n7. Return true if the linked list is a palindrome, false otherwise.\n8. Time Complexity: O(n) where n is the number of nodes in the linked list.\n9. Space Complexity: O(1) as we only modify the list in-place.",
    "code": "public boolean isPalindrome(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return true;\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Check if palindrome\n    return isPalindromeHelper(head);\n}\n\nprivate boolean isPalindromeHelper(ListNode head) {\n    if (head == null || head.next == null) return true;\n    \n    // Find middle\n    ListNode slow = head;\n    ListNode fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    // Reverse second half\n    ListNode secondHalf = reverseList(slow);\n    ListNode firstHalf = head;\n    \n    // Compare\n    ListNode p1 = firstHalf;\n    ListNode p2 = secondHalf;\n    boolean result = true;\n    \n    while (p2 != null) {\n        if (p1.val != p2.val) {\n            result = false;\n            break;\n        }\n        p1 = p1.next;\n        p2 = p2.next;\n    }\n    \n    // Restore list (optional)\n    reverseList(secondHalf);\n    \n    return result;\n}\n\nprivate ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n    \n    while (curr != null) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    \n    return prev;\n}\n\nprivate ListNode createLinkedList(List<Integer> values) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    for (int v : values) {\n        curr.next = new ListNode(v);\n        curr = curr.next;\n    }\n    return dummy.next;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Reverse a Linked List",
    "endpoint": "/api/linked-list/reverse-linked-list",
    "methodName": "reverseLinkedList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Given a singly linked list, reverse its order so that the last node becomes the first node, and each node points to the node that previously came before it. For example, the list [1,2,3,4,5] should become [5,4,3,2,1]. For [1,2,3], the result should be [3,2,1]. A single-node list [1] remains unchanged. The challenge is to reverse the list in-place using O(1) extra space, without creating new nodes. This requires carefully updating the next pointers of each node while keeping track of the previous and next nodes to avoid losing any connections. The operation should handle edge cases like empty lists, single-node lists, and lists with only two nodes.",
    "approach": "1. The problem requires reversing the direction of a singly linked list by changing the next pointers.\n2. We use an iterative approach with three pointers:\n   a. prev: Initially set to null, represents the new head of the reversed portion.\n   b. current: Points to the node being processed.\n   c. next: Temporarily stores the next node to avoid losing the reference when we change current.next.\n3. The algorithm steps:\n   a. Initialize prev as null and current as the head.\n   b. Iterate through the list until current becomes null:\n      i. Save current.next in the next pointer to avoid losing the reference.\n      ii. Reverse the next pointer of the current node to point to prev.\n      iii. Move prev to current and current to next to advance the pointers.\n   c. After the loop, prev will be pointing to the new head of the reversed list.\n4. The reversal essentially changes the direction of each arrow (next pointer) in the linked list.\n5. Example transformation: 1→2→3→4→5→null becomes null←1←2←3←4←5.\n6. Handle edge cases like empty lists or single node lists.\n7. Time Complexity: O(n) where n is the number of nodes in the linked list.\n8. Space Complexity: O(1) as we only use a constant amount of extra space regardless of input size.",
    "code": "public List<Integer> reverseLinkedList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Reverse the list\n    head = reverseLinkedListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}\n\nprivate ListNode reverseLinkedListHelper(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n    \n    while (curr != null) {\n        ListNode next = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = next;\n    }\n    \n    return prev;\n}\n\nprivate ListNode createLinkedList(List<Integer> values) {\n    if (values.isEmpty()) return null;\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    for (int v : values) {\n        curr.next = new ListNode(v);\n        curr = curr.next;\n    }\n    return dummy.next;\n}\n\nprivate List<Integer> convertLinkedListToList(ListNode head) {\n    List<Integer> result = new ArrayList<>();\n    while (head != null) {\n        result.add(head.val);\n        head = head.next;\n    }\n    return result;\n}\n\nprivate static class ListNode {\n    int val;\n    ListNode next;\n    ListNode(int val) { this.val = val; this.next = null; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}"

  },
  {
    "name": "Reverse Linked List in Groups of K",
    "endpoint": "/api/linked-list/reverse-k-group",
    "methodName": "reverseKGroup",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "k": 2 },
    "description": "Given a linked list and a positive integer k, reverse the nodes of the list k at a time and return the modified list. If the number of nodes is not a multiple of k then the nodes remaining at the end should be left as is. For example, given the list [1,2,3,4,5] and k=2, the output should be [2,1,4,3,5]. Here, nodes are reversed in groups of 2, but since we have an odd number of nodes, the last node 5 remains unchanged. For the same list with k=3, the output would be [3,2,1,4,5], where only the first group of 3 nodes is reversed since the remaining nodes are fewer than k. The challenge is to perform these reversals in-place using O(1) extra space, handling all edge cases including when k is 1 (no change) or when k equals the length of the list (complete reversal).",
    "approach": "1. The problem requires reversing the linked list in groups of k nodes each while maintaining the relative order of the groups.\n2. First, create a linked list from the input values.\n3. Use a systematic approach to reverse each group of k nodes:\n   a. Create a dummy node to simplify handling the head of the list.\n   b. Keep track of the previous group's end node (groupPrev).\n   c. For each group:\n      i. Check if there are at least k nodes remaining in the list. If not, leave the remaining nodes as is.\n      ii. Mark the start (groupStart) and end (groupEnd) of the current k-node group.\n      iii. Store the next group's start (nextGroupStart) to maintain continuity.\n      iv. Reverse the current k-node group using the standard linked list reversal technique.\n      v. Connect the previous group's end to the reversed group's start (which is now groupEnd).\n      vi. Connect the original group's start (which is now the reversed group's end) to the next group.\n      vii. Update groupPrev to the end of the current reversed group for the next iteration.\n   d. Continue this process until the end of the list is reached.\n4. For example, with input [1,2,3,4,5] and k=2, the transformation would be:\n   - Original: 1→2→3→4→5\n   - After reversal: 2→1→4→3→5 (groups of 2 nodes each are reversed)\n5. If k=1, the list remains unchanged. If k=n (list length), the entire list is reversed once.\n6. Time Complexity: O(n) where n is the number of nodes in the linked list.\n7. Space Complexity: O(1) as we only use a constant amount of extra space regardless of input size.",
    "code": "public List<Integer> reverseKGroup(List<Integer> values, int k) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Reverse in groups of k\n    head = reverseKGroupHelper(head, k);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Merge Two Sorted Linked Lists",
    "endpoint": "/api/linked-list/merge-two-lists",
    "methodName": "mergeTwoLists",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "l1": [1, 2, 4], "l2": [1, 3, 4] },
    "description": "Given two sorted linked lists, merge them into a single sorted linked list. The new list should be made by splicing together the nodes from the original lists, maintaining the original order of equal elements (stable merge). For example, given two lists [1,2,4] and [1,3,4], the merged result should be [1,1,2,3,4,4]. For lists [2,6,8] and [1,3,5,7], the result would be [1,2,3,5,6,7,8]. The challenge is to merge the lists in-place without creating new nodes, using O(1) extra space. You should handle cases where one or both lists are empty, and where the lists have different lengths. The merged list should maintain the sorted property, and if there are duplicate values, they should appear in the same order as in the original lists.",
    "approach": "1. The problem requires merging two already sorted linked lists into a single sorted linked list.\n2. First, handle edge cases: if one list is empty, return the other list.\n3. Create a dummy head node to simplify the merging process and avoid special handling for the head.\n4. Use a tail pointer to keep track of the last node in the merged list.\n5. Iterate through both lists simultaneously as long as neither is exhausted:\n   a. Compare the current nodes from both lists.\n   b. Take the smaller value node and append it to the merged list.\n   c. Move the pointer of the list from which we took the node.\n   d. Update the tail pointer to the newly added node.\n6. After one list is exhausted, append the remaining nodes from the other list to the merged list.\n7. Return the merged list starting from the dummy head's next node.\n8. Example: merging [1,2,4] and [1,3,4] results in [1,1,2,3,4,4].\n9. The approach preserves the original ordering of equal elements (stable merge).\n10. Time Complexity: O(m+n) where m and n are the lengths of the two input lists.\n11. Space Complexity: O(1) as we're reusing the existing nodes and only creating a dummy head.",
    "code": "public List<Integer> mergeTwoLists(List<Integer> list1, List<Integer> list2) {\n    if (list1 == null || list1.isEmpty()) {\n        return list2 != null ? list2 : new ArrayList<>();\n    }\n    if (list2 == null || list2.isEmpty()) {\n        return list1;\n    }\n    // Create linked lists\n    ListNode head1 = createLinkedList(list1);\n    ListNode head2 = createLinkedList(list2);\n    // Merge lists\n    ListNode result = mergeTwoListsHelper(head1, head2);\n    // Convert back to list\n    return convertLinkedListToList(result);\n}"
  },
  {
    "name": "Sort Linked List Using Merge Sort",
    "endpoint": "/api/linked-list/sort-list",
    "methodName": "sortList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [4, 2, 1, 3] },
    "description": "Given a singly linked list with unsorted values, sort it in ascending order using the merge sort algorithm. Merge sort is particularly well-suited for linked lists as it doesn't require random access to elements. For example, given the list [4,2,1,3], the output should be [1,2,3,4]. For [3,1,4,1,5,9,2,6], the output should be [1,1,2,3,4,5,6,9]. The algorithm should work by: 1) Finding the middle of the list using slow/fast pointers, 2) Recursively sorting the two halves, and 3) Merging the sorted halves. The challenge is to implement this efficiently with O(n log n) time complexity and O(log n) space complexity from the recursive call stack. The solution should handle all edge cases including empty lists, single-node lists, and lists with duplicate values.",
    "approach": "1. The problem requires sorting a linked list in ascending order using the merge sort algorithm.\n2. Merge sort is ideal for linked lists as it doesn't require random access to elements.\n3. The algorithm follows a divide-and-conquer strategy with these key steps:\n   a. Base case: If the list is empty or has only one node, it's already sorted.\n   b. Divide: Find the middle of the linked list using slow and fast pointers (slow moves one step, fast moves two steps).\n   c. Split the list into two halves by setting the middle node's next pointer to null.\n   d. Recursively sort both halves.\n   e. Conquer: Merge the two sorted halves into one sorted list.\n4. The merging process is similar to merging two sorted linked lists:\n   a. Create a dummy head to simplify merging.\n   b. Compare the current nodes from both lists and append the smaller value node to the result.\n   c. Continue until both lists are exhausted.\n5. Example transformation: [4,2,1,3] split into [4,2] and [1,3], which after sorting and merging becomes [1,2,3,4].\n6. Time Complexity: O(n log n) where n is the number of nodes in the linked list.\n7. Space Complexity: O(log n) due to the recursive call stack during the divide step.",
    "code": "public List<Integer> sortList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Sort the list\n    head = sortListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Rearrange Linked List Odd-Even",
    "endpoint": "/api/linked-list/odd-even-list",
    "methodName": "oddEvenList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Given a singly linked list, rearrange it so that all nodes at odd positions come first, followed by all nodes at even positions. Note that we're referring to the node's position (1-based indexing) rather than the node's value. For example, given [1,2,3,4,5], where 1 is at position 1 (odd), 2 at position 2 (even), etc., the rearranged list should be [1,3,5,2,4]. For [2,1,3,5,6,4,7], the result should be [2,3,6,7,1,5,4]. The relative order among odd-position nodes and among even-position nodes should be maintained. The challenge is to perform this rearrangement in-place using O(1) extra space, maintaining the stability of the relative ordering within odd and even groups.",
    "approach": "1. The problem requires rearranging a linked list so that all nodes at odd indices come first, followed by all nodes at even indices.\n2. Note that we're referring to the node's position (1-indexed) in the list, not the value stored in the node.\n3. Create a linked list from the input values.\n4. Use a two-pointer approach to separate odd and even indexed nodes:\n   a. Initialize oddHead and oddTail to the first node (index 1).\n   b. Initialize evenHead and evenTail to the second node (index 2).\n   c. Iterate through the list and connect alternating nodes:\n      i. Connect oddTail to the next odd-indexed node and update oddTail.\n      ii. Connect evenTail to the next even-indexed node and update evenTail.\n   d. After traversal, connect oddTail to evenHead to link the two parts together.\n   e. Set evenTail.next to null to terminate the list.\n5. The relative order of nodes within each group (odd and even) is preserved.\n6. Example transformation: [1,2,3,4,5] becomes [1,3,5,2,4] where nodes at indices 1,3,5 come first, followed by nodes at indices 2,4.\n7. Time Complexity: O(n) where n is the number of nodes in the linked list.\n8. Space Complexity: O(1) as we only use a constant amount of extra space regardless of input size.",
    "code": "public List<Integer> oddEvenList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Rearrange odd-even\n    head = oddEvenListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Remove Duplicates from Sorted Doubly Linked List",
    "endpoint": "/api/linked-list/remove-duplicates",
    "methodName": "removeDuplicates",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 1, 2, 3, 3, 4] },
    "description": "Given a sorted doubly linked list, remove all nodes with duplicate values, keeping only distinct values. A doubly linked list has pointers to both the next and previous nodes. Since the list is sorted, duplicate elements will be adjacent to each other. For example, given [1,1,2,3,3,4], the output should be [2,4] after removing all occurrences of duplicate elements (1 and 3). For [1,2,3,4], which has no duplicates, the output remains [1,2,3,4]. For [1,1,1,2,2], the output should be empty since all elements have duplicates. The challenge is to modify the list in-place using O(1) extra space, properly updating both next and previous pointers when removing nodes, and handling edge cases like when duplicates appear at the start or end of the list.",
    "approach": "1. The problem involves removing duplicate nodes from a sorted doubly linked list, keeping only one instance of each value.\n2. First, create a doubly linked list from the input values where each node has both next and prev pointers.\n3. Since the list is already sorted, duplicate nodes will appear consecutively.\n4. The algorithm steps:\n   a. Check for edge cases: if the list is empty or has only one node, return as is.\n   b. Initialize a current pointer to traverse the list.\n   c. For each node in the list:\n      i. Check if the current node has the same value as the next node.\n      ii. If duplicates are found, update the pointers to skip the next node:\n          - Set current.next = current.next.next\n          - If current.next is not null, set current.next.prev = current\n      iii. If no duplicate is found, move current to the next node.\n   d. Continue until the end of the list is reached.\n5. Example transformation: [1,1,2,3,3,4] becomes [1,2,3,4].\n6. The advantage of a doubly linked list is that we can directly access and update the previous node's pointers.\n7. Time Complexity: O(n) where n is the number of nodes in the linked list.\n8. Space Complexity: O(1) as we're modifying the list in-place.",
    "code": "public List<Integer> removeDuplicates(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create doubly linked list\n    ListNode head = createDoublyLinkedList(values);\n    // Remove duplicates\n    head = removeDuplicatesHelper(head);\n    // Convert back to list\n    return convertDoublyLinkedListToList(head);\n}"
  },
  {
    "name": "Remove Nth Node from End of Linked List",
    "endpoint": "/api/linked-list/remove-nth-from-end",
    "methodName": "removeNthFromEnd",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "n": 2 },
    "description": "Given a singly linked list and an integer n, remove the nth node from the end of the list and return the head of the modified list. For example, given the list [1,2,3,4,5] and n=2, we should remove the second node from the end (value 4), resulting in [1,2,3,5]. For [1,2] and n=2, removing the second node from the end means removing the first node, resulting in [2]. For [1] and n=1, the result should be an empty list. The challenge is to solve this in one pass through the list using O(1) extra space, without first calculating the length of the list. This can be achieved using two pointers with a gap of n nodes between them. Special care must be taken when removing the head node (when n equals the length of the list).",
    "approach": "1. The problem involves removing the nth node from the end of a linked list in one pass.\n2. In a singly linked list, we can't directly access the end or count backward, so we need a special approach.\n3. Use the two-pointer technique with a gap of n nodes between them:\n   a. Create a dummy head node to simplify handling edge cases (like removing the head).\n   b. Initialize two pointers, fast and slow, both pointing to the dummy node.\n   c. Advance the fast pointer by n+1 steps first (creating a gap of n nodes).\n   d. If fast becomes null, the nth node from the end is the head (special case).\n   e. Move both pointers simultaneously until fast reaches the end of the list.\n   f. At this point, slow.next is the nth node from the end that needs to be removed.\n   g. Update the pointers to skip the target node: slow.next = slow.next.next.\n4. The gap of n ensures that when fast reaches the end, slow is exactly at the node before the one we want to remove.\n5. Example: For [1,2,3,4,5] with n=2, we remove the 2nd node from the end (value 4), resulting in [1,2,3,5].\n6. Time Complexity: O(n) where n is the length of the linked list.\n7. Space Complexity: O(1) as we only use a constant amount of extra space.",
    "code": "public List<Integer> removeNthFromEnd(List<Integer> values, int n) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Remove nth from end\n    head = removeNthFromEndHelper(head, n);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Rotate Linked List Right by K Steps",
    "endpoint": "/api/linked-list/rotate-right",
    "methodName": "rotateRight",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "k": 2 },
    "description": "Given a singly linked list and a non-negative integer k, rotate the list to the right by k places. Each step of rotation moves the last element to the front of the list. For example, given the list [1,2,3,4,5] and k=2, the result should be [4,5,1,2,3]. This is achieved by performing two rotations: after the first rotation [5,1,2,3,4], and after the second rotation [4,5,1,2,3]. For [0,1,2] and k=4, the result should be [2,0,1] because rotating a list of length 3 by 4 positions is equivalent to rotating it by 4%3=1 position. The challenge is to handle this efficiently when k might be larger than the length of the list, performing the rotation in-place using O(1) extra space, and handling edge cases like empty lists or lists with only one node.",
    "approach": "1. The problem requires rotating a linked list to the right by k steps, where each node moves k positions to the right and the last k nodes move to the front.\n2. Handle edge cases: if the list is empty, has only one node, or k=0, no rotation is needed.\n3. The key insight is that rotating by k steps is equivalent to making the (n-k)th node the new head, where n is the list length.\n4. The algorithm steps:\n   a. First, find the length of the linked list and the last node.\n   b. Connect the last node to the head to form a circular linked list temporarily.\n   c. Calculate the effective rotation: k % length (since rotating by length gives the original list).\n   d. Traverse to the (length-k)th node, which will be the last node after rotation.\n   e. Set the next node as the new head and break the cycle by setting the current node's next to null.\n5. This approach efficiently handles large values of k without excessive rotations.\n6. Example: For [1,2,3,4,5] with k=2, the result is [4,5,1,2,3] where the last 2 nodes move to the front.\n7. For k=7 and length=5, the effective rotation is 7%5=2, so it's equivalent to rotating by 2 steps.\n8. Time Complexity: O(n) where n is the length of the linked list.\n9. Space Complexity: O(1) as we only modify pointers without using extra space.",
    "code": "public List<Integer> rotateRight(List<Integer> values, int k) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Rotate right by k steps\n    head = rotateRightHelper(head, k);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Copy Linked List with Random Pointers",
    "endpoint": "/api/linked-list/copy-random-list",
    "methodName": "copyRandomList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "nodes": [ { "val": 7, "nextIndex": 1, "randomIndex": null }, { "val": 13, "nextIndex": 2, "randomIndex": 0 }, { "val": 11, "nextIndex": 3, "randomIndex": 4 }, { "val": 10, "nextIndex": 4, "randomIndex": 2 }, { "val": 1, "nextIndex": null, "randomIndex": 0 } ] },
    "description": "Given a linked list where each node contains an additional random pointer that could point to any node in the list or null, create a deep copy of the list. Each node in the original list has a value, a next pointer, and a random pointer. The deep copy should have completely new nodes with the same structure and values, but no references to the original nodes. For example, if the original list has nodes A→B→C where A's random points to C and B's random points to A, the copied list should have nodes A'→B'→C' where A''s random points to C' and B''s random points to A'. The challenge is to maintain the random pointer relationships in the copied list while ensuring all nodes are completely new instances. This requires careful handling of the random pointers since they can point to any node, including nodes that haven't been created yet during the copying process.",
    "approach": "1. The problem involves creating a deep copy of a linked list where each node has both next and random pointers.\n2. The main challenge is handling random pointers that can point to any node in the list, including nodes not yet processed.\n3. We use a three-step approach to solve this efficiently:\n   a. Step 1: Create copy nodes and insert them right after each original node. This creates a pattern: original→copy→original→copy...\n   b. Step 2: Set the random pointers for the copy nodes. Since copy nodes are placed right after original nodes, if original.random points to X, then original.next.random should point to X.next.\n   c. Step 3: Separate the original and copy lists by adjusting the next pointers.\n4. This approach ensures that we can handle random pointers correctly without needing extra space for mapping.\n5. Alternative approach using HashMap: Create a mapping between original nodes and their copies, then set pointers using the mapping.\n6. The interleaving approach is more space-efficient as it doesn't require additional hash map storage.\n7. Handle edge cases like empty lists or nodes with null random pointers.\n8. Time Complexity: O(n) where n is the number of nodes in the linked list.\n9. Space Complexity: O(1) for the interleaving approach, O(n) for the hash map approach.",
    "code": "public List<LinkedListRequest.RandomListNodeDTO> copyRandomList(List<LinkedListRequest.RandomListNodeDTO> nodes) {\n    if (nodes == null || nodes.isEmpty()) return new ArrayList<>();\n    // Step 1: Build original node list\n    List<RandomListNode> origNodes = new ArrayList<>();\n    for (LinkedListRequest.RandomListNodeDTO dto : nodes) {\n        origNodes.add(new RandomListNode(dto.getVal()));\n    }\n    // Step 2: Set next and random pointers\n    for (int i = 0; i < nodes.size(); i++) {\n        Integer nextIdx = nodes.get(i).getNextIndex();\n        Integer randIdx = nodes.get(i).getRandomIndex();\n        if (nextIdx != null && nextIdx >= 0 && nextIdx < nodes.size()) {\n            origNodes.get(i).next = origNodes.get(nextIdx);\n        }\n        if (randIdx != null && randIdx >= 0 && randIdx < nodes.size()) {\n            origNodes.get(i).random = origNodes.get(randIdx);\n        }\n    }\n    // Step 3: Clone the list\n    RandomListNode head = origNodes.get(0);\n    RandomListNode clonedHead = copyRandomListInternal(head);\n    // Step 4: Collect cloned nodes in order\n    Map<RandomListNode, Integer> nodeToIndex = new HashMap<>();\n    List<RandomListNode> clonedNodes = new ArrayList<>();\n    RandomListNode temp = clonedHead;\n    int idx = 0;\n    while (temp != null) {\n        nodeToIndex.put(temp, idx++);\n        clonedNodes.add(temp);\n        temp = temp.next;\n    }\n    // Step 5: Build DTOs for output\n    List<LinkedListRequest.RandomListNodeDTO> result = new ArrayList<>();\n    for (int i = 0; i < clonedNodes.size(); i++) {\n        RandomListNode node = clonedNodes.get(i);\n        Integer nextIdx = node.next != null ? nodeToIndex.get(node.next) : null;\n        Integer randIdx = node.random != null ? nodeToIndex.get(node.random) : null;\n        result.add(new LinkedListRequest.RandomListNodeDTO(node.val, nextIdx, randIdx));\n    }\n    return result;\n}\n\nprivate RandomListNode copyRandomListInternal(RandomListNode head) {\n    if (head == null) return null;\n    // Insert copy nodes\n    RandomListNode temp = head;\n    while (temp != null) {\n        RandomListNode copy = new RandomListNode(temp.val);\n        copy.next = temp.next;\n        temp.next = copy;\n        temp = copy.next;\n    }\n    // Set random pointers\n    temp = head;\n    while (temp != null) {\n        if (temp.random != null) {\n            temp.next.random = temp.random.next;\n        }\n        temp = temp.next.next;\n    }\n    // Separate the lists\n    temp = head;\n    RandomListNode dummy = new RandomListNode(0);\n    RandomListNode copyCurr = dummy;\n    while (temp != null) {\n        copyCurr.next = temp.next;\n        temp.next = temp.next.next;\n        temp = temp.next;\n        copyCurr = copyCurr.next;\n    }\n    return dummy.next;\n}\n\nprivate static class RandomListNode {\n    int val;\n    RandomListNode next, random;\n    RandomListNode(int val) { this.val = val; }\n}"
  }
]
