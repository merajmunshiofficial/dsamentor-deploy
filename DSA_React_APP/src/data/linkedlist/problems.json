[
  {
    "name": "Add One to Number Represented by Linked List",
    "endpoint": "/api/linked-list/add-one",
    "methodName": "addOne",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3] },
    "description": "Add one to a number represented as a linked list of digits.",
    "approach": "Use recursion to add one from the end, handling carry propagation.",
    "code": "public List<Integer> addOne(List<Integer> values) {\n    ListNode head = fromList(values);\n    int carry = addHelper(head);\n    if (carry == 1) {\n        ListNode newNode = new ListNode(1);\n        newNode.next = head;\n        head = newNode;\n    }\n    return toList(head);\n}"
  },
  {
    "name": "Add Two Numbers Represented by Linked Lists",
    "endpoint": "/api/linked-list/add-two-numbers",
    "methodName": "addTwoNumbers",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "l1": [2, 4, 3], "l2": [5, 6, 4] },
    "description": "Add two numbers represented as linked lists of digits.",
    "approach": "Iterate through both lists, summing digits and handling carry.",
    "code": "public List<Integer> addTwoNumbers(List<Integer> l1, List<Integer> l2) {\n    ListNode node1 = fromList(l1);\n    ListNode node2 = fromList(l2);\n    ListNode result = addTwoNumbersHelper(node1, node2);\n    return toList(result);\n}"
  },
  {
    "name": "Delete All Occurrences of a Value in Doubly Linked List",
    "endpoint": "/api/linked-list/delete-all-occurrences",
    "methodName": "deleteAllOccurrences",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 2, 4, 2, 5], "target": 2 },
    "description": "Delete all occurrences of a target value from a doubly linked list.",
    "approach": "Traverse the list and remove nodes matching the target value, updating links.",
    "code": "public List<Integer> deleteAllOccurrences(List<Integer> values, int target) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    ListNode head = createDoublyLinkedList(values);\n    head = deleteAllOccurrencesHelper(head, target);\n    return convertDoublyLinkedListToList(head);\n}"
  },
  {
    "name": "Delete Middle Node of Linked List",
    "endpoint": "/api/linked-list/delete-middle",
    "methodName": "deleteMiddle",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Delete the middle node from a singly linked list.",
    "approach": "Use slow and fast pointers to find and remove the middle node.",
    "code": "public List<Integer> deleteMiddle(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    ListNode head = createLinkedList(values);\n    head = deleteMiddleHelper(head);\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Find Length of Loop in Linked List",
    "endpoint": "/api/linked-list/find-length-of-loop",
    "methodName": "findLengthOfLoop",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "loopPosition": 2 },
    "description": "Find the length of the loop in a linked list, if present.",
    "approach": "Use Floyd's cycle detection algorithm to find the loop and count its length.",
    "code": "public int findLengthOfLoop(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return 0;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Find length of loop\n    return findLengthOfLoopHelper(head);\n}"
  },
  {
    "name": "Find Starting Point of Loop in Linked List",
    "endpoint": "/api/linked-list/find-starting-point",
    "methodName": "findStartingPoint",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "loopPosition": 2 },
    "description": "Find the starting node value of the loop in a linked list, if present.",
    "approach": "Use Floyd's cycle detection and reset one pointer to head to find the start of the loop.",
    "code": "public int findStartingPoint(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return -1;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Find starting point of loop\n    ListNode result = findStartingPointHelper(head);\n    return result != null ? result.val : -1;\n}"
  },
  {
    "name": "Flatten Multi-Level Linked List",
    "endpoint": "/api/linked-list/flatten-linked-list",
    "methodName": "flattenLinkedList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "nodes": [ { "val": 1, "nextIndex": 1, "childIndex": -1 }, { "val": 2, "nextIndex": -1, "childIndex": 2 }, { "val": 3, "nextIndex": -1, "childIndex": -1 } ] },
    "description": "Flatten a multi-level linked list into a single-level sorted linked list.",
    "approach": "Recursively flatten the next lists and merge with the current list.",
    "code": "public List<Integer> flattenLinkedList(List<LinkedListRequest.MultiLevelNode> nodes) {\n    if (nodes == null || nodes.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create multi-level linked list\n    MultiLevelListNode head = createMultiLevelLinkedList(nodes);\n    // Flatten the linked list\n    head = flattenLinkedListHelper(head);\n    // Convert back to list\n    return convertFlattenedLinkedListToList(head);\n}"
  },
  {
    "name": "Get Intersection Node of Two Linked Lists",
    "endpoint": "/api/linked-list/get-intersection-node",
    "methodName": "getIntersectionNode",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "list1": [4,1,8,4,5], "list2": [5,6,1,8,4,5], "intersectionIndex1": 2, "intersectionIndex2": 3 },
    "description": "Find the value of the intersection node of two singly linked lists, if present.",
    "approach": "Create two pointers and traverse both lists; when one reaches the end, switch to the other list. They will meet at the intersection or at null.",
    "code": "public int getIntersectionNode(List<Integer> list1, List<Integer> list2, int intersectionIndex1, int intersectionIndex2) {\n    if (list1 == null || list2 == null || list1.isEmpty() || list2.isEmpty()) {\n        return -1;\n    }\n    // Create linked lists with intersection\n    ListNode head1 = createLinkedListWithIntersection(list1, list2, intersectionIndex1, intersectionIndex2, true);\n    ListNode head2 = createLinkedListWithIntersection(list1, list2, intersectionIndex1, intersectionIndex2, false);\n    // Find intersection node\n    ListNode result = getIntersectionNodeHelper(head1, head2);\n    return result != null ? result.val : -1;\n}"
  },
  {
    "name": "Detect Cycle in Linked List",
    "endpoint": "/api/linked-list/has-cycle",
    "methodName": "hasCycle",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [3,2,0,-4], "loopPosition": 1 },
    "description": "Detect if a linked list has a cycle (loop).",
    "approach": "Use Floyd's cycle detection algorithm (slow and fast pointers).",
    "code": "public boolean hasCycle(List<Integer> values, int loopPosition) {\n    if (values == null || values.isEmpty()) {\n        return false;\n    }\n    // Create linked list with loop\n    ListNode head = createLinkedListWithLoop(values, loopPosition);\n    // Check for cycle\n    return hasCycleHelper(head);\n}"
  },
  {
    "name": "Check if Linked List is Palindrome",
    "endpoint": "/api/linked-list/is-palindrome",
    "methodName": "isPalindrome",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1,2,2,1] },
    "description": "Check if a singly linked list is a palindrome.",
    "approach": "Find the middle, reverse the second half, and compare both halves.",
    "code": "public boolean isPalindrome(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return true;\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Check if palindrome\n    return isPalindromeHelper(head);\n}"
  },
  {
    "name": "Reverse a Linked List",
    "endpoint": "/api/linked-list/reverse-linked-list",
    "methodName": "reverseLinkedList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Reverse a singly linked list.",
    "approach": "Iteratively reverse the linked list by changing next pointers.",
    "code": "public List<Integer> reverseLinkedList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Reverse the list\n    head = reverseLinkedListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Reverse Linked List in Groups of K",
    "endpoint": "/api/linked-list/reverse-k-group",
    "methodName": "reverseKGroup",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "k": 2 },
    "description": "Reverse nodes of a linked list in groups of size k.",
    "approach": "Iteratively reverse every k nodes in the list using helper functions.",
    "code": "public List<Integer> reverseKGroup(List<Integer> values, int k) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Reverse in groups of k\n    head = reverseKGroupHelper(head, k);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Merge Two Sorted Linked Lists",
    "endpoint": "/api/linked-list/merge-two-lists",
    "methodName": "mergeTwoLists",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "l1": [1, 2, 4], "l2": [1, 3, 4] },
    "description": "Merge two sorted singly linked lists into one sorted list.",
    "approach": "Iteratively compare nodes from both lists and merge into a new list.",
    "code": "public List<Integer> mergeTwoLists(List<Integer> list1, List<Integer> list2) {\n    if (list1 == null || list1.isEmpty()) {\n        return list2 != null ? list2 : new ArrayList<>();\n    }\n    if (list2 == null || list2.isEmpty()) {\n        return list1;\n    }\n    // Create linked lists\n    ListNode head1 = createLinkedList(list1);\n    ListNode head2 = createLinkedList(list2);\n    // Merge lists\n    ListNode result = mergeTwoListsHelper(head1, head2);\n    // Convert back to list\n    return convertLinkedListToList(result);\n}"
  },
  {
    "name": "Sort Linked List Using Merge Sort",
    "endpoint": "/api/linked-list/sort-list",
    "methodName": "sortList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [4, 2, 1, 3] },
    "description": "Sort a singly linked list using merge sort algorithm.",
    "approach": "Recursively split the list and merge sorted halves.",
    "code": "public List<Integer> sortList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Sort the list\n    head = sortListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Rearrange Linked List Odd-Even",
    "endpoint": "/api/linked-list/odd-even-list",
    "methodName": "oddEvenList",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5] },
    "description": "Rearrange a linked list so that all odd-indexed nodes are followed by even-indexed nodes.",
    "approach": "Use two pointers to separate odd and even nodes, then concatenate.",
    "code": "public List<Integer> oddEvenList(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Rearrange odd-even\n    head = oddEvenListHelper(head);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Remove Duplicates from Sorted Doubly Linked List",
    "endpoint": "/api/linked-list/remove-duplicates",
    "methodName": "removeDuplicates",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 1, 2, 3, 3, 4] },
    "description": "Remove duplicates from a sorted doubly linked list.",
    "approach": "Traverse the list and remove consecutive duplicate nodes.",
    "code": "public List<Integer> removeDuplicates(List<Integer> values) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create doubly linked list\n    ListNode head = createDoublyLinkedList(values);\n    // Remove duplicates\n    head = removeDuplicatesHelper(head);\n    // Convert back to list\n    return convertDoublyLinkedListToList(head);\n}"
  },
  {
    "name": "Remove Nth Node from End of Linked List",
    "endpoint": "/api/linked-list/remove-nth-from-end",
    "methodName": "removeNthFromEnd",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "n": 2 },
    "description": "Remove the nth node from the end of a singly linked list.",
    "approach": "Use two pointers with a gap of n to find and remove the nth node from the end.",
    "code": "public List<Integer> removeNthFromEnd(List<Integer> values, int n) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Remove nth from end\n    head = removeNthFromEndHelper(head, n);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  },
  {
    "name": "Rotate Linked List Right by K Steps",
    "endpoint": "/api/linked-list/rotate-right",
    "methodName": "rotateRight",
    "serviceFile": "LinkedListService.java",
    "defaultInput": { "values": [1, 2, 3, 4, 5], "k": 2 },
    "description": "Rotate a singly linked list to the right by k steps.",
    "approach": "Connect the end to the head to form a cycle, then break at the new head position.",
    "code": "public List<Integer> rotateRight(List<Integer> values, int k) {\n    if (values == null || values.isEmpty()) {\n        return new ArrayList<>();\n    }\n    // Create linked list\n    ListNode head = createLinkedList(values);\n    // Rotate right by k steps\n    head = rotateRightHelper(head, k);\n    // Convert back to list\n    return convertLinkedListToList(head);\n}"
  }
]