[
  {
    "name": "Aggressive Cows",
    "endpoint": "/api/binary-search/aggressive-cows",
    "methodName": "aggressiveCows",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 4, 8, 9], "k": 3 },
    "description": "Place k cows in stalls such that the minimum distance between any two cows is maximized.",
    "approach": "Use binary search on the answer (distance) and check feasibility with a greedy helper.",
    "code": "public int aggressiveCows(int[] nums, int k) {\n    Arrays.sort(nums);\n    int low = 1, high = nums[nums.length - 1] - nums[0];\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canWePlace(nums, mid, k)) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return high;\n}"
  },
  {
    "name": "Find Floor and Ceil",
    "endpoint": "/api/binary-search/find-floor-and-ceil",
    "methodName": "findFloorAndCeil",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 8, 10, 10, 12, 19], "x": 5 },
    "description": "Find the floor and ceil of a given number in a sorted array.",
    "approach": "Use binary search twice: once for floor, once for ceil.",
    "code": "public int[] findFloorAndCeil(int[] nums, int x) {\n    int n = nums.length;\n    int floor = -1, ceil = -1;\n    int low = 0, high = n - 1;\n    // Find floor\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] <= x) {\n            floor = nums[mid];\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    low = 0; high = n - 1;\n    // Find ceil\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] >= x) {\n            ceil = nums[mid];\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return new int[] { floor, ceil };\n}"
  },
  {
    "name": "Find K Rotation",
    "endpoint": "/api/binary-search/find-k-rotation",
    "methodName": "findKRotation",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [15, 18, 2, 3, 6, 12] },
    "description": "Find the number of times a sorted array has been rotated.",
    "approach": "Use binary search to find the index of the minimum element.",
    "code": "public int findKRotation(int[] nums) {\n    int n = nums.length;\n    int low = 0, high = n - 1;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}"
  },
  {
    "name": "Find Median of Two Sorted Arrays",
    "endpoint": "/api/binary-search/find-median",
    "methodName": "findMedian",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums1": [1, 3], "nums2": [2] },
    "description": "Find the median of two sorted arrays.",
    "approach": "Use binary search on the smaller array to partition both arrays and find the median.",
    "code": "public double findMedian(int[] nums1, int[] nums2) {\n    int n1 = nums1.length, n2 = nums2.length;\n    if (n1 > n2) return findMedian(nums2, nums1);\n    int low = 0, high = n1;\n    while (low <= high) {\n        int cut1 = (low + high) / 2;\n        int cut2 = (n1 + n2 + 1) / 2 - cut1;\n        int l1 = (cut1 == 0) ? Integer.MIN_VALUE : nums1[cut1 - 1];\n        int l2 = (cut2 == 0) ? Integer.MIN_VALUE : nums2[cut2 - 1];\n        int r1 = (cut1 == n1) ? Integer.MAX_VALUE : nums1[cut1];\n        int r2 = (cut2 == n2) ? Integer.MAX_VALUE : nums2[cut2];\n        if (l1 <= r2 && l2 <= r1) {\n            if ((n1 + n2) % 2 == 0)\n                return (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;\n            else\n                return Math.max(l1, l2);\n        } else if (l1 > r2) {\n            high = cut1 - 1;\n        } else {\n            low = cut1 + 1;\n        }\n    }\n    return 0.0;\n}"
  },
  {
    "name": "Find Minimum in Rotated Sorted Array",
    "endpoint": "/api/binary-search/find-min",
    "methodName": "findMin",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [3, 4, 5, 1, 2] },
    "description": "Find the minimum element in a rotated sorted array.",
    "approach": "Use binary search to find the minimum element.",
    "code": "public int findMin(int[] nums) {\n    int n = nums.length;\n    int low = 0, high = n - 1;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return nums[low];\n}"
  },
  {
    "name": "Allocate Minimum Number of Pages",
    "endpoint": "/api/binary-search/find-pages",
    "methodName": "findPages",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [12, 34, 67, 90], "students": 2 },
    "description": "Allocate books to students such that the maximum number of pages assigned is minimized.",
    "approach": "Use binary search on the answer and check allocation feasibility with a helper.",
    "code": "public int findPages(int[] nums, int students) {\n    int n = nums.length;\n    if (students > n) return -1;\n    int low = Arrays.stream(nums).max().getAsInt();\n    int high = Arrays.stream(nums).sum();\n    int result = -1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canAllocate(nums, students, mid)) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return result;\n}"
  },
  {
    "name": "Find Peak Element",
    "endpoint": "/api/binary-search/find-peak-element",
    "methodName": "findPeakElement",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 1, 3, 5, 6, 4] },
    "description": "Find a peak element in the array.",
    "approach": "Use binary search to find an element greater than its neighbors.",
    "code": "public int findPeakElement(int[] nums) {\n    int n = nums.length;\n    int low = 0, high = n - 1;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}"
  },
  {
    "name": "Find Peak Element in 2D Array",
    "endpoint": "/api/binary-search/find-peak-element-2d",
    "methodName": "findPeakElement2D",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "arr": [[1, 4], [3, 2]] },
    "description": "Find a peak element in a 2D array.",
    "approach": "Use binary search on columns to find a peak in 2D.",
    "code": "public int[] findPeakElement2D(int[][] arr) {\n    int n = arr.length;\n    int m = arr[0].length;\n    int low = 0, high = m - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int row = maxElement(arr, mid);\n        int left = mid - 1 >= 0 ? arr[row][mid - 1] : Integer.MIN_VALUE;\n        int right = mid + 1 < m ? arr[row][mid + 1] : Integer.MIN_VALUE;\n        if (arr[row][mid] > left && arr[row][mid] > right) {\n            return new int[]{row, mid};\n        } else if (left > arr[row][mid]) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return new int[]{-1, -1};\n}"
  },
  {
    "name": "Binary Search",
    "endpoint": "/api/binary-search/search",
    "methodName": "search",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [-1, 0, 3, 5, 9, 12], "target": 9 },
    "description": "Search for a target value in a sorted array using binary search.",
    "approach": "Use standard binary search to find the target.",
    "code": "public int search(int[] nums, int target) {\n    int n = nums.length;\n    int low = 0, high = n - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] == target)\n            return mid;\n        else if (target > nums[mid])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}"
  },
  {
    "name": "Search Insert Position",
    "endpoint": "/api/binary-search/search-insert",
    "methodName": "searchInsert",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 3, 5, 6], "target": 5 },
    "description": "Find the index where the target should be inserted in a sorted array.",
    "approach": "Use binary search to find the insert position for the target.",
    "code": "public int searchInsert(int[] nums, int target) {\n    int n = nums.length;\n    int low = 0, high = n - 1;\n    int ans = n;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] >= target) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Lower Bound",
    "endpoint": "/api/binary-search/lower-bound",
    "methodName": "lowerBound",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 2, 3, 4, 5], "x": 2 },
    "description": "Find the index of the first element not less than x in a sorted array.",
    "approach": "Use binary search to find the lower bound for x.",
    "code": "public int lowerBound(int[] nums, int x) {\n    int low = 0, high = nums.length - 1;\n    int ans = nums.length;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] >= x) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Upper Bound",
    "endpoint": "/api/binary-search/upper-bound",
    "methodName": "upperBound",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 2, 3, 4, 5], "x": 2 },
    "description": "Find the index of the first element greater than x in a sorted array.",
    "approach": "Use binary search to find the upper bound for x.",
    "code": "public int upperBound(int[] nums, int x) {\n    int low = 0, high = nums.length - 1;\n    int ans = nums.length;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] > x) {\n            ans = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Search in 2D Matrix (Flattened)",
    "endpoint": "/api/binary-search/search-matrix",
    "methodName": "searchMatrix",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "mat": [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], "target": 3 },
    "description": "Search for a target value in a 2D matrix by treating it as a flattened array.",
    "approach": "Use binary search on the virtual 1D array representation of the matrix.",
    "code": "public boolean searchMatrix(int[][] mat, int target) {\n    int n = mat.length;\n    int m = mat[0].length;\n    int low = 0, high = n * m - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int row = mid / m;\n        int col = mid % m;\n        if (mat[row][col] == target) return true;\n        else if (mat[row][col] < target) low = mid + 1;\n        else high = mid - 1;\n    }\n    return false;\n}"
  },
  {
    "name": "Search in 2D Matrix (Staircase)",
    "endpoint": "/api/binary-search/search-matrix-2d",
    "methodName": "searchMatrix2D",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "matrix": [[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16], [10, 13, 14, 17]], "target": 5 },
    "description": "Search for a target value in a 2D matrix using the staircase search approach.",
    "approach": "Start from the top-right and move left or down based on comparison.",
    "code": "public boolean searchMatrix2D(int[][] matrix, int target) {\n    int n = matrix.length;\n    int m = matrix[0].length;\n    int row = 0, col = m - 1;\n    while (row < n && col >= 0) {\n        if (matrix[row][col] == target) return true;\n        else if (matrix[row][col] < target) row++;\n        else col--;\n    }\n    return false;\n}"
  },
  {
    "name": "Single Non-Duplicate",
    "endpoint": "/api/binary-search/single-non-duplicate",
    "methodName": "singleNonDuplicate",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 1, 2, 3, 3, 4, 4, 8, 8] },
    "description": "Find the single element in a sorted array that appears only once.",
    "approach": "Use binary search to find the unique element by checking neighbors and index parity.",
    "code": "public int singleNonDuplicate(int[] nums) {\n    int n = nums.length;\n    if (n == 1) return nums[0];\n    if (nums[0] != nums[1]) return nums[0];\n    if (nums[n - 1] != nums[n - 2]) return nums[n - 1];\n    int low = 1, high = n - 2;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\n            return nums[mid];\n        }\n        if ((mid % 2 == 1 && nums[mid] == nums[mid - 1])\n            || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}"
  },
  {
    "name": "Smallest Divisor",
    "endpoint": "/api/binary-search/smallest-divisor",
    "methodName": "smallestDivisor",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 2, 5, 9], "limit": 6 },
    "description": "Find the smallest divisor such that the sum of division results is less than or equal to the limit.",
    "approach": "Use binary search on the divisor and check the sum with a helper.",
    "code": "public int smallestDivisor(int[] nums, int limit) {\n    int n = nums.length;\n    if (n > limit) return -1;\n    int maxi = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        maxi = Math.max(maxi, nums[i]);\n    }\n    int low = 1, high = maxi;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (sumByD(nums, mid) <= limit) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}"
  },
  {
    "name": "Floor Square Root",
    "endpoint": "/api/binary-search/floor-sqrt",
    "methodName": "floorSqrt",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "n": 17 },
    "description": "Find the floor of the square root of a number.",
    "approach": "Use binary search to find the largest integer whose square is less than or equal to n.",
    "code": "public long floorSqrt(long n) {\n    long low = 1, high = n;\n    while (low <= high) {\n        long mid = (low + high) / 2;\n        long val = mid * mid;\n        if (val <= n) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return high;\n}"
  },
  {
    "name": "Nth Root of M",
    "endpoint": "/api/binary-search/nth-root",
    "methodName": "nthRoot",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "n": 3, "m": 27 },
    "description": "Find the nth root of m using binary search.",
    "approach": "Use binary search to find the integer x such that x^n = m.",
    "code": "public int nthRoot(int n, int m) {\n    int low = 1, high = m;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int midN = nthRootFunc(mid, n, m);\n        if (midN == 1) {\n            return mid;\n        } else if (midN == 0) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return -1;\n}"
  },
  {
    "name": "Search in Rotated Sorted Array",
    "endpoint": "/api/binary-search/search-in-rotated-array",
    "methodName": "searchInRotatedArray",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [4, 5, 6, 7, 0, 1, 2], "target": 0 },
    "description": "Search for a target value in a rotated sorted array.",
    "approach": "Use binary search with logic to determine which half is sorted.",
    "code": "public int searchInRotatedArray(int[] nums, int target) {\n    int low = 0, high = nums.length - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[low] <= nums[mid]) {\n            if (nums[low] <= target && target <= nums[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if (nums[mid] <= target && target <= nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}"
  },
  {
    "name": "Search in Rotated Sorted Array II",
    "endpoint": "/api/binary-search/search-in-rotated-array-ii",
    "methodName": "searchInRotatedArrayII",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "arr": [2, 5, 6, 0, 0, 1, 2], "target": 0 },
    "description": "Search for a target value in a rotated sorted array that may contain duplicates.",
    "approach": "Use binary search with additional checks for duplicates.",
    "code": "public boolean searchInRotatedArrayII(int[] arr, int target) {\n    int n = arr.length;\n    int low = 0, high = n - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (arr[mid] == target) return true;\n        if (arr[low] == arr[mid] && arr[mid] == arr[high]) {\n            low = low + 1;\n            high = high - 1;\n            continue;\n        }\n        if (arr[low] <= arr[mid]) {\n            if (arr[low] <= target && target <= arr[mid]) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if (arr[mid] <= target && target <= arr[high]) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return false;\n}"
  },
  {
    "name": "Row with Maximum 1s",
    "endpoint": "/api/binary-search/row-with-max-1s",
    "methodName": "rowWithMax1s",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "mat": [[0, 1, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1], [0, 0, 0, 0]] },
    "description": "Find the row with the maximum number of 1s in a binary matrix.",
    "approach": "For each row, use lower bound to count 1s and track the row with the most.",
    "code": "public int rowWithMax1s(int[][] mat) {\n    int n = mat.length;\n    int m = mat[0].length;\n    int cnt_max = 0;\n    int index = -1;\n    for (int i = 0; i < n; i++) {\n        int cnt_ones = m - lowerBound1(mat[i], m, 1);\n        if (cnt_ones > cnt_max) {\n            cnt_max = cnt_ones;\n            index = i;\n        }\n    }\n    return index;\n}"
  },
  {
    "name": "Rose Garden",
    "endpoint": "/api/binary-search/rose-garden",
    "methodName": "roseGarden",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [1, 10, 3, 10, 2], "k": 1, "m": 2 },
    "description": "Find the minimum day to make m bouquets of k adjacent flowers.",
    "approach": "Use binary search on days and check feasibility with a helper.",
    "code": "public int roseGarden(int[] nums, int k, int m) {\n    int n = nums.length;\n    long val = (long) m * k;\n    if (val > n) return -1;\n    int mini = Integer.MAX_VALUE, maxi = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        mini = Math.min(mini, nums[i]);\n        maxi = Math.max(maxi, nums[i]);\n    }\n    int left = mini, right = maxi, ans = -1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (possibleRoseGarden(nums, mid, m, k)) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n}"
  },
  {
    "name": "Minimum Rate to Eat Bananas",
    "endpoint": "/api/binary-search/minimum-rate-to-eat-bananas",
    "methodName": "minimumRateToEatBananas",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [3, 6, 7, 11], "h": 8 },
    "description": "Find the minimum eating speed to finish all bananas in h hours.",
    "approach": "Use binary search on the rate and check total hours with a helper.",
    "code": "public int minimumRateToEatBananas(int[] nums, int h) {\n    int low = 1, high = findMaxBananas(nums);\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int totalH = calculateTotalHours(nums, mid);\n        if (totalH <= h) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}"
  },
  {
    "name": "Minimize Maximum Distance to Gas Station",
    "endpoint": "/api/binary-search/minimise-max-distance",
    "methodName": "minimiseMaxDistance",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "arr": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "k": 9 },
    "description": "Minimize the maximum distance between gas stations after adding k more stations.",
    "approach": "Use binary search on the possible distance and check the number of stations needed.",
    "code": "public double minimiseMaxDistance(int[] arr, int k) {\n    int n = arr.length;\n    double low = 0;\n    double high = 0;\n    for (int i = 0; i < n - 1; i++) {\n        high = Math.max(high, arr[i + 1] - arr[i]);\n    }\n    double diff = 1e-6;\n    while (high - low > diff) {\n        double mid = (low + high) / 2.0;\n        int cnt = numberOfGasStationsRequired(mid, arr);\n        if (cnt > k) {\n            low = mid;\n        } else {\n            high = mid;\n        }\n    }\n    return high;\n}"
  },
  {
    "name": "Largest Subarray Sum Minimized",
    "endpoint": "/api/binary-search/largest-subarray-sum-minimized",
    "methodName": "largestSubarraySumMinimized",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "a": [7, 2, 5, 10, 8], "k": 2 },
    "description": "Split the array into k subarrays to minimize the largest subarray sum.",
    "approach": "Use binary search on the answer and count partitions with a helper.",
    "code": "public int largestSubarraySumMinimized(int[] a, int k) {\n    int low = a[0];\n    int high = 0;\n    for (int i = 0; i < a.length; i++) {\n        low = Math.max(low, a[i]);\n        high += a[i];\n    }\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int partitions = countPartitions(a, mid);\n        if (partitions > k) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low;\n}"
  },
  {
    "name": "Kth Element of Two Sorted Arrays",
    "endpoint": "/api/binary-search/kth-element",
    "methodName": "kthElement",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "a": [2, 3, 6, 7, 9], "b": [1, 4, 8, 10], "k": 5 },
    "description": "Find the kth element in the merged sorted array from two sorted arrays.",
    "approach": "Use binary search to partition both arrays and find the kth element.",
    "code": "public int kthElement(int[] a, int[] b, int k) {\n    int m = a.length;\n    int n = b.length;\n    if (m > n) {\n        return kthElement(b, a, k);\n    }\n    int left = k;\n    int low = Math.max(0, k - n), high = Math.min(k, m);\n    while (low <= high) {\n        int mid1 = (low + high) >> 1;\n        int mid2 = left - mid1;\n        int l1 = (mid1 > 0) ? a[mid1 - 1] : Integer.MIN_VALUE;\n        int l2 = (mid2 > 0) ? b[mid2 - 1] : Integer.MIN_VALUE;\n        int r1 = (mid1 < m) ? a[mid1] : Integer.MAX_VALUE;\n        int r2 = (mid2 < n) ? b[mid2] : Integer.MAX_VALUE;\n        if (l1 <= r2 && l2 <= r1) {\n            return Math.max(l1, l2);\n        } else if (l1 > r2) {\n            high = mid1 - 1;\n        } else {\n            low = mid1 + 1;\n        }\n    }\n    return -1;\n}"
  },
  {
    "name": "Search Range",
    "endpoint": "/api/binary-search/search-range",
    "methodName": "searchRange",
    "serviceFile": "BinarySearchService.java",
    "defaultInput": { "nums": [5, 7, 7, 8, 8, 10], "target": 8 },
    "description": "Find the starting and ending position of a given target value in a sorted array.",
    "approach": "Use binary search to find the first and last occurrence of the target.",
    "code": "public int[] searchRange(int[] nums, int target) {\n    int first = firstOccurrence(nums, target);\n    if(first == -1) return new int[]{-1, -1};\n    int last = lastOccurrence(nums, target);\n    return new int[]{first, last};\n}"
  }
]