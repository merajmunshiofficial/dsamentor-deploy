[
  {
    "name": "Asteroid Collision",
    "endpoint": "/api/stack-and-queue/asteroid-collision",
    "methodName": "asteroidCollision",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "asteroids": [5, 10, -5] },
    "description": "Simulate the collision of asteroids moving in a row and return the state after all collisions.",
    "approach": "1. In this problem, positive integers represent asteroids moving to the right, and negative integers represent asteroids moving to the left.\n2. Asteroids collide only if they're moving in opposite directions (one left, one right).\n3. Use a stack-based approach to simulate the collisions sequentially:\n   a. Create an ArrayList to act as our stack of surviving asteroids.\n   b. Process each asteroid in the array from left to right:\n      i. If the current asteroid is moving right (positive value), simply add it to the stack.\n      ii. If it's moving left (negative value), it may collide with previous asteroids moving right.\n   c. When processing a leftward-moving asteroid, check for collisions with rightward-moving asteroids at the top of the stack:\n      i. If the stack's top asteroid is moving right and has smaller magnitude than the current asteroid, it gets destroyed (pop from stack).\n      ii. Continue this process for all eligible collisions.\n      iii. If the top asteroid has equal magnitude as the current one, both are destroyed.\n      iv. If the top asteroid is larger, the current asteroid is destroyed (don't add to stack).\n      v. If there are no rightward-moving asteroids to collide with, add the current asteroid to the stack.\n4. After processing all asteroids, the stack contains the final state of surviving asteroids.\n5. Convert the ArrayList back to an integer array and return it.\n6. Time Complexity: O(n) where n is the number of asteroids.\n7. Space Complexity: O(n) for the stack in the worst case.",
    "code": "public int[] asteroidCollision(int[] asteroids) {\n    List<Integer> st = new ArrayList<>();\n    for (int a : asteroids) {\n        if (a > 0) {\n            st.add(a);\n        } else {\n            while (!st.isEmpty() && st.get(st.size() - 1) > 0 && st.get(st.size() - 1) < Math.abs(a)) {\n                st.remove(st.size() - 1);\n            }\n            if (!st.isEmpty() && st.get(st.size() - 1) == Math.abs(a)) {\n                st.remove(st.size() - 1);\n            } else if (st.isEmpty() || st.get(st.size() - 1) < 0) {\n                st.add(a);\n            }\n        }\n    }\n    int[] result = new int[st.size()];\n    for (int i = 0; i < st.size(); i++) result[i] = st.get(i);\n    return result;\n}"
  },
  {
    "name": "Celebrity Problem",
    "endpoint": "/api/stack-and-queue/celebrity",
    "methodName": "celebrity",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "matrix": [[0,1,0],[0,0,0],[0,1,0]], "n": 3 },
    "description": "Find the celebrity in a party of n people (if one exists).",
    "approach": "1. A celebrity is defined as someone who is known by everyone but doesn't know anyone else.\n2. The problem uses a matrix M where M[i][j] = 1 means person i knows person j, and M[i][j] = 0 means person i doesn't know person j.\n3. A naive approach would check each person against all others, requiring O(nÂ²) comparisons.\n4. We can optimize this using a two-pointer approach:\n   a. Initialize two pointers: 'top' at the first person (index 0) and 'down' at the last person (index n-1).\n   b. While top < down:\n      i. If top knows down (M[top][down] = 1), then top cannot be a celebrity, so increment top.\n      ii. If top doesn't know down (M[top][down] = 0), then down cannot be a celebrity, so decrement down.\n      iii. In cases where both don't know each other, we can eliminate both (increment top and decrement down).\n   c. After the loop, if top > down, no celebrity exists.\n   d. Otherwise, verify the candidate (top) by checking if:\n      i. The candidate doesn't know anyone else.\n      ii. Everyone else knows the candidate.\n5. This approach reduces the number of comparisons to O(n) in the best case.\n6. Return the index of the celebrity, or -1 if no celebrity exists.\n7. Time Complexity: O(n) for the elimination phase and O(n) for verification.\n8. Space Complexity: O(1) as we only use two pointers regardless of input size.",
    "code": "public int celebrity(int[][] M, int n) {\n    int top = 0, down = n - 1;\n    while (top < down) {\n        if (M[top][down] == 1) {\n            top++;\n        } else if (M[down][top] == 1) {\n            down--;\n        } else {\n            top++;\n            down--;\n        }\n    }\n    if (top > down) return -1;\n    for (int i = 0; i < n; i++) {\n        if (i == top) continue;\n        if (M[top][i] == 1 && M[i][top] == 0) return -1;\n    }\n    return top;\n}"
  },
  {
    "name": "Valid Parentheses",
    "endpoint": "/api/stack-and-queue/is-valid",
    "methodName": "isValid",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "s": "()[]{}" },
    "description": "Check if the input string of brackets is valid (all open brackets are closed in the correct order).",
    "approach": "1. The problem requires checking if a string containing various types of brackets (parentheses, square brackets, curly braces) is valid.\n2. A valid string must have all brackets properly closed in the correct order, following these rules:\n   a. Open brackets must be closed by the same type of brackets.\n   b. Open brackets must be closed in the correct order.\n   c. Every close bracket must have a corresponding open bracket of the same type.\n3. Use a stack data structure to track open brackets and match them with closing brackets:\n   a. Initialize an empty stack.\n   b. Process each character in the string from left to right:\n      i. If it's an opening bracket ('(', '[', '{'), push it onto the stack.\n      ii. If it's a closing bracket (')', ']', '}'), check if the stack is empty (invalid if it is).\n      iii. If not empty, pop the top element from the stack and check if it matches the current closing bracket.\n      iv. If they don't match (e.g., '(' and ']'), the string is invalid.\n   c. After processing all characters, if the stack is empty, all brackets were properly matched and the string is valid.\n   d. If the stack isn't empty, some opening brackets weren't closed, making the string invalid.\n4. Use a helper function to match opening and closing brackets (e.g., '(' matches with ')').\n5. Time Complexity: O(n) where n is the length of the input string.\n6. Space Complexity: O(n) in the worst case when all characters are opening brackets.",
    "code": "public boolean isValid(String str) {\n    Stack<Character> st = new Stack<>();\n    for (char c : str.toCharArray()) {\n        if (c == '(' || c == '[' || c == '{') {\n            st.push(c);\n        } else {\n            if (st.isEmpty()) return false;\n            char ch = st.pop();\n            if (!isMatched(ch, c)) return false;\n        }\n    }\n    return st.isEmpty();\n}\nprivate boolean isMatched(char open, char close) {\n    return (open == '(' && close == ')') ||\n           (open == '[' && close == ']') ||\n           (open == '{' && close == '}');\n}"
  },
  {
    "name": "Largest Rectangle in Histogram",
    "endpoint": "/api/stack-and-queue/largest-rectangle-area",
    "methodName": "largestRectangleArea",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "heights": [2,1,5,6,2,3] },
    "description": "Find the area of the largest rectangle in a histogram.",
    "approach": "1. The problem involves finding the largest rectangular area in a histogram where each bar has width 1.\n2. A key insight is that for each bar, the largest rectangle containing it is limited by the nearest shorter bars on both sides.\n3. We use a stack-based approach to efficiently find these boundaries for each bar:\n   a. Initialize an empty stack to store indices of bars in ascending order of height.\n   b. Initialize a variable to track the largest area found.\n   c. Process each bar from left to right:\n      i. While the stack is not empty and the current bar is shorter than the bar at the top of the stack:\n         - Pop the top bar from the stack, as we've found its right boundary (current bar).\n         - Calculate the area of the rectangle with the popped bar as the shortest: height * width.\n         - The width is (current index - previous stack top - 1) where previous stack top is the left boundary.\n         - Update the largest area if this area is larger.\n      ii. Push the current bar's index onto the stack.\n   d. After processing all bars, some indices may remain in the stack (bars that don't have a shorter bar to their right).\n   e. For these remaining bars, calculate their areas using the right boundary as the end of the histogram.\n4. This approach ensures that we calculate the maximum possible rectangle for each bar in the histogram.\n5. Time Complexity: O(n) where n is the number of bars in the histogram.\n6. Space Complexity: O(n) for the stack in the worst case.",
    "code": "public int largestRectangleArea(int[] heights) {\n    int n = heights.length;\n    Stack<Integer> st = new Stack<>();\n    int largestArea = 0;\n    for (int i = 0; i < n; i++) {\n        while (!st.isEmpty() && heights[st.peek()] >= heights[i]) {\n            int ind = st.pop();\n            int pse = st.isEmpty() ? -1 : st.peek();\n            int nse = i;\n            int area = heights[ind] * (nse - pse - 1);\n            largestArea = Math.max(largestArea, area);\n        }\n        st.push(i);\n    }\n    while (!st.isEmpty()) {\n        int nse = n;\n        int ind = st.pop();\n        int pse = st.isEmpty() ? -1 : st.peek();\n        int area = heights[ind] * (nse - pse - 1);\n        largestArea = Math.max(largestArea, area);\n    }\n    return largestArea;\n}"
  },
  {
    "name": "LFU Cache Simulation",
    "endpoint": "/api/stack-and-queue/lfu-cache",
    "methodName": "lfuCache",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "operations": "[{\"op\":\"put\",\"key\":1,\"value\":1},{\"op\":\"put\",\"key\":2,\"value\":2},{\"op\":\"get\",\"key\":1}]" },
    "description": "Simulate LFU (Least Frequently Used) cache operations and return the results as a list.",
    "approach": "1. LFU (Least Frequently Used) cache is a data structure that evicts the least frequently used item when it reaches capacity.\n2. The implementation requires efficient tracking of access frequency and handling tie-breaking based on time of access.\n3. The approach uses the following components:\n   a. A HashMap to store key-value pairs for O(1) access.\n   b. A HashMap to track the frequency of each key.\n   c. A HashMap mapping frequencies to a LinkedHashSet of keys, which maintains insertion order for tie-breaking.\n   d. A variable to track the minimum frequency for efficient eviction decisions.\n4. The algorithm handles two main operations:\n   a. get(key):\n      i. If the key doesn't exist, return -1.\n      ii. Otherwise, retrieve the value and increment the key's frequency.\n      iii. Remove the key from its current frequency set and add it to the next frequency set.\n      iv. Update the minimum frequency if needed.\n      v. Return the value.\n   b. put(key, value):\n      i. If the cache capacity is 0, do nothing.\n      ii. If the key already exists, update its value and handle the frequency change like in get().\n      iii. If the key is new and the cache is full, evict the least frequent key (tie broken by least recently used).\n      iv. Insert the new key with frequency 1 and update the minimum frequency to 1.\n5. For the simulation, we parse a JSON string of operations, apply them to the LFU cache, and collect the results.\n6. Time Complexity: O(1) for both get and put operations.\n7. Space Complexity: O(capacity) for storing the key-value pairs and frequency information.",
    "code": "public String lfuCache(StackAndQueueRequest.LFUCacheInput request) {\n    // Simulate LFUCache operations from a JSON string\n    try {\n        ObjectMapper mapper = new ObjectMapper();\n        List<Map<String, Object>> ops = mapper.readValue(request.getOperations(), List.class);\n        LFUCacheSim cache = new LFUCacheSim(2); // Default capacity 2, can be extended\n        List<String> results = new ArrayList<>();\n        for (Map<String, Object> op : ops) {\n            String type = (String) op.get(\"op\");\n            if (\"put\".equals(type)) {\n                cache.put((Integer) op.get(\"key\"), (Integer) op.get(\"value\"));\n                results.add(\"null\");\n            } else if (\"get\".equals(type)) {\n                results.add(String.valueOf(cache.get((Integer) op.get(\"key\"))));\n            }\n        }\n        return results.toString();\n    } catch (Exception e) {\n        return \"Invalid operations format: \" + e.getMessage();\n    }\n}\n// LFUCache simulation implementation\nstatic class LFUCacheSim {\n    private Map<Integer, Node> keyNode;\n    private Map<Integer, List> freqListMap;\n    private int maxSizeCache;\n    private int minFreq;\n    private int curSize;\n    \n    public LFUCacheSim(int capacity) {\n        maxSizeCache = capacity;\n        minFreq = 0;\n        curSize = 0;\n        keyNode = new HashMap<>();\n        freqListMap = new HashMap<>();\n    }\n    \n    private void updateFreqListMap(Node node) {\n        keyNode.remove(node.key);\n        freqListMap.get(node.cnt).removeNode(node);\n        if (node.cnt == minFreq && freqListMap.get(node.cnt).size == 0) {\n            minFreq++;\n        }\n        List nextHigherFreqList = freqListMap.getOrDefault(node.cnt + 1, new List());\n        node.cnt += 1;\n        nextHigherFreqList.addFront(node);\n        freqListMap.put(node.cnt, nextHigherFreqList);\n        keyNode.put(node.key, node);\n    }\n    \n    public int get(int key) {\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            int val = node.value;\n            updateFreqListMap(node);\n            return val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (maxSizeCache == 0) return;\n        if (keyNode.containsKey(key)) {\n            Node node = keyNode.get(key);\n            node.value = value;\n            updateFreqListMap(node);\n        } else {\n            if (curSize == maxSizeCache) {\n                List list = freqListMap.get(minFreq);\n                keyNode.remove(list.tail.prev.key);\n                freqListMap.get(minFreq).removeNode(list.tail.prev);\n                curSize--;\n            }\n            curSize++;\n            minFreq = 1;\n            List listFreq = freqListMap.getOrDefault(minFreq, new List());\n            Node node = new Node(key, value);\n            listFreq.addFront(node);\n            keyNode.put(key, node);\n            freqListMap.put(minFreq, listFreq);\n        }\n    }\n    \n    static class Node {\n        int key, value, cnt;\n        Node next, prev;\n        Node(int _key, int _value) { key = _key; value = _value; cnt = 1; }\n    }\n    \n    static class List {\n        int size;\n        Node head, tail;\n        List() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n            size = 0;\n        }\n        void addFront(Node node) {\n            Node temp = head.next;\n            node.next = temp;\n            node.prev = head;\n            head.next = node;\n            temp.prev = node;\n            size++;\n        }\n        void removeNode(Node delnode) {\n            Node prevNode = delnode.prev;\n            Node nextNode = delnode.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n            size--;\n        }\n    }\n}"
  },
  {
    "name": "Stock Span Problem",
    "endpoint": "/api/stack-and-queue/stock-span",
    "methodName": "stockSpan",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "prices": [100, 80, 60, 70, 60, 75, 85] },
    "description": "Calculate the stock span for each day given a list of daily prices.",
    "approach": "1. The stock span problem asks us to find, for each day, the number of consecutive days (including the current day) for which the stock price is less than or equal to the current day's price.\n2. This is equivalent to finding the number of days since the last day with a higher price (or the start of the period if no such day exists).\n3. Use a stack-based approach to efficiently find the previous greater element (PGE) for each price:\n   a. Initialize an empty stack to store indices of prices in decreasing order.\n   b. For each day's price:\n      i. While the stack is not empty and the price at the stack's top index is less than or equal to the current price, pop elements from the stack.\n      ii. If the stack is empty after popping, there's no previous day with a higher price, so the span is the current day index + 1.\n      iii. Otherwise, the span is the difference between the current index and the index at the top of the stack.\n      iv. Push the current index onto the stack.\n   c. After processing all prices, calculate the span for each day as (current index - PGE index).\n4. Example calculation: For [100, 80, 60, 70, 60, 75, 85], the spans are [1, 1, 1, 2, 1, 4, 6].\n5. Time Complexity: O(n) where n is the number of days.\n6. Space Complexity: O(n) for the stack in the worst case.",
    "code": "public int[] stockSpan(int[] prices) {\n    int n = prices.length;\n    int[] PGE = new int[n];\n    Stack<Integer> st = new Stack<>();\n    for (int i = 0; i < n; i++) {\n        while (!st.isEmpty() && prices[st.peek()] <= prices[i]) {\n            st.pop();\n        }\n        PGE[i] = st.isEmpty() ? -1 : st.peek();\n        st.push(i);\n    }\n    int[] ans = new int[n];\n    for (int i = 0; i < n; i++) {\n        ans[i] = i - PGE[i];\n    }\n    return ans;\n}"
  },
  {
    "name": "Sum of Subarray Ranges",
    "endpoint": "/api/stack-and-queue/subarray-ranges",
    "methodName": "subArrayRanges",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "arr": [1, 2, 3] },
    "description": "Find the sum of the ranges (max - min) of all subarrays of the array.",
    "approach": "1. The problem requires calculating the sum of the range (maximum - minimum) of every subarray of the given array.\n2. A naive approach would be to generate all subarrays and find the max and min for each, but this would be O(nÂ³).\n3. We use a more efficient approach based on the observation that the sum of ranges equals the sum of all subarray maximums minus the sum of all subarray minimums.\n4. The algorithm has two main parts:\n   a. Calculate the sum of all subarray maximums using monotonic stacks:\n      i. For each element, determine how many subarrays it's the maximum of by finding the next greater element (NGE) and previous greater or equal element (PGEE).\n      ii. The number of subarrays where the element is the maximum is (i - PGEE[i]) * (NGE[i] - i).\n      iii. Multiply this count by the element's value and sum across all elements.\n   b. Calculate the sum of all subarray minimums using monotonic stacks:\n      i. Similarly, for each element, find how many subarrays it's the minimum of by using next smaller element (NSE) and previous smaller or equal element (PSEE).\n      ii. The number of subarrays is (i - PSEE[i]) * (NSE[i] - i).\n      iii. Multiply by the element's value and sum across all elements.\n5. Subtract the sum of minimums from the sum of maximums to get the final result.\n6. This approach efficiently handles the calculation with a time complexity of O(n).\n7. The monotonic stack techniques help us find the boundaries where each element is the maximum or minimum.\n8. Time Complexity: O(n) where n is the size of the array.\n9. Space Complexity: O(n) for storing the NGE, PGEE, NSE, and PSEE arrays.",
    "code": "public long subArrayRanges(int[] arr) {\n    return sumSubarrayMaxs(arr) - sumSubarrayMins(arr);\n}\nprivate long sumSubarrayMins(int[] arr) {\n    int[] nse = findNSE(arr);\n    int[] psee = findPSEE(arr);\n    int n = arr.length;\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int left = i - psee[i];\n        int right = nse[i] - i;\n        long freq = left * (long) right;\n        long val = freq * arr[i];\n        sum += val;\n    }\n    return sum;\n}\nprivate long sumSubarrayMaxs(int[] arr) {\n    int[] nge = findNGE(arr);\n    int[] pgee = findPGEE(arr);\n    int n = arr.length;\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int left = i - pgee[i];\n        int right = nge[i] - i;\n        long freq = left * (long) right;\n        long val = freq * arr[i];\n        sum += val;\n    }\n    return sum;\n}"
  },
  {
    "name": "Sum of Subarray Minimums",
    "endpoint": "/api/stack-and-queue/sum-subarray-mins",
    "methodName": "sumSubarrayMins",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "arr": [3, 1, 2, 4] },
    "description": "Find the sum of the minimum value of every subarray of the array.",
    "approach": "1. The problem asks for the sum of the minimum values of all possible subarrays of the given array.\n2. A naive approach would be to generate all subarrays and find their minimums, but this would be O(nÂ²) or worse.\n3. Instead, we use a more efficient approach based on contribution technique:\n   a. For each element, we determine how many subarrays have this element as the minimum.\n   b. To find this, we need to know the boundaries where each element is the minimum.\n4. The algorithm works as follows:\n   a. For each element at index i, find:\n      i. The nearest element to the left that is smaller or equal (PSEE - Previous Smaller or Equal Element).\n      ii. The nearest element to the right that is strictly smaller (NSE - Next Smaller Element).\n   b. These boundaries define the range where the current element is the minimum of all subarrays that contain it.\n   c. The number of subarrays where arr[i] is the minimum is (i - PSEE[i]) * (NSE[i] - i).\n   d. Multiply this count by arr[i] to get the total contribution of this element to the sum.\n5. We use monotonic stacks to efficiently find the PSEE and NSE for each element:\n   a. For PSEE, maintain a non-decreasing stack from left to right.\n   b. For NSE, maintain a non-increasing stack from right to left.\n6. Sum up the contributions of all elements to get the final result.\n7. The solution handles potential integer overflow by using long type for intermediate calculations.\n8. Time Complexity: O(n) where n is the size of the array.\n9. Space Complexity: O(n) for the stacks and boundary arrays.",
    "code": "public int sumSubarrayMins(int[] arr) {\n    int[] nse = findNSE(arr);\n    int[] psee = findPSEE(arr);\n    int n = arr.length;\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        int left = i - psee[i];\n        int right = nse[i] - i;\n        long freq = left * (long) right;\n        long val = freq * arr[i];\n        sum += val;\n    }\n    return (int)sum;\n}\nprivate int[] findNSE(int[] arr) {\n    int n = arr.length;\n    int[] ans = new int[n];\n    Stack<Integer> st = new Stack<>();\n    for (int i = n - 1; i >= 0; i--) {\n        while (!st.isEmpty() && arr[st.peek()] >= arr[i]) {\n            st.pop();\n        }\n        ans[i] = !st.isEmpty() ? st.peek() : n;\n        st.push(i);\n    }\n    return ans;\n}\nprivate int[] findPSEE(int[] arr) {\n    int n = arr.length;\n    int[] ans = new int[n];\n    Stack<Integer> st = new Stack<>();\n    for (int i = 0; i < n; i++) {\n        while (!st.isEmpty() && arr[st.peek()] > arr[i]) {\n            st.pop();\n        }\n        ans[i] = !st.isEmpty() ? st.peek() : -1;\n        st.push(i);\n    }\n    return ans;\n}"
  },
  {
    "name": "Trapping Rain Water",
    "endpoint": "/api/stack-and-queue/trap",
    "methodName": "trap",
    "serviceFile": "StackAndQueueService.java",
    "defaultInput": { "height": [0,1,0,2,1,0,1,3,2,1,2,1] },
    "description": "Compute how much water can be trapped after raining given an elevation map.",
    "approach": "1. The problem asks us to calculate the amount of rainwater that can be trapped between bars of varying heights.\n2. The key insight is that for any position i, the water trapped at that position depends on the minimum of the maximum heights to its left and right, minus its own height (if the result is positive).\n3. There are multiple ways to solve this problem. The most efficient is the two-pointer approach:\n   a. Initialize two pointers: left at the beginning and right at the end of the array.\n   b. Also initialize two variables to keep track of the maximum height encountered so far from the left and from the right.\n   c. The idea is to process the bars from both ends, moving inward and calculating water trapped as we go.\n4. The algorithm works as follows:\n   a. While left < right:\n      i. If height[left] is less than or equal to height[right], focus on the left pointer:\n         - If leftMax is greater than the current height, we can trap water at this position equal to (leftMax - height[left]).\n         - Otherwise, update leftMax to the current height as no water can be trapped.\n         - Move the left pointer one step to the right.\n      ii. If height[left] is greater than height[right], focus on the right pointer:\n         - If rightMax is greater than the current height, we can trap water at this position equal to (rightMax - height[right]).\n         - Otherwise, update rightMax to the current height as no water can be trapped.\n         - Move the right pointer one step to the left.\n5. The two-pointer approach works because we only need to know the limiting wall (the smaller of the two max heights) for each position.\n6. By processing bars from both ends and always moving the pointer at the smaller height, we ensure that we have the necessary information to calculate trapped water at each step.\n7. Time Complexity: O(n) where n is the number of bars in the height array.\n8. Space Complexity: O(1) as we only use a constant amount of extra space regardless of input size.",
    "code": "public int trap(int[] height) {\n    int n = height.length;\n    int total = 0;\n    int leftMax = 0, rightMax = 0;\n    int left = 0, right = n - 1;\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            if (leftMax > height[left]) {\n                total += leftMax - height[left];\n            } else leftMax = height[left];\n            left++;\n        } else {\n            if (rightMax > height[right]) {\n                total += rightMax - height[right];\n            } else rightMax = height[right];\n            right--;\n        }\n    }\n    return total;\n}"
  }
]