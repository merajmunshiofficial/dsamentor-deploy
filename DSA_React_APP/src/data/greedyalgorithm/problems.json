[
  {
    "name": "Maximum Number of Meetings",
    "endpoint": "/api/greedy-algorithm/max-meetings",
    "methodName": "maxMeetings",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "start": [1,3,0,5,8,5], "end": [2,4,6,7,9,9] },
    "description": "Find the maximum number of meetings that can be held without overlap.",
    "approach": "Sort meetings by end time and select non-overlapping intervals.",
    "code": "public int maxMeetings(int[] start, int[] end) {\n    int n = start.length;\n    List<int[]> meetings = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        meetings.add(new int[]{start[i], end[i]});\n    }\n    Collections.sort(meetings, (a, b) -> Integer.compare(a[1], b[1]));\n    int limit = meetings.get(0)[1];\n    int count = 1;\n    for (int i = 1; i < n; i++) {\n        if (meetings.get(i)[0] > limit) {\n            limit = meetings.get(i)[1];\n            count++;\n        }\n    }\n    return count;\n}"
  },
  {
    "name": "Maximum Non-Overlapping Intervals",
    "endpoint": "/api/greedy-algorithm/max-non-overlapping-intervals",
    "methodName": "maxNonOverlappingIntervals",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "intervals": [[1,2],[2,3],[3,4],[1,3]] },
    "description": "Find the maximum number of non-overlapping intervals.",
    "approach": "Sort intervals by end time and select intervals that do not overlap.",
    "code": "public int maxNonOverlappingIntervals(List<List<Integer>> intervals) {\n    if (intervals.isEmpty()) return 0;\n    intervals.sort((a, b) -> Integer.compare(a.get(1), b.get(1)));\n    int count = 1;\n    int end = intervals.get(0).get(1);\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals.get(i).get(0) >= end) {\n            count++;\n            end = intervals.get(i).get(1);\n        }\n    }\n    return count;\n}"
  },
  {
    "name": "Insert New Interval",
    "endpoint": "/api/greedy-algorithm/insert-new-interval",
    "methodName": "insertNewInterval",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "intervals": [[1,3],[6,9]], "newInterval": [2,5] },
    "description": "Insert a new interval into a list of sorted intervals and merge if necessary.",
    "approach": "Iterate through intervals, merge overlapping ones, and insert the new interval.",
    "code": "public List<List<Integer>> insertNewInterval(List<List<Integer>> intervals, List<Integer> newInterval) {\n    List<List<Integer>> result = new ArrayList<>();\n    for (List<Integer> interval : intervals) {\n        if (interval.get(1) < newInterval.get(0)) {\n            result.add(interval);\n        } else if (interval.get(0) > newInterval.get(1)) {\n            result.add(newInterval);\n            newInterval = interval;\n        } else {\n            newInterval.set(0, Math.min(newInterval.get(0), interval.get(0)));\n            newInterval.set(1, Math.max(newInterval.get(1), interval.get(1)));\n        }\n    }\n    result.add(newInterval);\n    return result;\n}"
  },
  {
    "name": "Lemonade Change",
    "endpoint": "/api/greedy-algorithm/lemonade-change",
    "methodName": "lemonadeChange",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "bills": [5,5,5,10,20] },
    "description": "Check if it is possible to provide change to every customer in a queue.",
    "approach": "Track the number of $5 and $10 bills and give change greedily.",
    "code": "public boolean lemonadeChange(int[] bills) {\n    int five = 0, ten = 0;\n    for (int bill : bills) {\n        if (bill == 5) {\n            five++;\n        } else if (bill == 10) {\n            if (five == 0) return false;\n            five--;\n            ten++;\n        } else { // bill == 20\n            if (ten > 0 && five > 0) {\n                ten--;\n                five--;\n            } else if (five >= 3) {\n                five -= 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "name": "Job Scheduling with Deadlines and Profits",
    "endpoint": "/api/greedy-algorithm/job-scheduling",
    "methodName": "jobScheduling",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "jobs": [[1,2,100],[2,1,19],[3,2,27],[4,1,25],[5,1,15]] },
    "description": "Schedule jobs to maximize profit given deadlines and profits.",
    "approach": "Sort jobs by profit and assign each to the latest available slot before its deadline.",
    "code": "public int jobScheduling(List<List<Integer>> jobs) {\n    jobs.sort((a, b) -> Integer.compare(b.get(2), a.get(2)));\n    int maxDeadline = 0;\n    for (List<Integer> job : jobs) {\n        maxDeadline = Math.max(maxDeadline, job.get(1));\n    }\n    boolean[] slot = new boolean[maxDeadline + 1];\n    int totalProfit = 0;\n    for (List<Integer> job : jobs) {\n        int deadline = job.get(1);\n        int profit = job.get(2);\n        for (int i = deadline; i > 0; i--) {\n            if (!slot[i]) {\n                slot[i] = true;\n                totalProfit += profit;\n                break;\n            }\n        }\n    }\n    return totalProfit;\n}"
  },
  {
    "name": "Minimum Number of Platforms Required",
    "endpoint": "/api/greedy-algorithm/find-platform",
    "methodName": "findPlatform",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "arr": [900, 940, 950, 1100, 1500, 1800], "dep": [910, 1200, 1120, 1130, 1900, 2000], "n": 6 },
    "description": "Find the minimum number of platforms required for trains so that no train waits.",
    "approach": "Sort arrival and departure times and use two pointers to track platforms needed.",
    "code": "public int findPlatform(int[] arr, int[] dep, int n) {\n    Arrays.sort(arr);\n    Arrays.sort(dep);\n    int platforms = 1;\n    int maxPlatforms = 1;\n    int i = 1, j = 0;\n    while (i < n && j < n) {\n        if (arr[i] <= dep[j]) {\n            platforms++;\n            i++;\n        } else {\n            platforms--;\n            j++;\n        }\n        maxPlatforms = Math.max(maxPlatforms, platforms);\n    }\n    return maxPlatforms;\n}"
  },
  {
    "name": "Maximum Cookies for Students",
    "endpoint": "/api/greedy-algorithm/find-maximum-cookie-students",
    "methodName": "findMaximumCookieStudents",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "g": [1,2,3], "s": [1,1] },
    "description": "Find the maximum number of students who can get cookies based on their greed factor.",
    "approach": "Sort greed and cookie arrays, assign smallest available cookie to each student.",
    "code": "public int findMaximumCookieStudents(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n    int count = 0;\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            count++;\n            i++;\n        }\n        j++;\n    }\n    return count;\n}"
  },
  {
    "name": "Can Jump to Last Index",
    "endpoint": "/api/greedy-algorithm/can-jump",
    "methodName": "canJump",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "nums": [2,3,1,1,4] },
    "description": "Check if it is possible to reach the last index of the array.",
    "approach": "Track the farthest index reachable at each step.",
    "code": "public boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n        if (maxReach >= nums.length - 1) return true;\n    }\n    return true;\n}"
  },
  {
    "name": "Distribute Candies to Children",
    "endpoint": "/api/greedy-algorithm/candy",
    "methodName": "candy",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "ratings": [1,0,2] },
    "description": "Distribute candies to children such that each child has at least one and higher rated children get more than neighbors.",
    "approach": "Use two passes (left-to-right and right-to-left) to ensure all constraints are met.",
    "code": "public int candy(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    Arrays.fill(candies, 1);\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) {\n            candies[i] = candies[i - 1] + 1;\n        }\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) {\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n        }\n    }\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n    return sum;\n}"
  },
  {
    "name": "Valid Parentheses",
    "endpoint": "/api/greedy-algorithm/is-valid",
    "methodName": "isValid",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "s": "()[]{}" },
    "description": "Check if a string of parentheses is valid (all open/close match and are in order).",
    "approach": "Use a stack to match opening and closing brackets.",
    "code": "public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n            char top = stack.pop();\n            if ((c == ')' && top != '(') || \n                (c == '}' && top != '{') || \n                (c == ']' && top != '[')) {\n                return false;\n            }\n        }\n    }\n    return stack.isEmpty();\n}"
  },
  {
    "name": "Generic Greedy Solve",
    "endpoint": "/api/greedy-algorithm/solve",
    "methodName": "solve",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "n": 4, "arr": [1,2,3,4] },
    "description": "Solve a generic greedy problem (implementation may vary by use case).",
    "approach": "Sort the array and accumulate weighted sum as a simple greedy example.",
    "code": "public int solve(int n, int[] arr) {\n    if (n == 0) return 0;\n    Arrays.sort(arr);\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result += arr[i] * (i + 1);\n    }\n    return result;\n}"
  }
]