[
  {
    "name": "Maximum Number of Meetings",
    "endpoint": "/api/greedy-algorithm/max-meetings",
    "methodName": "maxMeetings",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "start": [1,3,0,5,8,5], "end": [2,4,6,7,9,9] },
    "description": "Find the maximum number of meetings that can be held without overlap.",
    "approach": "1. This problem requires finding the maximum number of meetings that can be scheduled without overlaps.\n2. The greedy approach selects meetings that end earliest, allowing us to accommodate as many meetings as possible.\n3. Steps of the algorithm:\n   a. Create a list of meetings with their start and end times.\n   b. Sort the meetings by their end times in ascending order.\n   c. Initialize the count of meetings to 1 (select the first meeting that ends earliest).\n   d. For each subsequent meeting, check if its start time is greater than the end time of the previously selected meeting:\n      - If yes, select this meeting and update the current end time.\n      - If no, skip this meeting as it overlaps with the previously selected one.\n4. The sorting by end time is the key greedy choice - by selecting meetings that end earliest, we maximize the available time for future meetings.\n5. The algorithm works because once we select a meeting, we only need to know its end time to check for overlaps with future meetings.\n6. Time Complexity: O(n log n) where n is the number of meetings, dominated by the sorting operation.\n7. Space Complexity: O(n) for storing the meetings list with start and end times.",
    "code": "public int maxMeetings(int[] start, int[] end) {\n    int n = start.length;\n    List<int[]> meetings = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        meetings.add(new int[]{start[i], end[i]});\n    }\n    Collections.sort(meetings, (a, b) -> Integer.compare(a[1], b[1]));\n    int limit = meetings.get(0)[1];\n    int count = 1;\n    for (int i = 1; i < n; i++) {\n        if (meetings.get(i)[0] > limit) {\n            limit = meetings.get(i)[1];\n            count++;\n        }\n    }\n    return count;\n}"
  },
  {
    "name": "Maximum Non-Overlapping Intervals",
    "endpoint": "/api/greedy-algorithm/max-non-overlapping-intervals",
    "methodName": "maxNonOverlappingIntervals",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "intervals": [[1,2],[2,3],[3,4],[1,3]] },
    "description": "Find the maximum number of non-overlapping intervals.",
    "approach": "1. This problem requires finding the maximum number of non-overlapping intervals from a given set of intervals.\n2. Similar to the maximum meetings problem, the greedy approach selects intervals that end earliest.\n3. Steps of the algorithm:\n   a. Check if the list of intervals is empty; if so, return 0.\n   b. Sort the intervals by their end times in ascending order.\n   c. Initialize the count of selected intervals to 1 (select the first interval that ends earliest).\n   d. Keep track of the end time of the last selected interval.\n   e. For each subsequent interval, check if its start time is greater than or equal to the end time of the previously selected interval:\n      - If yes, select this interval, increment the count, and update the current end time.\n      - If no, skip this interval as it overlaps with the previously selected one.\n4. The greedy choice of selecting intervals by earliest end time ensures we have the maximum time available for future intervals.\n5. This approach is optimal because for any set of mutually non-overlapping intervals, we can replace the first interval with the one that ends earliest without reducing the maximum possible count.\n6. Time Complexity: O(n log n) where n is the number of intervals, dominated by the sorting operation.\n7. Space Complexity: O(1) additional space (excluding the input and output).",
    "code": "public int maxNonOverlappingIntervals(List<List<Integer>> intervals) {\n    if (intervals.isEmpty()) return 0;\n    intervals.sort((a, b) -> Integer.compare(a.get(1), b.get(1)));\n    int count = 1;\n    int end = intervals.get(0).get(1);\n    for (int i = 1; i < intervals.size(); i++) {\n        if (intervals.get(i).get(0) >= end) {\n            count++;\n            end = intervals.get(i).get(1);\n        }\n    }\n    return count;\n}"
  },
  {
    "name": "Insert New Interval",
    "endpoint": "/api/greedy-algorithm/insert-new-interval",
    "methodName": "insertNewInterval",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "intervals": [[1,3],[6,9]], "newInterval": [2,5] },
    "description": "Insert a new interval into a list of sorted intervals and merge if necessary.",
    "approach": "1. This problem requires inserting a new interval into a sorted list of non-overlapping intervals and merging if necessary.\n2. The approach processes each interval in the original list exactly once, comparing it with the new interval and making decisions based on their relationship.\n3. Steps of the algorithm:\n   a. Create a result list to store the final intervals.\n   b. Iterate through each interval in the original list and handle three cases:\n      - Case 1: If the current interval ends before the new interval starts (no overlap), add the current interval to the result list.\n      - Case 2: If the current interval starts after the new interval ends (no overlap), add the new interval to the result list and update the new interval to be the current interval (we'll add it later).\n      - Case 3: If there is an overlap between the current interval and the new interval, merge them by updating the new interval's start and end points to cover both intervals.\n   c. After processing all intervals, add the final version of the new interval to the result list.\n4. The key insight is that we handle the insertion of the new interval as we iterate through the original list, rather than first inserting it and then merging intervals.\n5. In cases where the new interval needs to be merged with multiple original intervals, the merging happens gradually as we encounter each overlapping interval.\n6. Time Complexity: O(n) where n is the number of intervals in the original list.\n7. Space Complexity: O(n) for storing the result list.",
    "code": "public List<List<Integer>> insertNewInterval(List<List<Integer>> intervals, List<Integer> newInterval) {\n    List<List<Integer>> result = new ArrayList<>();\n    for (List<Integer> interval : intervals) {\n        if (interval.get(1) < newInterval.get(0)) {\n            result.add(interval);\n        } else if (interval.get(0) > newInterval.get(1)) {\n            result.add(newInterval);\n            newInterval = interval;\n        } else {\n            newInterval.set(0, Math.min(newInterval.get(0), interval.get(0)));\n            newInterval.set(1, Math.max(newInterval.get(1), interval.get(1)));\n        }\n    }\n    result.add(newInterval);\n    return result;\n}"
  },
  {
    "name": "Lemonade Change",
    "endpoint": "/api/greedy-algorithm/lemonade-change",
    "methodName": "lemonadeChange",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "bills": [5,5,5,10,20] },
    "description": "Check if it is possible to provide change to every customer in a queue.",
    "approach": "1. This problem simulates a lemonade stand where each lemonade costs $5, and customers pay with $5, $10, or $20 bills.\n2. The greedy approach is to always use the largest denomination bills first when giving change.\n3. Steps of the algorithm:\n   a. Keep track of the number of $5 and $10 bills we have (initially zero).\n   b. For each customer's bill:\n      - If they pay with $5: Simply add it to our collection (five++).\n      - If they pay with $10: We must give $5 change. If we don't have a $5 bill, return false. Otherwise, give one $5 bill (five--) and add the $10 to our collection (ten++).\n      - If they pay with $20: We must give $15 change. The greedy choice is to first try to use one $10 and one $5 bill (preferred), or if that's not possible, use three $5 bills. If neither is possible, return false.\n4. The greedy choice is to prefer giving $10 + $5 for change rather than three $5 bills because $5 bills are more versatile (they can be used for both $10 and $20 bills as change).\n5. Time Complexity: O(n) where n is the number of customers (length of the bills array).\n6. Space Complexity: O(1) as we only use two variables to keep track of the bill counts.",
    "code": "public boolean lemonadeChange(int[] bills) {\n    int five = 0, ten = 0;\n    for (int bill : bills) {\n        if (bill == 5) {\n            five++;\n        } else if (bill == 10) {\n            if (five == 0) return false;\n            five--;\n            ten++;\n        } else { // bill == 20\n            if (ten > 0 && five > 0) {\n                ten--;\n                five--;\n            } else if (five >= 3) {\n                five -= 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
  },
  {
    "name": "Job Scheduling with Deadlines and Profits",
    "endpoint": "/api/greedy-algorithm/job-scheduling",
    "methodName": "jobScheduling",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "jobs": [[1,2,100],[2,1,19],[3,2,27],[4,1,25],[5,1,15]] },
    "description": "Schedule jobs to maximize profit given deadlines and profits.",
    "approach": "1. This problem requires scheduling jobs to maximize total profit, where each job has an ID, a deadline, and a profit.\n2. Each job takes exactly one unit of time, and only one job can be scheduled at a time.\n3. The greedy approach is to prioritize jobs with higher profits and schedule them as late as possible before their deadlines.\n4. Steps of the algorithm:\n   a. Sort all jobs in descending order of profit.\n   b. Find the maximum deadline among all jobs to determine the size of the timeline.\n   c. Create a boolean array to track which time slots are already occupied.\n   d. For each job in the sorted list (from highest profit to lowest):\n      - Find the latest available time slot before or at its deadline.\n      - If such a slot exists, schedule the job there and mark the slot as occupied.\n      - Add the job's profit to the total profit.\n5. The key insight is that it's always optimal to schedule the highest profit jobs first, as long as we can find a valid slot before their deadline.\n6. By trying to schedule jobs as late as possible (starting from their deadline and moving backward), we leave earlier slots open for other jobs with earlier deadlines.\n7. Time Complexity: O(n log n + n*m) where n is the number of jobs and m is the maximum deadline.\n   - O(n log n) for sorting the jobs by profit.\n   - O(n*m) for scheduling each job (potentially checking all slots for each job).\n8. Space Complexity: O(m) for the boolean array tracking occupied slots.",
    "code": "public int jobScheduling(List<List<Integer>> jobs) {\n    jobs.sort((a, b) -> Integer.compare(b.get(2), a.get(2)));\n    int maxDeadline = 0;\n    for (List<Integer> job : jobs) {\n        maxDeadline = Math.max(maxDeadline, job.get(1));\n    }\n    boolean[] slot = new boolean[maxDeadline + 1];\n    int totalProfit = 0;\n    for (List<Integer> job : jobs) {\n        int deadline = job.get(1);\n        int profit = job.get(2);\n        for (int i = deadline; i > 0; i--) {\n            if (!slot[i]) {\n                slot[i] = true;\n                totalProfit += profit;\n                break;\n            }\n        }\n    }\n    return totalProfit;\n}"
  },
  {
    "name": "Minimum Number of Platforms Required",
    "endpoint": "/api/greedy-algorithm/find-platform",
    "methodName": "findPlatform",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "arr": [900, 940, 950, 1100, 1500, 1800], "dep": [910, 1200, 1120, 1130, 1900, 2000], "n": 6 },
    "description": "Find the minimum number of platforms required for trains so that no train waits.",
    "approach": "1. This problem requires finding the minimum number of platforms needed at a railway station so that no train has to wait.\n2. The key insight is that the number of platforms needed at any time is equal to the number of trains present at the station at that time.\n3. Steps of the algorithm:\n   a. Sort the arrival times array in ascending order.\n   b. Sort the departure times array in ascending order (independent of arrival array).\n   c. Use two pointers, i for arrivals and j for departures, both starting at the beginning of their respective arrays.\n   d. Initialize platform count to 1 (for the first train) and maximum platforms to 1.\n   e. Compare the current arrival and departure times:\n      - If a train arrives before or at the same time as the earliest departure (arr[i] <= dep[j]), a new platform is needed (platforms++) and move to the next arrival (i++).\n      - If a departure happens before any new arrival (arr[i] > dep[j]), a platform becomes available (platforms--) and move to the next departure (j++).\n      - Update the maximum number of platforms needed at any point.\n4. This approach works because we're processing all events (arrivals and departures) in chronological order.\n5. After sorting, we've decoupled arrivals from departures, but we maintain the correct count of trains at the station.\n6. Time Complexity: O(n log n) where n is the number of trains, dominated by the sorting operations.\n7. Space Complexity: O(1) additional space (excluding the input and output).",
    "code": "public int findPlatform(int[] arr, int[] dep, int n) {\n    Arrays.sort(arr);\n    Arrays.sort(dep);\n    int platforms = 1;\n    int maxPlatforms = 1;\n    int i = 1, j = 0;\n    while (i < n && j < n) {\n        if (arr[i] <= dep[j]) {\n            platforms++;\n            i++;\n        } else {\n            platforms--;\n            j++;\n        }\n        maxPlatforms = Math.max(maxPlatforms, platforms);\n    }\n    return maxPlatforms;\n}"
  },
  {
    "name": "Maximum Cookies for Students",
    "endpoint": "/api/greedy-algorithm/find-maximum-cookie-students",
    "methodName": "findMaximumCookieStudents",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "g": [1,2,3], "s": [1,1] },
    "description": "Find the maximum number of students who can get cookies based on their greed factor.",
    "approach": "1. This problem involves distributing cookies to students, where each student has a greed factor g[i] and each cookie has a size s[j].\n2. A student is content if they receive a cookie that is at least as large as their greed factor.\n3. The goal is to maximize the number of content students.\n4. The greedy approach is to match the smallest sufficient cookie with the student having the smallest greed factor.\n5. Steps of the algorithm:\n   a. Sort both the greed factors array (g) and the cookie sizes array (s) in ascending order.\n   b. Use two pointers, i for students and j for cookies, both starting at the beginning of their respective arrays.\n   c. For each cookie:\n      - If the current cookie size is sufficient for the current student (s[j] >= g[i]), assign it to that student, increment the content student count, and move to the next student (i++).\n      - Always move to the next cookie (j++) after each comparison.\n6. The key insight is that there's no advantage in giving a student a cookie much larger than their greed factor when that cookie could potentially satisfy another student with a larger greed factor.\n7. By starting with the student with the smallest greed factor, we ensure we use cookies efficiently.\n8. Time Complexity: O(n log n + m log m) where n is the number of students and m is the number of cookies, dominated by the sorting operations.\n9. Space Complexity: O(1) additional space (excluding the input and output).",
    "code": "public int findMaximumCookieStudents(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n    int count = 0;\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            count++;\n            i++;\n        }\n        j++;\n    }\n    return count;\n}"
  },
  {
    "name": "Can Jump to Last Index",
    "endpoint": "/api/greedy-algorithm/can-jump",
    "methodName": "canJump",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "nums": [2,3,1,1,4] },
    "description": "Check if it is possible to reach the last index of the array.",
    "approach": "1. This problem asks whether it's possible to jump from the first position to the last position in an array, where each value represents the maximum jump length from that position.\n2. The greedy approach is to track the farthest position that can be reached from any position visited so far.\n3. Steps of the algorithm:\n   a. Initialize a variable maxReach to 0, representing the farthest position reachable.\n   b. Iterate through each position in the array:\n      - If the current position i is beyond our maximum reach (i > maxReach), return false because we cannot reach this position.\n      - Update maxReach to be the maximum of the current maxReach and i + nums[i] (the furthest we can jump from the current position).\n      - If at any point maxReach is greater than or equal to the last index, return true because we can reach the end.\n4. The key insight is that we don't need to try all possible jump combinations. We only need to know if we can reach each position and what the furthest position we can jump to from there.\n5. As we iterate through the array, if we can reach a position i, we can also reach all positions between our previous position and i.\n6. If at any point we find that we can't reach position i (because i > maxReach), we know we can't reach any position beyond i either, so we can immediately return false.\n7. Time Complexity: O(n) where n is the length of the array.\n8. Space Complexity: O(1) as we only use a single variable to track the maximum reachable position.",
    "code": "public boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n        if (maxReach >= nums.length - 1) return true;\n    }\n    return true;\n}"
  },
  {
    "name": "Distribute Candies to Children",
    "endpoint": "/api/greedy-algorithm/candy",
    "methodName": "candy",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "ratings": [1,0,2] },
    "description": "Distribute candies to children such that each child has at least one and higher rated children get more than neighbors.",
    "approach": "1. This problem requires distributing candies to children based on their ratings, with two rules:\n   - Each child must have at least one candy.\n   - Children with higher ratings than their neighbors must get more candies than their neighbors.\n2. The greedy approach uses two passes through the array to ensure all constraints are satisfied.\n3. Steps of the algorithm:\n   a. Initialize an array of size n (number of children) with all values set to 1 (everyone gets at least one candy).\n   b. First pass (left to right): Ensure that each child has more candies than the child to their left if they have a higher rating.\n      - For each child from index 1 to n-1:\n        * If ratings[i] > ratings[i-1], set candies[i] = candies[i-1] + 1.\n   c. Second pass (right to left): Ensure that each child has more candies than the child to their right if they have a higher rating.\n      - For each child from index n-2 down to 0:\n        * If ratings[i] > ratings[i+1], set candies[i] = max(candies[i], candies[i+1] + 1).\n   d. Sum up all the candies in the array to get the minimum total required.\n4. The key insight is that we need two passes to handle both directions of the constraints (higher rated than left neighbor, higher rated than right neighbor).\n5. The first pass ensures the relative ordering with respect to left neighbors is correct.\n6. The second pass ensures the relative ordering with respect to right neighbors is correct, while preserving the constraints established in the first pass (that's why we take the maximum).\n7. Time Complexity: O(n) where n is the number of children (length of the ratings array).\n8. Space Complexity: O(n) for the candies array.",
    "code": "public int candy(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    Arrays.fill(candies, 1);\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) {\n            candies[i] = candies[i - 1] + 1;\n        }\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) {\n            candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n        }\n    }\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n    return sum;\n}"
  },
  {
    "name": "Valid Parentheses",
    "endpoint": "/api/greedy-algorithm/is-valid",
    "methodName": "isValid",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "s": "()[]{}" },
    "description": "Check if a string of parentheses is valid (all open/close match and are in order).",
    "approach": "1. This problem requires checking if a string containing various types of brackets is valid (all open brackets have corresponding closing brackets in the correct order).\n2. The approach uses a stack data structure to track opening brackets and match them with closing brackets.\n3. Steps of the algorithm:\n   a. Initialize an empty stack.\n   b. Iterate through each character in the input string:\n      - If the current character is an opening bracket ('(', '{', or '['), push it onto the stack.\n      - If the current character is a closing bracket (')', '}', or ']'):\n        * If the stack is empty, return false (no matching opening bracket).\n        * Pop the top element from the stack and check if it matches the current closing bracket:\n          - '(' should match with ')'.\n          - '{' should match with '}'.\n          - '[' should match with ']'.\n        * If there's a mismatch, return false.\n   c. After processing all characters, check if the stack is empty:\n      - If empty, all brackets were properly matched, so return true.\n      - If not empty, there are unclosed opening brackets, so return false.\n4. This approach effectively uses the Last-In-First-Out (LIFO) property of stacks to match the most recent opening bracket with the current closing bracket.\n5. Time Complexity: O(n) where n is the length of the string.\n6. Space Complexity: O(n) in the worst case, when all characters are opening brackets.",
    "code": "public boolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.isEmpty()) return false;\n            char top = stack.pop();\n            if ((c == ')' && top != '(') || \n                (c == '}' && top != '{') || \n                (c == ']' && top != '[')) {\n                return false;\n            }\n        }\n    }\n    return stack.isEmpty();\n}"
  },
  {
    "name": "Generic Greedy Solve",
    "endpoint": "/api/greedy-algorithm/solve",
    "methodName": "solve",
    "serviceFile": "GreedyAlgorithmService.java",
    "defaultInput": { "n": 4, "arr": [1,2,3,4] },
    "description": "Solve a generic greedy problem (implementation may vary by use case).",
    "approach": "1. This is a generic example of a greedy algorithm implementation.\n2. For this specific implementation, the approach sorts the input array and computes a weighted sum of its elements.\n3. Steps of the algorithm:\n   a. Check if the array is empty (n = 0), if so, return 0.\n   b. Sort the array in ascending order.\n   c. Compute a weighted sum where each element arr[i] is multiplied by its position + 1 (i+1).\n4. This is a common pattern in greedy algorithms: sort the input data according to some criteria and then process it in that order.\n5. The specific weighting scheme used here (multiplying by position + 1) could represent various real-world problems, such as:\n   - Minimizing waiting times in job scheduling.\n   - Optimizing resource allocation based on priority.\n   - Computing weighted averages where more recent items have higher weights.\n6. Time Complexity: O(n log n) where n is the length of the array, dominated by the sorting operation.\n7. Space Complexity: O(1) additional space (excluding the input and output).",
    "code": "public int solve(int n, int[] arr) {\n    if (n == 0) return 0;\n    Arrays.sort(arr);\n    int result = 0;\n    for (int i = 0; i < n; i++) {\n        result += arr[i] * (i + 1);\n    }\n    return result;\n}"
  }
]