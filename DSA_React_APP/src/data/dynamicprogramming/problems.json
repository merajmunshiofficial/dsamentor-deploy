[
  {
    "name": "Climb Stairs",
    "endpoint": "/api/dynamic-programming/climb-stairs",
    "methodName": "climbStairs",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 5 },
    "description": "Given a staircase with n steps, calculate the total number of distinct ways to reach the top if you can climb either 1 or 2 steps at a time. For example, with n = 5, the total ways are 8 because: 1. [1,1,1,1,1], 2. [1,1,1,2], 3. [1,1,2,1], 4. [1,2,1,1], 5. [2,1,1,1], 6. [1,2,2], 7. [2,1,2], 8. [2,2,1]. Each sequence represents a valid way to climb the stairs, and we need to count all such unique sequences.",
    "approach": "1. The problem asks us to count the number of ways to climb to the nth stair when we can take either 1 or 2 steps at a time.\n2. This is a classic dynamic programming problem that follows the pattern of the Fibonacci sequence.\n3. To solve it, we create a bottom-up dynamic programming approach:\n   a. Define a DP array where dp[i] represents the number of ways to reach the ith stair.\n   b. Set the base cases: dp[0] = 1 (one way to reach the 0th stair - don't climb at all) and dp[1] = 1 (one way to reach the 1st stair - take one step).\n   c. For each stair i from 2 to n, the number of ways to reach it is the sum of ways to reach the previous stair (dp[i-1]) and the stair before that (dp[i-2]).\n      - This is because we can either take a single step from stair i-1 or take a 2-step from stair i-2.\n4. The recurrence relation is: dp[i] = dp[i-1] + dp[i-2]\n5. For example, with n = 5:\n   - dp[0] = 1 (base case)\n   - dp[1] = 1 (base case)\n   - dp[2] = dp[1] + dp[0] = 1 + 1 = 2\n   - dp[3] = dp[2] + dp[1] = 2 + 1 = 3\n   - dp[4] = dp[3] + dp[2] = 3 + 2 = 5\n   - dp[5] = dp[4] + dp[3] = 5 + 3 = 8\n   So there are 8 different ways to climb to the 5th stair.\n6. Time Complexity: O(n) as we iterate from 2 to n once.\n7. Space Complexity: O(n) for storing the dp array, though this could be optimized to O(1) since we only need the last two values at any point.",
    "code": "public int climbStairs(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}"
  },
  {
    "name": "0/1 Knapsack",
    "endpoint": "/api/dynamic-programming/knapsack-01",
    "methodName": "knapsack01",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "wt": [1, 2, 4, 5], "val": [5, 4, 8, 6], "n": 4, "W": 5 },
    "description": "Given n items where each item has a weight and a value, find the maximum value subset of items that can fit in a knapsack of capacity W. Each item can be taken at most once (0/1 property). For example, with weights [1,2,4,5] and values [5,4,8,6], and capacity W=5, we can take items with weights [1,4] achieving maximum value of 13 (5+8). Or with weights [2,4] getting value 12 (4+8). By systematically evaluating all valid combinations, we can determine that [1,4] gives the optimal solution of value 13.",
    "approach": "1. The 0/1 Knapsack problem involves selecting items to maximize value while staying within a weight constraint.\n2. The key constraint is that each item can either be taken in its entirety (1) or left out (0) - hence the name \"0/1 Knapsack\".\n3. We use a top-down dynamic programming approach with memoization, which involves:\n   a. Creating a 2D DP array where dp[i][w] represents the maximum value that can be obtained using the first i items with weight capacity w.\n   b. For each item, we have two choices: either take it or leave it.\n4. The recursive logic works as follows:\n   a. Base cases:\n      i. If there are no items left (ind < 0) or the knapsack has no capacity (W = 0), return 0.\n   b. Recursive cases:\n      i. For each item at index ind, consider two options:\n         - Not taking the item: Get the maximum value without including the current item.\n         - Taking the item: If the item's weight fits in the remaining capacity, add its value plus the maximum value obtainable with the remaining capacity and previous items.\n      ii. Choose the maximum of these two options.\n   c. Use memoization to avoid recalculating states we've already seen.\n5. The implementation uses a 2D array dp[n][W+1] for memoization, where n is the number of items and W is the knapsack capacity.\n6. For example, with weights [1, 2, 4, 5], values [5, 4, 8, 6], n=4, W=5:\n   - When considering the 4th item (ind=3), we can either leave it (W=5 remains) or take it (but its weight is 5, so W=0 remains).\n   - The maximum value we get is max(knapsack01Helper(2, 5), 6 + knapsack01Helper(2, 0)) = max of previous items with W=5, or value of current item (6) plus previous items with W=0.\n7. Time Complexity: O(n * W) where n is the number of items and W is the knapsack capacity.\n8. Space Complexity: O(n * W) for the memoization table, plus O(n) for the recursion stack in the worst case.",
    "code": "public int knapsack01(int[] wt, int[] val, int n, int W) {\n    int[][] dp = new int[n][W + 1];\n    for (int[] row : dp) {\n        Arrays.fill(row, -1);\n    }\n    return knapsack01Helper(wt, val, n - 1, W, dp);\n}\n\nprivate int knapsack01Helper(int[] wt, int[] val, int ind, int W, int[][] dp) {\n    if (ind < 0 || W == 0) {\n        return 0;\n    }\n    if (dp[ind][W] != -1) {\n        return dp[ind][W];\n    }\n    int notTaken = knapsack01Helper(wt, val, ind - 1, W, dp);\n    int taken = 0;\n    if (wt[ind] <= W) {\n        taken = val[ind] + knapsack01Helper(wt, val, ind - 1, W - wt[ind], dp);\n    }\n    dp[ind][W] = Math.max(notTaken, taken);\n    return dp[ind][W];\n}"
  },
  {
    "name": "Frog Jump",
    "endpoint": "/api/dynamic-programming/frog-jump",
    "methodName": "frogJump",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "heights": [10, 20, 30, 10] },
    "description": "A frog is trying to cross a river. Starting from stone 1, it can jump to stone i+1 or i+2. The energy cost of jumping from stone i to stone j is the absolute difference between their heights |heights[j] - heights[i]|. Find the minimum total energy needed to reach the last stone. For example, with heights [10,20,30,10]: If the frog jumps one step each time (10→20→30→10), energy cost is |20-10| + |30-20| + |10-30| = 10+10+20 = 40. If it jumps using combination of 1 and 2 steps (10→30→10), energy cost is |30-10| + |10-30| = 20+20 = 40. After trying all possible jump combinations, we find that 40 is the minimum possible energy cost.",
    "approach": "1. The Frog Jump problem involves a frog that can jump either 1 or 2 steps at a time and wants to minimize the energy spent.\n2. The energy required for a jump is the absolute difference in heights between the starting and ending positions.\n3. We need to find the minimum total energy required to reach the last stone from the first one.\n4. This is a classic dynamic programming problem that can be solved using a top-down approach with memoization:\n   a. We define a state dp[i] that represents the minimum energy required to reach position i from position 0.\n   b. Starting from the last position (n-1), we work backward to calculate the minimum energy for each position.\n5. For each position i, the frog can jump to it from either position i-1 (taking 1 step) or position i-2 (taking 2 steps):\n   a. If jumping from position i-1, the energy cost is dp[i-1] + abs(heights[i] - heights[i-1])\n   b. If jumping from position i-2, the energy cost is dp[i-2] + abs(heights[i] - heights[i-2]) (only if i > 1)\n   c. We take the minimum of these two options.\n6. The base case is dp[0] = 0, as no energy is required to start at the first position.\n7. Example with heights [10, 20, 30, 10]:\n   - dp[0] = 0 (base case)\n   - dp[1] = dp[0] + abs(20 - 10) = 0 + 10 = 10\n   - dp[2] = min(dp[1] + abs(30 - 20), dp[0] + abs(30 - 10)) = min(10 + 10, 0 + 20) = 20\n   - dp[3] = min(dp[2] + abs(10 - 30), dp[1] + abs(10 - 20)) = min(20 + 20, 10 + 10) = 20\n   So the minimum energy required is 20.\n8. Time Complexity: O(n) where n is the number of stones.\n9. Space Complexity: O(n) for the memoization array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int frogJump(int[] heights) {\n    int n = heights.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    return frogJumpHelper(n - 1, heights, dp);\n}\n\nprivate int frogJumpHelper(int ind, int[] heights, int[] dp) {\n    if (ind == 0) return 0;\n    if (dp[ind] != -1) return dp[ind];\n    int jumpOne = frogJumpHelper(ind - 1, heights, dp) + Math.abs(heights[ind] - heights[ind - 1]);\n    int jumpTwo = Integer.MAX_VALUE;\n    if (ind > 1)\n        jumpTwo = frogJumpHelper(ind - 2, heights, dp) + Math.abs(heights[ind] - heights[ind - 2]);\n    return dp[ind] = Math.min(jumpOne, jumpTwo);\n}"
  },
  {
    "name": "Frog Jump K Steps",
    "endpoint": "/api/dynamic-programming/frog-jump-k",
    "methodName": "frogJumpK",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "heights": [10, 20, 30, 10], "k": 2 },
    "description": "A frog can jump up to k steps at a time. For each jump from stone i to j, it loses energy equal to the absolute difference of their heights |heights[j] - heights[i]|. Find the minimum energy needed to reach the last stone. For example, with heights [10,20,30,10] and k=2: The frog can either jump one step at a time (10→20→30→10) costing |20-10|+|30-20|+|10-30| = 40 energy, or use a mix of 1 and 2 steps (10→30→10) costing |30-10|+|10-30| = 40 energy, or other combinations. After trying all possible jump patterns within k=2 steps, we find 40 is the minimum energy needed.",
    "approach": "1. The Frog Jump K Steps problem is an extension of the basic Frog Jump problem, where the frog can now jump up to K steps at a time instead of just 1 or 2.\n2. We need to find the minimum energy required for the frog to reach the last stone from the first one, where the energy cost for a jump is the absolute difference in heights.\n3. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i] as the minimum energy required to reach position i from position 0.\n   b. For each position i, the frog can jump from any of the previous k positions (i-1, i-2, ..., i-k) if they are valid.\n   c. We need to find the jump that minimizes the energy cost.\n4. The recurrence relation is:\n   dp[i] = min(dp[i-j] + |heights[i] - heights[i-j]|) for all j from 1 to k where i-j ≥ 0\n5. The base case is dp[0] = 0, as no energy is required to start at the first position.\n6. For example, with heights [10, 20, 30, 10] and k = 2:\n   - dp[0] = 0 (base case)\n   - dp[1] = dp[0] + abs(20 - 10) = 0 + 10 = 10 (can only jump from position 0)\n   - dp[2] = min(dp[1] + abs(30 - 20), dp[0] + abs(30 - 10)) = min(10 + 10, 0 + 20) = 20\n   - dp[3] = min(dp[2] + abs(10 - 30), dp[1] + abs(10 - 20)) = min(20 + 20, 10 + 10) = 20\n   So the minimum energy required is 20.\n7. If k were larger, we would check more previous positions for each step.\n8. The implementation uses memoization to avoid recalculating states we've already computed.\n9. Time Complexity: O(n * k) where n is the number of stones and k is the maximum number of steps the frog can take.\n10. Space Complexity: O(n) for the memoization array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int frogJumpK(int[] heights, int k) {\n    int n = heights.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    return frogJumpKHelper(n - 1, heights, k, dp);\n}\n\nprivate int frogJumpKHelper(int ind, int[] heights, int k, int[] dp) {\n    if (ind == 0) return 0;\n    if (dp[ind] != -1) return dp[ind];\n    int minEnergy = Integer.MAX_VALUE;\n    for (int j = 1; j <= k; j++) {\n        if (ind - j >= 0) {\n            int energy = frogJumpKHelper(ind - j, heights, k, dp) + Math.abs(heights[ind] - heights[ind - j]);\n            minEnergy = Math.min(minEnergy, energy);\n        }\n    }\n    return dp[ind] = minEnergy;\n}"
  },
  {
    "name": "House Robber",
    "endpoint": "/api/dynamic-programming/house-robber",
    "methodName": "houseRobber",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "nums": [2, 7, 9, 3, 1] },
    "description": "A professional robber plans to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a row. The only constraint stopping the robber is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. For example, with money in houses [2,7,9,3,1], the maximum amount you can rob is 12: rob house 1 (with 2) + rob house 3 (with 9) + rob house 5 (with 1) = 12. If you try other combinations like [7,3] = 10 or [2,9,1] = 12, you'll find that [2,9,1] gives the optimal solution without robbing any adjacent houses.",
    "approach": "1. The House Robber problem asks us to find the maximum amount of money that can be robbed from a row of houses without robbing adjacent houses.\n2. This is a classic dynamic programming problem that can be approached with a top-down (recursive with memoization) strategy.\n3. We define a state dp[i] that represents the maximum amount of money that can be robbed up to and including house i.\n4. For each house at index i, we have two choices:\n   a. Rob the current house: In this case, we add its value to the maximum amount that can be robbed up to i-2 (since we can't rob adjacent houses).\n   b. Skip the current house: In this case, the maximum amount is the same as the maximum amount up to i-1.\n5. The recurrence relation is: dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n6. The base cases are:\n   a. dp[-1] = 0 (no houses to rob)\n   b. dp[0] = nums[0] (only one house to rob)\n7. Example with nums = [2, 7, 9, 3, 1]:\n   - Start with the last house (ind = 4):\n     - If we rob it, we get 1 + houseRobberHelper(2) = 1 + 11 = 12\n     - If we don't rob it, we get houseRobberHelper(3) = 12\n     - Maximum is 12\n   - For ind = 3:\n     - If we rob it, we get 3 + houseRobberHelper(1) = 3 + 7 = 10\n     - If we don't rob it, we get houseRobberHelper(2) = 11\n     - Maximum is 11\n   - For ind = 2:\n     - If we rob it, we get 9 + houseRobberHelper(0) = 9 + 2 = 11\n     - If we don't rob it, we get houseRobberHelper(1) = 7\n     - Maximum is 11\n   - For ind = 1:\n     - If we rob it, we get 7 + houseRobberHelper(-1) = 7 + 0 = 7\n     - If we don't rob it, we get houseRobberHelper(0) = 2\n     - Maximum is 7\n   - For ind = 0:\n     - Only one house, so the answer is 2\n   The final answer is 12.\n8. Time Complexity: O(n) where n is the number of houses.\n9. Space Complexity: O(n) for the memoization array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int houseRobber(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    return houseRobberHelper(n - 1, nums, dp);\n}\n\nprivate int houseRobberHelper(int ind, int[] nums, int[] dp) {\n    if (ind < 0) return 0;\n    if (dp[ind] != -1) return dp[ind];\n    int pick = nums[ind] + houseRobberHelper(ind - 2, nums, dp);\n    int notPick = houseRobberHelper(ind - 1, nums, dp);\n    return dp[ind] = Math.max(pick, notPick);\n}"
  },
  {
    "name": "Unbounded Knapsack",
    "endpoint": "/api/dynamic-programming/unbounded-knapsack",
    "methodName": "unboundedKnapsack",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "wt": [2, 3, 4], "val": [1, 2, 5], "n": 3, "W": 7 },
    "description": "Given n items where each item has a weight and a value, and a knapsack of capacity W, find the maximum value subset of items that can fit in the knapsack. Unlike 0/1 knapsack, here you can use each item any number of times. For example, with weights [2,3,4] and values [1,2,5], and capacity W=7: We could take item 1 three times (weight 6, value 3), or items 2,2,3 (weight 6, value 4), or items 1,4 (weight 6, value 6). After trying all possibilities including using items multiple times, we find that taking item 3 once and item 2 once (weight 7, value 7) gives the maximum value.",
    "approach": "1. The Unbounded Knapsack problem is a variation of the 0/1 Knapsack problem where we can pick an item multiple times (unlimited supply of each item).\n2. The goal remains the same: maximize the total value while keeping the total weight within the knapsack capacity.\n3. Unlike the 0/1 Knapsack where each item can be taken at most once, here we can take as many instances of an item as we want as long as we don't exceed the capacity.\n4. We use a bottom-up dynamic programming approach with a 1D array (instead of a 2D array used in 0/1 Knapsack):\n   a. Create a DP array dp[] of size W+1 where dp[j] represents the maximum value that can be obtained with a knapsack of capacity j.\n   b. Initialize dp[0] = 0 (base case: with 0 capacity, we can't include any items).\n   c. For each item i:\n      i. For each capacity j from the weight of the current item to the maximum capacity:\n         - Consider taking the current item and add its value to the maximum value achievable with the remaining capacity.\n         - Update dp[j] if this gives a better result than the current dp[j].\n5. The recurrence relation is: dp[j] = max(dp[j], dp[j-wt[i]] + val[i]) for all valid j.\n6. Example with weights [2, 3, 4], values [1, 2, 5], and W = 7:\n   - Initialize dp = [0, 0, 0, 0, 0, 0, 0, 0]\n   - Process item 0 (wt=2, val=1):\n     - dp[2] = max(dp[2], dp[0] + 1) = 1\n     - dp[3] = max(dp[3], dp[1] + 1) = 1\n     - ...\n     - dp[7] = max(dp[7], dp[5] + 1) = 3\n   - After all items, dp[7] = 12 (maximum value with capacity 7)\n7. Time Complexity: O(n * W) where n is the number of items and W is the knapsack capacity.\n8. Space Complexity: O(W) for the dp array, much more efficient than the O(n * W) required for the 0/1 Knapsack problem.",
    "code": "public int unboundedKnapsack(int[] wt, int[] val, int n, int W) {\n    int[] dp = new int[W + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = wt[i]; j <= W; j++) {\n            dp[j] = Math.max(dp[j], dp[j - wt[i]] + val[i]);\n        }\n    }\n    return dp[W];\n}"
  },
  {
    "name": "Rod Cutting",
    "endpoint": "/api/dynamic-programming/rod-cutting",
    "methodName": "rodCutting",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "price": [2, 5, 7, 8, 10], "n": 5 },
    "description": "Given a rod of length n and an array of prices where price[i-1] is the value of a rod piece of length i, determine how to cut the rod into pieces to maximize the total value. For example, with prices [2,5,7,8,10] for lengths 1 to 5: If we have a rod of length 5, we could cut it as [1,1,1,1,1] for value 10 (5×2), or [2,3] for value 12 (5+7), or [5] for value 10, etc. After trying all possible cutting combinations, we find that cutting it into lengths of 2 and 3 (price[1] + price[2] = 5 + 7) gives the maximum value of 12.",
    "approach": "1. The Rod Cutting problem asks us to find the maximum profit that can be obtained by cutting a rod of length n into smaller pieces.\n2. We're given a price array where price[i-1] represents the value of a rod piece of length i.\n3. This is actually a variation of the Unbounded Knapsack problem, where:\n   a. The items are the rod pieces of different lengths.\n   b. The weights are the lengths of the pieces.\n   c. The values are the prices of the pieces.\n   d. The capacity is the total rod length n.\n   e. We can use each piece length multiple times (unbounded).\n4. We use a bottom-up dynamic programming approach with a 1D array:\n   a. Create a DP array dp[] of size n+1 where dp[i] represents the maximum profit that can be obtained from a rod of length i.\n   b. Initialize dp[0] = 0 (base case: no profit from a rod of length 0).\n   c. For each possible rod length i from 1 to n:\n      i. Consider all possible ways to cut the rod into two pieces: one piece of length j (1 to i) and the remaining piece.\n      ii. The profit would be price[j-1] (for the piece of length j) plus dp[i-j] (the maximum profit from the remaining piece).\n      iii. Choose the maximum profit among all possible cuts.\n5. The recurrence relation is: dp[i] = max(dp[i], price[j-1] + dp[i-j]) for all j from 1 to i.\n6. Example with price = [2, 5, 7, 8, 10] and n = 5:\n   - Initialize dp = [0, 0, 0, 0, 0, 0]\n   - For i = 1:\n     - j = 1: dp[1] = max(0, 2 + dp[0]) = 2\n   - For i = 2:\n     - j = 1: dp[2] = max(0, 2 + dp[1]) = 4\n     - j = 2: dp[2] = max(4, 5 + dp[0]) = 5\n   - And so on...\n   - The final answer is dp[5] = 12\n7. Time Complexity: O(n²) where n is the length of the rod.\n8. Space Complexity: O(n) for the dp array.",
    "code": "public int rodCutting(int[] price, int n) {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            dp[i] = Math.max(dp[i], price[j - 1] + dp[i - j]);\n        }\n    }\n    return dp[n];\n}"
  },
  {
    "name": "Coin Change (Count Ways)",
    "endpoint": "/api/dynamic-programming/coin-change",
    "methodName": "coinChange",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "coins": [1, 2, 5], "amount": 5 },
    "description": "Given an array of coin denominations and a target amount, count the number of different ways you can make up that amount using the coins. Each coin can be used multiple times. For example, with coins [1,2,5] and target amount 5: We can make 5 using [1,1,1,1,1], or [1,1,1,2], or [1,2,2], or [5], giving us 4 different ways. Similarly, for amount 3 with the same coins, we can use [1,1,1] or [1,2], giving us 2 ways. Note that [2,1] is considered the same as [1,2] since we're counting combinations, not permutations.",
    "approach": "1. This problem asks us to count the number of different ways we can make up a given amount using the available coin denominations, where each coin can be used unlimited times (unbounded knapsack variation).\n2. We use a bottom-up dynamic programming approach to count the combinations for each amount from 0 to the target amount.\n3. The key steps in the approach are:\n   a. Create a DP array dp[] of size amount+1, where dp[i] represents the number of ways to make amount i using the given coins.\n   b. Initialize dp[0] = 1 because there is exactly one way to make amount 0 (by not selecting any coin).\n   c. For each coin denomination:\n      i. For each amount from the coin's value to the target amount:\n         - Add the number of ways to make the current amount without the current coin (dp[i]) with the number of ways to make the remaining amount after using the current coin (dp[i - coin]).\n4. The recurrence relation is: dp[i] += dp[i - coin] for each coin and valid amount i.\n5. The ordering of loops is critical for this problem:\n   a. Outer loop over coins and inner loop over amounts ensures that we count each combination exactly once, avoiding duplicates where the same coins are used in different orders.\n6. Example with coins [1, 2, 5] and amount = 5:\n   - Initialize dp = [1, 0, 0, 0, 0, 0] (dp[0] = 1, all others 0)\n   - Process coin 1:\n     - dp[1] += dp[0] = 1\n     - dp[2] += dp[1] = 1\n     - dp[3] += dp[2] = 1\n     - dp[4] += dp[3] = 1\n     - dp[5] += dp[4] = 1\n     After this: dp = [1, 1, 1, 1, 1, 1]\n   - Process coin 2:\n     - dp[2] += dp[0] = 1 + 1 = 2\n     - dp[3] += dp[1] = 1 + 1 = 2\n     - dp[4] += dp[2] = 1 + 2 = 3\n     - dp[5] += dp[3] = 1 + 2 = 3\n     After this: dp = [1, 1, 2, 2, 3, 3]\n   - Process coin 5:\n     - dp[5] += dp[0] = 3 + 1 = 4\n     Final result: dp = [1, 1, 2, 2, 3, 4]\n   So there are 4 ways to make amount 5 with coins [1, 2, 5]:\n   - 1+1+1+1+1\n   - 1+1+1+2\n   - 1+2+2\n   - 5\n7. Time Complexity: O(n * amount) where n is the number of coin denominations.\n8. Space Complexity: O(amount) for the dp array.",
    "code": "public int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n}"
  },
  {
    "name": "Target Sum",
    "endpoint": "/api/dynamic-programming/target-sum",
    "methodName": "targetSum",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 5, "target": 3, "nums": [1, 1, 1, 1, 1] },
    "description": "Given an array of integers and a target value, find the number of ways to assign + and - signs to each number in the array such that their sum equals the target. For example, with nums=[1,1,1,1,1] and target=3: We can assign signs as +1+1+1-1+1=3, +1-1+1+1+1=3, +1+1-1+1+1=3, etc. In total, there are 5 different ways to assign signs to get sum=3: [+1,+1,+1,-1,+1], [+1,-1,+1,+1,+1], [+1,+1,-1,+1,+1], [-1,+1,+1,+1,+1], [+1,+1,+1,+1,-1]. Each way gives us exactly the target sum of 3.",
    "approach": "1. The Target Sum problem asks us to find the number of ways to assign + and - signs to each number in the array such that the resulting sum equals the target value.\n2. This problem can be transformed into a subset sum problem as follows:\n   a. If we assign + to some numbers (subset S1) and - to others (subset S2), then:\n      S1 - S2 = target\n   b. We also know that S1 + S2 = totalSum (sum of all numbers in the array)\n   c. Solving these equations: S1 = (totalSum + target) / 2\n   d. So, the problem becomes: find the count of subsets with sum equal to (totalSum + target) / 2.\n3. However, we need to check two conditions before proceeding:\n   a. If (totalSum + target) is odd, it's impossible to find such a subset since we're dealing with integers.\n   b. If (totalSum + target) is negative, it's impossible since subset sums cannot be negative with non-negative inputs.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the number of ways to form a subset with sum j using the first i elements of the array.\n   b. For each element, we have two choices: either include it in the subset or exclude it.\n5. The recurrence relation is:\n   dp[i][j] = dp[i-1][j] (not taking the current element) + dp[i-1][j-nums[i]] (taking the current element, if j >= nums[i])\n6. Base cases:\n   a. If we've processed all elements (i = 0):\n      i. If target = 0 and nums[0] = 0, return 2 (we can either include or exclude the 0)\n      ii. If target = 0 or target = nums[0], return 1\n      iii. Otherwise, return 0\n7. Example with nums = [1, 1, 1, 1, 1] and target = 3:\n   a. totalSum = 5, s2 = (totalSum + target) / 2 = 4\n   b. We need to find the number of subsets with sum 4\n   c. Process through the recursive solution with memoization...\n   d. Final result: 5 ways to assign + and - to get a sum of 3\n8. Time Complexity: O(n * sum) where n is the number of elements and sum is the calculated target subset sum.\n9. Space Complexity: O(n * sum) for the dp table, plus O(n) for the recursion stack in the worst case.",
    "code": "public int targetSum(int n, int target, int[] nums) {\n    int totSum = 0;\n    for (int num : nums) {\n        totSum += num;\n    }\n    if (totSum - target < 0 || (totSum - target) % 2 == 1) return 0;\n    int s2 = (totSum - target) / 2;\n    int[][] dp = new int[n][s2 + 1];\n    for (int[] row : dp) {\n        Arrays.fill(row, -1);\n    }\n    return targetSumHelper(n - 1, s2, nums, dp);\n}\n\nprivate int targetSumHelper(int ind, int target, int[] arr, int[][] dp) {\n    if (ind == 0) {\n        if (target == 0 && arr[0] == 0) return 2;\n        if (target == 0 || target == arr[0]) return 1;\n        return 0;\n    }\n    if (dp[ind][target] != -1) return dp[ind][target];\n\n    int notTaken = targetSumHelper(ind - 1, target, arr, dp);\n    int taken = 0;\n    if (arr[ind] <= target) {\n        taken = targetSumHelper(ind - 1, target - arr[ind], arr, dp);\n    }\n    return dp[ind][target] = notTaken + taken;\n}"
  },
  {
    "name": "Partition Equal Subset Sum",
    "endpoint": "/api/dynamic-programming/partition-equal-subset-sum",
    "methodName": "partitionEqualSubsetSum",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "nums": [1, 5, 11, 5] },
    "description": "Given an array of integers, determine if it can be partitioned into two subsets such that their sums are equal. For example, with array [1,5,11,5]: We can partition it into subsets [1,5,5] and [11], both with sum=11, so return true. For array [1,2,3,5]: The sum is 11 (odd), so it cannot be partitioned into equal subsets, return false. For array [1,2,3,4]: We can partition it into [1,4] and [2,3], both with sum=5, return true. The key is finding if we can select some numbers that sum to exactly half of the total array sum.",
    "approach": "1. The Partition Equal Subset Sum problem asks us to determine whether an array can be divided into two subsets such that the sum of elements in both subsets is equal.\n2. This problem can be reduced to the Subset Sum problem: if the total sum of the array is odd, it's impossible to divide it into two equal parts. If it's even, we need to find if there exists a subset with sum equal to half of the total sum.\n3. The key steps in the approach are:\n   a. Calculate the total sum of all elements in the array.\n   b. If the total sum is odd, return false immediately (can't have two equal partitions).\n   c. Set our target sum as totalSum/2.\n   d. Use dynamic programming to determine if there's a subset with sum equal to target.\n4. We use a bottom-up approach with a 1D boolean dp array:\n   a. dp[i] represents whether it's possible to form a subset with sum i.\n   b. Initialize dp[0] = true (it's always possible to form a subset with sum 0 by not taking any elements).\n   c. For each element num in the array:\n      i. Iterate backwards from the target to num.\n      ii. For each sum i, if dp[i-num] is true (meaning we can form a subset with sum i-num), then dp[i] becomes true (we can form a subset with sum i by adding the current element).\n5. The backward iteration in the inner loop is crucial to avoid counting an element multiple times in the same subset.\n6. Example with nums = [1, 5, 11, 5]:\n   a. Total sum = 22, which is even. Target = 11.\n   b. Initialize dp = [true, false, false, ..., false] of size 12.\n   c. Process 1: dp[1] = dp[0] = true, dp = [true, true, false, ..., false]\n   d. Process 5: dp[5] = dp[0] = true, dp[6] = dp[1] = true, ..., dp = [true, true, false, false, false, true, true, ...]\n   e. Process 11: dp[11] = dp[0] = true, dp = [..., true]\n   f. Final dp[11] = true, so return true.\n7. Time Complexity: O(n * target) where n is the number of elements and target is half of the total sum.\n8. Space Complexity: O(target) for the dp array.",
    "code": "public boolean partitionEqualSubsetSum(int[] nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    if (sum % 2 != 0) return false;\n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}"
  },
  {
    "name": "Minimum Falling Path Sum",
    "endpoint": "/api/dynamic-programming/min-falling-path-sum",
    "methodName": "minFallingPathSum",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "matrix": [[2,1,3],[6,5,4],[7,8,9]] },
    "description": "Given an n x n matrix, find the minimum sum path from any element in the first row to any element in the last row, where you can only move diagonally down-left, straight down, or diagonally down-right from each position. For example, with matrix [[2,1,3],[6,5,4],[7,8,9]]: Starting from 1 in the first row, we can move to 5 in second row (straight down), then to 7 in last row (diagonal left), giving path sum 1+5+7=13. Or starting from 2, we can go to 5 then 7 for sum 14. After trying all possible paths, we find that starting from 1→5→7 gives the minimum sum of 13.",
    "approach": "1. The Minimum Falling Path Sum problem asks us to find the minimum sum path from the top row to the bottom row of a matrix, where at each step we can move diagonally down-left, straight down, or diagonally down-right.\n2. We use a top-down dynamic programming approach with memoization to solve this problem efficiently:\n   a. Define dp[i][j] as the minimum falling path sum ending at position (i, j) in the matrix.\n   b. For each position (i, j), we need to consider three possible previous positions: (i-1, j-1), (i-1, j), and (i-1, j+1), if they are valid.\n   c. The minimum path sum ending at (i, j) is the value at matrix[i][j] plus the minimum of the path sums from these three previous positions.\n3. The recurrence relation is:\n   dp[i][j] = matrix[i][j] + min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])\n4. The base cases are:\n   a. For the first row (i = 0), dp[0][j] = matrix[0][j] for all valid j.\n   b. For out-of-bounds positions (j < 0 or j >= n), we return a very large value (like 10^9) to ensure these paths are not considered.\n5. To find the overall minimum falling path sum, we compute the minimum path sum ending at each position in the last row and take the minimum among them.\n6. Example with matrix = [[2,1,3],[6,5,4],[7,8,9]]:\n   a. Starting from the bottom row, we calculate minimum paths for each position.\n   b. For position (2,0): Value is 7, minimum path from above is min(matrix[1][0], matrix[1][1]) = min(6, 5) = 5, so dp[2][0] = 7 + 5 = 12.\n   c. For position (2,1): Value is 8, minimum path from above is min(matrix[1][0], matrix[1][1], matrix[1][2]) = min(6, 5, 4) = 4, so dp[2][1] = 8 + 4 = 12.\n   d. For position (2,2): Value is 9, minimum path from above is min(matrix[1][1], matrix[1][2]) = min(5, 4) = 4, so dp[2][2] = 9 + 4 = 13.\n   e. The minimum falling path sum is min(12, 12, 13) = 12.\n7. Time Complexity: O(n²) where n is the size of the n×n matrix.\n8. Space Complexity: O(n²) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int minFallingPathSum(int[][] matrix) {\n    int n = matrix.length;\n    int[][] dp = new int[n][n];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    int minSum = Integer.MAX_VALUE;\n    for (int j = 0; j < n; j++) {\n        minSum = Math.min(minSum, minFallingPathSumHelper(n - 1, j, matrix, dp));\n    }\n    return minSum;\n}\n\nprivate int minFallingPathSumHelper(int i, int j, int[][] matrix, int[][] dp) {\n    if (j < 0 || j >= matrix[0].length) return (int)(1e9);\n    if (i == 0) return matrix[0][j];\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    int up = matrix[i][j] + minFallingPathSumHelper(i - 1, j, matrix, dp);\n    int leftDiagonal = matrix[i][j] + minFallingPathSumHelper(i - 1, j - 1, matrix, dp);\n    int rightDiagonal = matrix[i][j] + minFallingPathSumHelper(i - 1, j + 1, matrix, dp);\n    \n    return dp[i][j] = Math.min(up, Math.min(leftDiagonal, rightDiagonal));\n}"
  },
  {
    "name": "Minimum Triangle Sum",
    "endpoint": "/api/dynamic-programming/min-triangle-sum",
    "methodName": "minTriangleSum",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "triangle": [[2],[3,4],[6,5,7],[4,1,8,3]] },
    "description": "Given a triangle array, find the minimum path sum from top to bottom. At each step, you may move to the adjacent numbers in the row directly below. For example, with triangle [[2],[3,4],[6,5,7],[4,1,8,3]]: Starting from top '2', we can move to either '3' or '4'. From '3' we can move to '6' or '5', from '4' we can move to '5' or '7', and so on. One possible path is 2→3→5→1, with sum 11. Another is 2→4→7→3, with sum 16. After trying all possible paths, we find that 2→3→5→1 gives the minimum sum of 11.",
    "approach": "1. The Minimum Triangle Sum problem asks us to find the minimum path sum from the top to the bottom of a triangle, where at each step, we can move to one of the two adjacent numbers in the row below.\n2. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the minimum path sum starting from position (i, j) to the bottom of the triangle.\n   b. For each position (i, j), we have two choices: move to (i+1, j) or (i+1, j+1).\n   c. The minimum path sum from (i, j) is the value at triangle[i][j] plus the minimum of the path sums from these two next positions.\n3. The recurrence relation is:\n   dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])\n4. The base case is the bottom row of the triangle, where dp[n-1][j] = triangle[n-1][j] for all valid j.\n5. We start from the top of the triangle at position (0, 0) and compute the minimum path sum.\n6. Example with triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]:\n   a. Starting from the top element 2, we need to find the minimum path to the bottom.\n   b. From position (0,0), we can move to (1,0) or (1,1).\n   c. From (1,0), the minimum path sum is 3 + min(minTriangleSumHelper(2, 0), minTriangleSumHelper(2, 1)) = 3 + min(path through 6, path through 5)\n   d. Working through all positions recursively with memoization...\n   e. The minimum path is 2 → 3 → 5 → 1, with a total sum of 11.\n7. Time Complexity: O(n²) where n is the number of rows in the triangle. This is because there are n*(n+1)/2 positions in the triangle.\n8. Space Complexity: O(n²) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int minTriangleSum(List<List<Integer>> triangle) {\n    int n = triangle.size();\n    int[][] dp = new int[n][n];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return minTriangleSumHelper(0, 0, triangle, dp);\n}\n\nprivate int minTriangleSumHelper(int i, int j, List<List<Integer>> triangle, int[][] dp) {\n    if (i == triangle.size() - 1) return triangle.get(i).get(j);\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    int down = triangle.get(i).get(j) + minTriangleSumHelper(i + 1, j, triangle, dp);\n    int diagonal = triangle.get(i).get(j) + minTriangleSumHelper(i + 1, j + 1, triangle, dp);\n    \n    return dp[i][j] = Math.min(down, diagonal);\n}"
  },
  {
    "name": "Max Coins",
    "endpoint": "/api/dynamic-programming/max-coins",
    "methodName": "maxCoins",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "nums": [3,1,5,8] },
    "description": "Given n balloons, each with a number written on it. You are asked to burst the balloons one by one. For each burst operation, you get coins equal to nums[left] × nums[i] × nums[right], where left and right are adjacent non-burst balloons. For example, with balloons [3,1,5,8]: If we burst 1 first, we get 3×1×5 = 15 coins, then either 3×5×8 or 3×8×5 for next burst. Different bursting orders give different total coins: bursting 5 first gives 3×5×8 = 120, then 3×8×1 = 24, then 3×1 = 3, total 147. After trying all possible bursting orders, we find the maximum coins possible.",
    "approach": "1. In the Balloon Burst (Max Coins) problem, we have n balloons, each with a number on it. When a balloon is burst, we collect coins equal to nums[left] * nums[i] * nums[right], where left and right are the adjacent non-burst balloons.\n2. The goal is to burst all balloons to collect the maximum possible number of coins.\n3. This is a challenging problem because the order of bursting affects the outcome. We use a dynamic programming approach with the following key insight:\n   a. Instead of thinking about the order in which balloons are burst, we think about the order in which balloons are kept until the end.\n   b. For each subproblem, we consider which balloon is the last to be burst in that range.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the maximum coins that can be collected by bursting all balloons in the range [i, j].\n   b. For each range [i, j], we try each balloon k in the range as the last one to burst.\n   c. The cost of bursting all balloons with k as the last one is:\n      newNums[i-1] * newNums[k] * newNums[j+1] (coins from bursting k with its final neighbors) + dp[i][k-1] (coins from bursting all balloons to the left of k) + dp[k+1][j] (coins from bursting all balloons to the right of k)\n5. We add two dummy balloons with value 1 at the beginning and end of the array to simplify boundary conditions.\n6. The recurrence relation is:\n   dp[i][j] = max(dp[i][j], newNums[i-1] * newNums[k] * newNums[j+1] + dp[i][k-1] + dp[k+1][j]) for all k from i to j\n7. The base case is when i > j, meaning there are no balloons in the range, so dp[i][j] = 0.\n8. Example with nums = [3, 1, 5, 8]:\n   a. Add dummy balloons: newNums = [1, 3, 1, 5, 8, 1]\n   b. For the original array (positions 1 to 4 in newNums), we need to calculate dp[1][4].\n   c. Try each balloon as the last one to burst:\n      - Last burst at position 1: 1*3*1 + dp[1][0] + dp[2][4]\n      - Last burst at position 2: 1*1*5 + dp[1][1] + dp[3][4]\n      - Last burst at position 3: 1*5*8 + dp[1][2] + dp[4][4]\n      - Last burst at position 4: 1*8*1 + dp[1][3] + dp[5][4]\n   d. Calculate each subproblem recursively with memoization.\n   e. The maximum coins collectible is 167.\n9. Time Complexity: O(n³) where n is the number of balloons.\n10. Space Complexity: O(n²) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 0; i < n; i++) {\n        newNums[i + 1] = nums[i];\n    }\n    int[][] dp = new int[n + 2][n + 2];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return maxCoinsHelper(1, n, newNums, dp);\n}\n\nprivate int maxCoinsHelper(int i, int j, int[] nums, int[][] dp) {\n    if (i > j) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    int maxi = Integer.MIN_VALUE;\n    for (int ind = i; ind <= j; ind++) {\n        int cost = nums[i - 1] * nums[ind] * nums[j + 1] + \n                  maxCoinsHelper(i, ind - 1, nums, dp) + \n                  maxCoinsHelper(ind + 1, j, nums, dp);\n        maxi = Math.max(maxi, cost);\n    }\n    return dp[i][j] = maxi;\n}"
  },
  {
    "name": "Matrix Chain Multiplication",
    "endpoint": "/api/dynamic-programming/matrix-chain-multiplication",
    "methodName": "matrixChainMultiplication",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "arr": [40, 20, 30, 10, 30] },
    "description": "Find the minimum number of scalar multiplications needed to multiply a chain of matrices. For example, given dimensions [40,20,30,10,30], we have matrices A(40×20), B(20×30), C(30×10), and D(10×30). To multiply them, we can choose different orders: ((A×B)×C)×D, (A×(B×C))×D, etc. Each multiplication operation (P×Q)×R requires p×q×r scalar multiplications where p is rows of first matrix, q is columns of first/rows of second, and r is columns of second matrix. Trying all possible multiplication orders, we find the optimal sequence that minimizes total scalar multiplications.",
    "approach": "1. The Matrix Chain Multiplication problem asks us to find the most efficient way to multiply a chain of matrices to minimize the total number of scalar multiplications.\n2. For matrix multiplication, the dimensions are crucial: a matrix of dimensions p×q can be multiplied with a matrix of dimensions q×r to result in a p×r matrix, requiring p*q*r scalar multiplications.\n3. Given an array of dimensions where matrices A_i has dimensions arr[i-1] × arr[i], we need to determine the optimal order of multiplication to minimize the total number of operations.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the minimum number of scalar multiplications needed to compute the matrix product from matrix i to matrix j.\n   b. For each range [i, j], we try all possible places to split the chain, and choose the one that minimizes the total cost.\n   c. The cost for a split at position k is the cost of multiplying the matrices from i to k, plus the cost of multiplying the matrices from k+1 to j, plus the cost of multiplying these two resulting matrices.\n5. The recurrence relation is:\n   dp[i][j] = min(dp[i][k] + dp[k+1][j] + arr[i-1]*arr[k]*arr[j]) for all k from i to j-1\n6. The base case is when i equals j, meaning we have a single matrix, so dp[i][j] = 0 (no multiplication needed).\n7. Example with arr = [40, 20, 30, 10, 30]:\n   a. We have 4 matrices: A(40×20), B(20×30), C(30×10), D(10×30)\n   b. For dp[1][4] (multiplying all matrices), we consider all possible splits:\n      - Split at k=1: cost = dp[1][1] + dp[2][4] + 40*20*30 = 0 + min cost of BCD + 24000\n      - Split at k=2: cost = dp[1][2] + dp[3][4] + 40*30*30 = min cost of AB + min cost of CD + 36000\n      - Split at k=3: cost = dp[1][3] + dp[4][4] + 40*10*30 = min cost of ABC + 0 + 12000\n   c. Calculate each subproblem recursively with memoization.\n   d. The minimum number of scalar multiplications is 26000.\n8. Time Complexity: O(n³) where n is the number of matrices.\n9. Space Complexity: O(n²) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int matrixChainMultiplication(int[] arr) {\n    int n = arr.length;\n    int[][] dp = new int[n][n];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return matrixChainMultiplicationHelper(1, n - 1, arr, dp);\n}\n\nprivate int matrixChainMultiplicationHelper(int i, int j, int[] arr, int[][] dp) {\n    if (i == j) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    int mini = Integer.MAX_VALUE;\n    for (int k = i; k < j; k++) {\n        int steps = arr[i - 1] * arr[k] * arr[j] + \n                   matrixChainMultiplicationHelper(i, k, arr, dp) + \n                   matrixChainMultiplicationHelper(k + 1, j, arr, dp);\n        mini = Math.min(mini, steps);\n    }\n    return dp[i][j] = mini;\n}"
  },
  {
    "name": "Minimum Cost to Cut Stick",
    "endpoint": "/api/dynamic-programming/min-cost",
    "methodName": "minCost",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 7, "cuts": [1,3,4,5] },
    "description": "Given a stick of length n and a list of positions where cuts can be made, find the minimum cost to cut the stick into all required pieces. The cost of each cut is equal to the length of the stick being cut. For example, with a stick of length 7 and cuts at positions [1,3,4,5]: First cutting at position 3 costs 7, creating pieces [0-3] and [3-7]. Then cutting at 1 costs 3, and cutting at 4 costs 4, and finally at 5 costs 2. The total cost is 16. Different cutting orders give different total costs, and we need to find the minimum possible total cost.",
    "approach": "1. The Minimum Cost to Cut Stick problem asks us to find the minimum cost to cut a stick of length n at specified positions.\n2. The cost of making a cut is equal to the length of the stick being cut. After a cut, the stick is split into two smaller sticks, and we can make more cuts on these smaller sticks.\n3. This problem is similar to the Matrix Chain Multiplication problem in that we need to find the optimal order of operations (cuts) to minimize the total cost.\n4. The key insight is to consider which cut should be made last rather than first, which makes the dynamic programming approach more straightforward.\n5. We use a top-down dynamic programming approach with memoization:\n   a. First, we add the endpoints (0 and n) to the list of cuts and sort the list.\n   b. Define dp[i][j] as the minimum cost to cut the stick from position newCuts[i] to position newCuts[j].\n   c. For each range [i, j], we try each cut position k between i and j, and choose the one that minimizes the total cost.\n   d. The cost of making the cuts in the range [i, j] with cut at position k includes:\n      i. The cost of making all cuts in the range [i, k-1] (to the left of k)\n      ii. The cost of making all cuts in the range [k+1, j] (to the right of k)\n      iii. The cost of making the cut at position k itself, which is the length of the current stick (newCuts[j+1] - newCuts[i-1])\n6. The recurrence relation is:\n   dp[i][j] = min(dp[i][k-1] + dp[k+1][j] + (newCuts[j+1] - newCuts[i-1])) for all k from i to j\n7. The base case is when i > j, meaning there are no cuts to be made in this range, so dp[i][j] = 0.\n8. Example with n = 7, cuts = [1, 3, 4, 5]:\n   a. We add endpoints and sort: newCuts = [0, 1, 3, 4, 5, 7]\n   b. For dp[1][4] (making all cuts), we try each cut position k from 1 to 4.\n   c. For k=1: cost = dp[1][0] + dp[2][4] + (newCuts[5] - newCuts[0]) = 0 + min cost of making cuts at positions 3,4,5 + 7\n   d. Similarly for k=2, k=3, k=4...\n   e. Calculate each subproblem recursively with memoization.\n   f. The minimum cost to make all the cuts is 16.\n9. Time Complexity: O(c³) where c is the number of cuts.\n10. Space Complexity: O(c²) for the dp array, plus O(c) for the recursion stack in the worst case.",
    "code": "public int minCost(int n, int[] cuts) {\n    int c = cuts.length;\n    int[] newCuts = new int[c + 2];\n    newCuts[0] = 0;\n    newCuts[c + 1] = n;\n    for (int i = 0; i < c; i++) {\n        newCuts[i + 1] = cuts[i];\n    }\n    Arrays.sort(newCuts);\n    int[][] dp = new int[c + 2][c + 2];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return minCostHelper(1, c, newCuts, dp);\n}\n\nprivate int minCostHelper(int i, int j, int[] cuts, int[][] dp) {\n    if (i > j) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    int mini = Integer.MAX_VALUE;\n    for (int ind = i; ind <= j; ind++) {\n        int cost = cuts[j + 1] - cuts[i - 1] + \n                  minCostHelper(i, ind - 1, cuts, dp) + \n                  minCostHelper(ind + 1, j, cuts, dp);\n        mini = Math.min(mini, cost);\n    }\n    return dp[i][j] = mini;\n}"
  },
  {
    "name": "Minimum Insertions to Make Palindrome",
    "endpoint": "/api/dynamic-programming/min-insertions",
    "methodName": "minInsertions",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "s": "mbadm" },
    "description": "Given a string, find the minimum number of characters that need to be inserted to make it a palindrome. For example, with string 'mbadm': We can insert 'a' between 'b' and 'd' to get 'mbabadm' (2 insertions), or insert 'b' after 'd' to get 'mbadmbm' (2 insertions), or insert 'a' after 'b' to get 'mbadabm' (1 insertion). After trying all possibilities, we find that inserting just one character 'a' to get 'mbadabm' is optimal, giving us minimum 1 insertion needed.",
    "approach": "1. The Minimum Insertions to Make Palindrome problem asks us to find the minimum number of characters that need to be inserted into a string to make it a palindrome.\n2. This problem can be approached using dynamic programming by considering all possible substrings and determining the minimum insertions needed for each.\n3. The key insight is that for any substring s[i...j]:\n   a. If the characters at both ends are the same (s[i] == s[j]), then the minimum insertions needed is the same as for s[i+1...j-1].\n   b. If the characters at the ends are different, we have two choices:\n      i. Insert the character s[i] at position j+1 and solve for s[i+1...j].\n      ii. Insert the character s[j] at position i and solve for s[i...j-1].\n      We take the minimum of these two options and add 1 for the insertion made.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the minimum number of insertions needed to make the substring s[i...j] a palindrome.\n   b. The recurrence relation is:\n      If s[i] == s[j]: dp[i][j] = dp[i+1][j-1]\n      Otherwise: dp[i][j] = 1 + min(dp[i+1][j], dp[i][j-1])\n5. Base cases:\n   a. When i > j, we have an empty substring, so dp[i][j] = 0.\n   b. When i == j, we have a single character, which is already a palindrome, so dp[i][j] = 0.\n6. Example with s = \"mbadm\":\n   a. For substring \"m\" (i=0, j=0): Already a palindrome, dp[0][0] = 0.\n   b. For substring \"mb\" (i=0, j=1): Characters differ, dp[0][1] = 1 + min(dp[1][1], dp[0][0]) = 1 + min(0, 0) = 1. We need to insert 'b' before 'm' or 'm' after 'b'.\n   c. For the entire string \"mbadm\" (i=0, j=4): Characters match, dp[0][4] = dp[1][3] = minimum insertions for \"bad\" = 1.\n   d. The minimum number of insertions needed is 1 (inserting 'a' to get \"mbadabm\" or 'd' to get \"mbadmbadm\").\n7. Time Complexity: O(n²) where n is the length of the string.\n8. Space Complexity: O(n²) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int minInsertions(String s) {\n    int n = s.length();\n    int[][] dp = new int[n][n];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return minInsertionsHelper(0, n - 1, s, dp);\n}\n\nprivate int minInsertionsHelper(int i, int j, String s, int[][] dp) {\n    if (i >= j) return 0;\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    if (s.charAt(i) == s.charAt(j)) {\n        return dp[i][j] = minInsertionsHelper(i + 1, j - 1, s, dp);\n    }\n    return dp[i][j] = 1 + Math.min(minInsertionsHelper(i + 1, j, s, dp), \n                                  minInsertionsHelper(i, j - 1, s, dp));\n}"
  },
  {
    "name": "Minimum Operations to Make Array Equal",
    "endpoint": "/api/dynamic-programming/min-operations",
    "methodName": "minOperations",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "nums": [1, 2, 3, 4, 5] },
    "description": "Given an array of integers, find the minimum number of operations needed to make all elements equal. In one operation, you can pick any two elements and increase one by 1 while decreasing the other by 1. For example, with array [1,2,3,4,5]: To make all elements 3 (the mean), we need: Operation 1: Decrease 5 by 1 and increase 1 by 1, getting [2,2,3,4,4]. Operation 2: Decrease 4 by 1 and increase 2 by 1, getting [3,2,3,3,4]. Operation 3: Decrease 4 by 1 and increase 2 by 1, getting [3,3,3,3,3]. Thus, we need minimum 3 operations.",
    "approach": "1. The Minimum Operations to Make Array Equal problem asks us to find the minimum number of operations needed to make all elements in the array equal, where each operation involves increasing one element by 1 and decreasing another element by 1.\n2. This is actually more of a mathematical problem than a traditional dynamic programming problem. The key insights are:\n   a. The sum of all elements in the array remains constant after any operation (since we're adding 1 to one element and subtracting 1 from another).\n   b. Therefore, if all elements are to become equal, each must equal the mean of the original array.\n   c. The mean must be an integer for the problem to have a solution (otherwise return -1).\n3. The steps to solve this problem are:\n   a. Calculate the sum of all elements in the array.\n   b. Check if the sum is divisible by the number of elements (n). If not, return -1 (impossible to make all elements equal).\n   c. Calculate the target value that all elements should become: target = sum / n.\n   d. Sum up the absolute differences between each element and the target value.\n   e. Divide this sum by 2 to get the minimum number of operations required (since each operation changes two elements).\n4. The division by 2 is necessary because each absolute difference is counted twice: once for the element that needs to be decreased and once for the element that needs to be increased.\n5. Example with nums = [1, 2, 3, 4, 5]:\n   a. Sum = 15, n = 5, so target = 15/5 = 3.\n   b. Sum of absolute differences = |1-3| + |2-3| + |3-3| + |4-3| + |5-3| = 2 + 1 + 0 + 1 + 2 = 6.\n   c. Minimum operations = 6/2 = 3.\n6. Time Complexity: O(n) where n is the size of the array.\n7. Space Complexity: O(1) as we only use a few variables regardless of the input size.",
    "code": "public int minOperations(int[] nums) {\n    int n = nums.length;\n    int sum = 0;\n    for (int num : nums) sum += num;\n    if (sum % n != 0) return -1;\n    int target = sum / n;\n    int operations = 0;\n    for (int num : nums) {\n        operations += Math.abs(num - target);\n    }\n    return operations / 2;\n}"
  },
  {
    "name": "Non-Adjacent Elements Maximum Sum",
    "endpoint": "/api/dynamic-programming/non-adjacent",
    "methodName": "nonAdjacent",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "nums": [3, 2, 5, 10, 7] },
    "description": "Given an array of integers, find the maximum sum possible by selecting elements such that no two adjacent elements are chosen. For example, with array [3,2,5,10,7]: If we pick 3, we can't pick 2. Some possible selections are [3,5,7] with sum 15, [3,10] with sum 13, [2,10] with sum 12. After trying all possibilities, we find that selecting elements [3,5,7] gives the maximum sum of 15 while ensuring no two adjacent elements are picked.",
    "approach": "1. The Non-Adjacent Elements Maximum Sum problem (also known as the House Robber problem) asks us to find the maximum sum of elements in an array such that no two adjacent elements are included in the sum.\n2. This is a classic dynamic programming problem where at each position, we need to make a choice that maximizes our overall result.\n3. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i] as the maximum sum we can achieve considering the elements from index 0 to index i.\n   b. For each element at index i, we have two choices:\n      i. Pick the element: In this case, we add its value to the maximum sum we can achieve up to index i-2 (skipping the adjacent element).\n      ii. Skip the element: In this case, the maximum sum remains the same as what we can achieve up to index i-1.\n   c. We take the maximum of these two choices.\n4. The recurrence relation is:\n   dp[i] = max(nums[i] + dp[i-2], dp[i-1])\n5. Base cases:\n   a. dp[-1] = 0 (no elements to pick)\n   b. dp[0] = nums[0] (only one element to pick)\n6. Example with nums = [3, 2, 5, 10, 7]:\n   a. For i = 0: dp[0] = 3 (only element available)\n   b. For i = 1: dp[1] = max(2 + dp[-1], dp[0]) = max(2 + 0, 3) = 3\n   c. For i = 2: dp[2] = max(5 + dp[0], dp[1]) = max(5 + 3, 3) = 8\n   d. For i = 3: dp[3] = max(10 + dp[1], dp[2]) = max(10 + 3, 8) = 13\n   e. For i = 4: dp[4] = max(7 + dp[2], dp[3]) = max(7 + 8, 13) = 15\n   f. The maximum sum of non-adjacent elements is 15.\n7. Time Complexity: O(n) where n is the size of the array.\n8. Space Complexity: O(n) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int nonAdjacent(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[n];\n    Arrays.fill(dp, -1);\n    return nonAdjacentHelper(n - 1, nums, dp);\n}\n\nprivate int nonAdjacentHelper(int ind, int[] nums, int[] dp) {\n    if (ind < 0) return 0;\n    if (dp[ind] != -1) return dp[ind];\n    \n    int pick = nums[ind] + nonAdjacentHelper(ind - 2, nums, dp);\n    int notPick = nonAdjacentHelper(ind - 1, nums, dp);\n    return dp[ind] = Math.max(pick, notPick);\n}"
  },
  {
    "name": "Wildcard Pattern Matching",
    "endpoint": "/api/dynamic-programming/wildcard",
    "methodName": "wildcard",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "pattern": "a*b?c", "str": "aabxc" },
    "description": "Given a string and a pattern containing wildcards, determine if the string matches the pattern. The pattern can contain '?' which matches any single character, and '*' which matches zero or more characters. For example, with pattern='a*b?c' and string='aabxc': The 'a' matches directly, '*' can match 'a', 'b' matches directly, '?' matches 'x', and 'c' matches directly, so the string matches the pattern. For pattern='a*b?c' and string='abc', it doesn't match because '?' needs exactly one character but finds none between 'b' and 'c'.",
    "approach": "1. The Wildcard Pattern Matching problem asks us to determine if a string matches a pattern containing wildcards. The wildcards are:\n   a. '?' which matches any single character\n   b. '*' which matches any sequence of characters (including the empty sequence)\n2. This problem is well-suited for dynamic programming, as we need to make decisions at each character position that depend on previous decisions.\n3. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as a boolean value (represented as 0 or 1) indicating whether the substring pattern[0...i] matches the substring str[0...j].\n   b. We start from the end of both strings and work backwards.\n4. The recurrence relation considers several cases:\n   a. If both strings are empty (i < 0 and j < 0), return 1 (match).\n   b. If the pattern is empty but the string is not (i < 0 and j >= 0), return 0 (no match).\n   c. If the string is empty but the pattern is not (j < 0 and i >= 0), return 1 only if all remaining pattern characters are '*' (since '*' can match an empty sequence).\n   d. If the current characters match or the pattern has a '?' at position i, then dp[i][j] = dp[i-1][j-1].\n   e. If the pattern has a '*' at position i, then dp[i][j] = dp[i-1][j] | dp[i][j-1].\n      i. dp[i-1][j]: '*' matches no characters (we move to the next pattern character).\n      ii. dp[i][j-1]: '*' matches one or more characters (we keep the '*' and move to the next string character).\n   f. Otherwise, return 0 (no match).\n5. Example with pattern = \"a*b?c\" and str = \"aabxc\":\n   a. Starting from the end (i = 4, j = 4):\n      i. pattern[4] = 'c', str[4] = 'c', they match, so check dp[3][3].\n      ii. pattern[3] = '?', which matches any character, so check dp[2][2].\n      iii. pattern[2] = 'b', str[2] = 'b', they match, so check dp[1][1].\n      iv. pattern[1] = '*', which can match any sequence, we need to check both dp[0][1] and dp[1][0].\n      v. One of these paths will lead to a match.\n   b. The result is true.\n6. Time Complexity: O(n * m) where n is the length of the pattern and m is the length of the string.\n7. Space Complexity: O(n * m) for the dp array, plus O(n + m) for the recursion stack in the worst case.",
    "code": "public boolean wildcard(String pattern, String str) {\n    int n = pattern.length();\n    int m = str.length();\n    int[][] dp = new int[n][m];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return wildcardHelper(n - 1, m - 1, pattern, str, dp) == 1;\n}\n\nprivate int wildcardHelper(int i, int j, String pattern, String str, int[][] dp) {\n    if (i < 0 && j < 0) return 1;\n    if (i < 0 && j >= 0) return 0;\n    if (j < 0 && i >= 0) {\n        for (int ii = 0; ii <= i; ii++) {\n            if (pattern.charAt(ii) != '*') return 0;\n        }\n        return 1;\n    }\n    if (dp[i][j] != -1) return dp[i][j];\n    \n    if (pattern.charAt(i) == str.charAt(j) || pattern.charAt(i) == '?') {\n        return dp[i][j] = wildcardHelper(i - 1, j - 1, pattern, str, dp);\n    }\n    if (pattern.charAt(i) == '*') {\n        return dp[i][j] = wildcardHelper(i - 1, j, pattern, str, dp) | \n                         wildcardHelper(i, j - 1, pattern, str, dp);\n    }\n    return dp[i][j] = 0;\n}"
  },
  {
    "name": "Count Partitions with Given Difference",
    "endpoint": "/api/dynamic-programming/count-partitions",
    "methodName": "countPartitions",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 4, "d": 1, "arr": [1, 1, 2, 3] },
    "description": "Given an array and a difference 'd', count the number of ways to partition the array into two subsets such that their sum difference equals 'd'. For example, with array [1,1,2,3] and d=1: We can partition it as {1,1,2} and {3} (difference=4-3=1), or {1,3} and {1,2} (difference=4-3=1), or {3,1} and {1,2} (difference=4-3=1). Total 3 ways exist to partition with difference 1. Another example: with array [1,2,3] and d=1, no partition exists because all possible partitions ([1,2] and [3], [1,3] and [2], etc.) have differences other than 1.",
    "approach": "1. The Count Partitions with Given Difference problem asks us to count the number of ways to partition an array into two subsets S1 and S2 such that the difference between their sums is equal to a given value D.\n2. This problem can be transformed into a subset sum problem using the following steps:\n   a. Let S1 and S2 be the two subsets, and totalSum be the sum of all elements in the array.\n   b. We know that S1 + S2 = totalSum and S1 - S2 = D.\n   c. Solving these equations: S1 = (totalSum + D) / 2.\n   d. So the problem becomes: count the number of subsets with sum equal to (totalSum + D) / 2.\n3. Before proceeding, we need to check two conditions:\n   a. If (totalSum + D) is odd, it's impossible to find such subsets since we're dealing with integers.\n   b. If (totalSum + D) is negative, it's impossible since subset sums cannot be negative with non-negative inputs.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i][j] as the number of ways to form a subset with sum j using the first i elements of the array.\n   b. For each element, we have two choices: either include it in the subset or exclude it.\n5. The recurrence relation is:\n   dp[i][j] = dp[i-1][j] (not taking the current element) + dp[i-1][j-arr[i]] (taking the current element, if j >= arr[i])\n6. Base cases:\n   a. If we've processed all elements (i = 0):\n      i. If target = 0 and arr[0] = 0, return 2 (we can either include or exclude the 0)\n      ii. If target = 0 or target = arr[0], return 1\n      iii. Otherwise, return 0\n7. Example with n = 4, d = 1, arr = [1, 1, 2, 3]:\n   a. totalSum = 7, s2 = (totalSum + d) / 2 = (7 + 1) / 2 = 4.\n   b. We need to count the number of subsets with sum 4.\n   c. Process through the recursive solution with memoization...\n   d. Final result: 3 ways to partition the array with difference 1: ({1,1,2}, {3}), ({1,3}, {1,2}), ({3,1}, {1,2}).\n8. Time Complexity: O(n * s2) where n is the number of elements and s2 is the calculated target sum.\n9. Space Complexity: O(n * s2) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int countPartitions(int n, int d, int[] arr) {\n    int totSum = 0;\n    for (int num : arr) totSum += num;\n    if (totSum - d < 0 || (totSum - d) % 2 == 1) return 0;\n    int s2 = (totSum - d) / 2;\n    int[][] dp = new int[n][s2 + 1];\n    for (int[] row : dp) Arrays.fill(row, -1);\n    return countPartitionsHelper(n - 1, s2, arr, dp);\n}\n\nprivate int countPartitionsHelper(int ind, int target, int[] arr, int[][] dp) {\n    if (ind == 0) {\n        if (target == 0 && arr[0] == 0) return 2;\n        if (target == 0 || target == arr[0]) return 1;\n        return 0;\n    }\n    if (dp[ind][target] != -1) return dp[ind][target];\n    \n    int notTaken = countPartitionsHelper(ind - 1, target, arr, dp);\n    int taken = 0;\n    if (arr[ind] <= target) {\n        taken = countPartitionsHelper(ind - 1, target - arr[ind], arr, dp);\n    }\n    return dp[ind][target] = notTaken + taken;\n}"
  },
  {
    "name": "Equal Partition Sum",
    "endpoint": "/api/dynamic-programming/equal-partition",
    "methodName": "equalPartition",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 4, "arr": [1, 5, 11, 5] },
    "description": "Given an array of integers, determine if it can be partitioned into two subsets such that their sums are equal. For example, with array [1,5,11,5]: We can partition it into subsets [1,5,5] and [11], both with sum=11, so return true. For array [1,2,3,5]: The sum is 11 (odd), so it cannot be partitioned into equal subsets, return false. For array [1,2,3,4]: We can partition it into [1,4] and [2,3], both with sum=5, return true. The key is finding if we can select some numbers that sum to exactly half of the total array sum.",
    "approach": "1. The Equal Partition Sum problem asks us to determine whether an array can be divided into two subsets such that the sum of elements in both subsets is equal.\n2. This problem can be reduced to the Subset Sum problem: if the total sum of the array is odd, it's impossible to divide it into two equal parts. If it's even, we need to find if there exists a subset with sum equal to half of the total sum.\n3. The key steps in the approach are:\n   a. Calculate the total sum of all elements in the array.\n   b. If the total sum is odd, return false immediately (can't have two equal partitions).\n   c. Set our target sum as totalSum/2.\n   d. Use dynamic programming to determine if there's a subset with sum equal to target.\n4. We use a bottom-up dynamic programming approach:\n   a. Create a 2D boolean array dp[n][target+1] where dp[i][j] represents whether it's possible to form a subset with sum j using the first i+1 elements of the array.\n   b. Initialize dp[i][0] = true for all i (it's always possible to form a subset with sum 0 by not taking any elements).\n   c. Initialize dp[0][arr[0]] = true if arr[0] <= target (we can form a subset with sum arr[0] by taking the first element).\n   d. For each element i from 1 to n-1 and each possible sum j from 1 to target:\n      i. dp[i][j] = dp[i-1][j] (not taking the current element) OR dp[i-1][j-arr[i]] (taking the current element, if j >= arr[i]).\n5. The final answer is dp[n-1][target], which tells us if it's possible to form a subset with sum equal to half of the total sum using all elements.\n6. Example with arr = [1, 5, 11, 5], n = 4:\n   a. Total sum = 22, which is even. Target = 11.\n   b. Initialize dp array with dp[i][0] = true for all i, and dp[0][1] = true.\n   c. Fill the dp table according to the recurrence relation.\n   d. The final result is dp[3][11] = true, which means it's possible to form a subset with sum 11.\n   e. The two subsets would be {1, 5, 5} and {11}, both with sum 11.\n7. Time Complexity: O(n * target) where n is the number of elements and target is half of the total sum.\n8. Space Complexity: O(n * target) for the dp array.",
    "code": "public boolean equalPartition(int n, int[] arr) {\n    int totSum = 0;\n    for (int num : arr) totSum += num;\n    if (totSum % 2 == 1) return false;\n    int target = totSum / 2;\n    boolean[][] dp = new boolean[n][target + 1];\n    for (int i = 0; i < n; i++) dp[i][0] = true;\n    if (arr[0] <= target) dp[0][arr[0]] = true;\n    for (int ind = 1; ind < n; ind++) {\n        for (int cap = 1; cap <= target; cap++) {\n            boolean notTaken = dp[ind - 1][cap];\n            boolean taken = false;\n            if (arr[ind] <= cap) taken = dp[ind - 1][cap - arr[ind]];\n            dp[ind][cap] = notTaken || taken;\n        }\n    }\n    return dp[n - 1][target];\n}"
  },
  {
    "name": "Is Subset Sum",
    "endpoint": "/api/dynamic-programming/is-subset-sum",
    "methodName": "isSubsetSum",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 5, "arr": [3, 34, 4, 12, 5], "sum": 9 },
    "description": "Given an array of non-negative integers and a target sum, determine if there exists a subset of the array that adds up exactly to the target sum. For example, with array [3,34,4,12,5] and target sum 9: We could try {3,4,2} = 9 (not possible as 2 isn't in array), or {3,5,1} = 9 (not possible), or {4,5} = 9 (this works!). Therefore, there exists at least one subset (namely [4,5]) whose sum equals the target 9. Similarly, for target 10, no subset would sum to exactly 10, so we would return false.",
    "approach": "1. The Is Subset Sum problem asks us to determine whether there exists a subset of the given array whose sum equals the target sum.\n2. This is a classic dynamic programming problem that can be solved using a bottom-up approach.\n3. We use a 2D boolean array dp[n][sum+1] where dp[i][j] represents whether it's possible to form a subset with sum j using the first i+1 elements of the array.\n4. The key steps in the approach are:\n   a. Initialize dp[i][0] = true for all i (it's always possible to form a subset with sum 0 by not taking any elements).\n   b. Initialize dp[0][arr[0]] = true if arr[0] <= sum (we can form a subset with sum arr[0] by taking just the first element).\n   c. For each element i from 1 to n-1 and each possible sum j from 1 to sum:\n      i. dp[i][j] = dp[i-1][j] (not taking the current element) OR dp[i-1][j-arr[i]] (taking the current element, if j >= arr[i]).\n5. The final answer is dp[n-1][sum], which tells us if it's possible to form a subset with the target sum using the given array.\n6. Example with n = 5, arr = [3, 34, 4, 12, 5], sum = 9:\n   a. Initialize dp array with dp[i][0] = true for all i, and dp[0][3] = true (since 3 is the first element and 3 <= 9).\n   b. Process the elements one by one:\n      i. For element 34 at index 1: dp[1][j] = dp[0][j] OR dp[0][j-34] (if j >= 34). Since 34 > 9, dp[1][j] = dp[0][j] for all j <= 9.\n      ii. For element 4 at index 2: dp[2][j] = dp[1][j] OR dp[1][j-4] (if j >= 4). Now dp[2][3] = true (from dp[1][3]), dp[2][4] = true (from dp[1][4] = false OR dp[1][0] = true), and so on.\n      iii. Continue for the remaining elements...\n   c. The final result is dp[4][9] = true, which means it's possible to form a subset with sum 9.\n   d. Indeed, the subset {4, 5} has a sum of 9.\n7. Time Complexity: O(n * sum) where n is the number of elements and sum is the target sum.\n8. Space Complexity: O(n * sum) for the dp array.",
    "code": "public boolean isSubsetSum(int n, int[] arr, int sum) {\n    boolean[][] dp = new boolean[n][sum + 1];\n    for (int i = 0; i < n; i++) dp[i][0] = true;\n    if (arr[0] <= sum) dp[0][arr[0]] = true;\n    for (int ind = 1; ind < n; ind++) {\n        for (int target = 1; target <= sum; target++) {\n            boolean notTaken = dp[ind - 1][target];\n            boolean taken = false;\n            if (arr[ind] <= target) taken = dp[ind - 1][target - arr[ind]];\n            dp[ind][target] = notTaken || taken;\n        }\n    }\n    return dp[n - 1][sum];\n}"
  },
  {
    "name": "Count Ways to Reach Nth Stair",
    "endpoint": "/api/dynamic-programming/count",
    "methodName": "count",
    "serviceFile": "DynamicProgrammingService.java",
    "defaultInput": { "n": 4 },
    "description": "Given a staircase with n stairs, count the number of distinct ways to climb to the top if you can climb either 1 or 2 stairs at a time. For example, if n=4: You can climb as [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], or [2,2], giving 5 total ways. Similarly, for n=3, you can climb as [1,1,1], [1,2], or [2,1], giving 3 ways. For n=2, you can climb as [1,1] or [2], giving 2 ways. The pattern follows the Fibonacci sequence where each number represents the ways to reach that stair.",
    "approach": "1. The Count Ways to Reach Nth Stair problem asks us to count the number of ways to climb to the nth stair when we can take either 1 or 2 steps at a time.\n2. This is a classic dynamic programming problem that follows the pattern of the Fibonacci sequence.\n3. For each stair i, we can reach it either by taking a single step from stair i-1 or by taking a 2-step from stair i-2.\n4. We use a top-down dynamic programming approach with memoization:\n   a. Define dp[i] as the number of ways to reach the ith stair.\n   b. The recurrence relation is: dp[i] = dp[i-1] + dp[i-2]\n   c. Base cases are:\n      i. dp[0] = 1 (one way to reach the 0th stair - don't climb at all)\n      ii. dp[1] = 1 (one way to reach the 1st stair - take one step)\n      iii. For negative i, we return 0 (can't go below the ground)\n5. Example with n = 4:\n   a. dp[4] = dp[3] + dp[2]\n   b. dp[3] = dp[2] + dp[1] = dp[2] + 1\n   c. dp[2] = dp[1] + dp[0] = 1 + 1 = 2\n   d. dp[3] = 2 + 1 = 3\n   e. dp[4] = 3 + 2 = 5\n   So there are 5 ways to reach the 4th stair:\n   - 1+1+1+1\n   - 1+1+2\n   - 1+2+1\n   - 2+1+1\n   - 2+2\n6. Time Complexity: O(n) because each stair is computed exactly once thanks to memoization.\n7. Space Complexity: O(n) for the dp array, plus O(n) for the recursion stack in the worst case.",
    "code": "public int count(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, -1);\n    return countHelper(n, dp);\n}\n\nprivate int countHelper(int n, int[] dp) {\n    if (n == 0) return 1;\n    if (n < 0) return 0;\n    if (dp[n] != -1) return dp[n];\n    \n    return dp[n] = countHelper(n - 1, dp) + countHelper(n - 2, dp);\n}"
  }
]